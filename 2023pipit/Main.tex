%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%% For submission and review of your manuscript please change the
%% command to \documentclass[manuscript, screen, review]{acmart}.
%%
%% When submitting camera ready or to TAPS, please change the command
%% to \documentclass[sigconf]{acmart} or whichever template is required
%% for your publication.
\documentclass[sigplan,screen]{acmart}

% any of these necessary?
% \usepackage{amssymb}
\usepackage{amsthm}
% \usepackage{graphicx}
\usepackage{amsmath}
% \usepackage{mathptmx}
\usepackage{mathtools}
% \usepackage{stmaryrd}
% \usepackage{adjustbox}
% \usepackage{hyperref}
% \usepackage{alltt}
% \usepackage{url}
% \usepackage{float}
% \usepackage{minipage-marginpar}

% \usepackage{cite}

\usepackage{style/utils}
\usepackage{style/code}
\usepackage{style/proof}
\usepackage{style/keywords}
\usepackage{style/judgements}

\setcopyright{acmcopyright}
\copyrightyear{2023}
\acmYear{2023}
\acmDOI{XXXXXXX.XXXXXXX}

\acmConference[TyDe '23]{In submission}{2023}{In submission}
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
% \acmPrice{15.00}
% \acmISBN{978-1-4503-XXXX-X/18/06}
%%\acmSubmissionID{123-A56-BU3}

\begin{document}

\title{Pipit: Reactive Systems in \fstar ~(Extended Abstract)}

\newcommand{\affiliationANU}{
  \affiliation{%
  \institution{Australian National University}
  \city{Canberra}
  \country{Australia}
}
}

\author{Amos Robinson}
% \authornote{}
\email{amos.robinson@anu.edu.au}
\orcid{0009-0004-4837-4981}
\affiliationANU{}
\author{Alex Potanin}
% \authornotemark[1]
\email{alex.potanin@anu.edu.au}
\orcid{0000-0002-4242-2725}
\affiliationANU{}

% \renewcommand{\shortauthors}{Robinson et al.}

\begin{abstract}
  Reactive languages such as Lustre and Scade are used to implement safety-critical control systems; proving such programs correct and having the proved properties apply to the compiled code is therefore equally critical.
  We introduce Pipit, a simple reactive language embedded in \fstar{}, designed for verifying control systems and executing them in real-time.
  Pipit includes a verified translation to transition systems; by reusing \fstar{}'s existing proof automation, certain safety properties can be automatically proved using k-induction on the transition system.
  Pipit can also generate imperative code in \lowstar{}, a subset of \fstar{} which is suitable for compilation and real-time execution on embedded devices.
  This translation to imperative code has been proved to preserve types; the proof that the generated imperative code preserves semantics is future work.
\end{abstract}

%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
\begin{CCSXML}
<ccs2012>
    <concept>
        <concept_id>10010520.10010553.10010562.10010564</concept_id>
        <concept_desc>Computer systems organization~Embedded software</concept_desc>
        <concept_significance>300</concept_significance>
        </concept>
    <concept>
        <concept_id>10010520.10010570.10010572</concept_id>
        <concept_desc>Computer systems organization~Real-time languages</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
    <concept>
        <concept_id>10003752.10010124.10010138.10010142</concept_id>
        <concept_desc>Theory of computation~Program verification</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
    <concept>
        <concept_id>10003752.10003790.10003793</concept_id>
        <concept_desc>Theory of computation~Modal and temporal logics</concept_desc>
        <concept_significance>100</concept_significance>
        </concept>
    <concept>
        <concept_id>10011007.10011006.10011050.10011023</concept_id>
        <concept_desc>Software and its engineering~Specialized application languages</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
  </ccs2012>
\end{CCSXML}

\ccsdesc[300]{Computer systems organization~Embedded software}
\ccsdesc[500]{Computer systems organization~Real-time languages}
\ccsdesc[500]{Theory of computation~Program verification}
\ccsdesc[100]{Theory of computation~Modal and temporal logics}
\ccsdesc[500]{Software and its engineering~Specialized application languages}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Lustre, streaming, reactive, control}

\received{1 June 2023}
% \received[revised]{12 March 2009}
% \received[accepted]{5 June 2009}

\maketitle

% enable @verbatim@ syntax
\makeatactive

\section{Introduction}

Safety-critical control systems, such as the anti-lock braking systems that occur in most cars today, need to be correct and execute in real-time.
One approach, favoured by parts of the aerospace industry, is to implement the controllers in a high-level language such as Lustre~\cite{caspi1995functional} or Scade, and verify that the implementations satisfy the high-level specification using a model-checker, such as Kind2~\cite{champion2016kind2}.
These model-checkers can prove many interesting properties automatically, but do not provide many options for manual proofs when the automated proof techniques fail.
Additionally, the semantics used by the model-checker may not match the semantics of the compiled code, in which case properties proved do not necessarily hold on the real system.
This mismatch may occur even when the compiler has been verified correct, as in the case of Vélus~\cite{bourke2017formally}.
For example, in the Vélus compiler, integer division rounds towards zero, matching the semantics of C; however, integer division in Kind2 rounds to negative infinity, matching SMT-lib~\cite{BarFT2016SMTLIB}.

To be confident that our proofs hold on the real system, we need a single semantics that is shared between the compiler and the model-checker or prover.
In the following, we introduce Pipit, an embedded domain-specific language for implementing and verifying controllers in \fstar{}.
Pipit aims to provide a high-level language based on a clock-free subset of Lustre, while reusing \fstar{}'s proof automation and manual proofs for verifying controllers, and using \lowstar{}'s C-code generation for real-time execution.
% By designing Pipit as an embedded language, we can reuse many of the \fstar{} meta-language's features while retaining a small core language.
Pipit translates its expression language to a transition system for k-inductive proofs, which is verified\footnote{The translation is verified for a previous untyped expression representation; we are still finishing porting the proofs to the new typed representation.}; verifying the translation to imperative code is future work.

In this extended abstract, we will briefly describe the following preliminary results:

\begin{itemize}
  \item embedded language reduces the need for fancy features (\autoref{s:tut});
  \item normalisation and proof automation allow us to prove certain properties with minimal effort (\autoref{ss:tut:bibo});
  \item normalisation and extraction allows us to generate unverified executable code (\autoref{s:extraction});
\end{itemize}

We will also touch upon the following work-in-progress, which we intend to publish upon completion:

\begin{itemize}
  \item we describe the syntax (\autoref{s:core});
  \item a unified semantics for theorem proving and computation;
  \item verified imperative code generation;
  \item the ability to mix manual proofs with automated proofs
  \item further evaluation with the verification of a realistic controller
\end{itemize}

%CUT
% \begin{itemize}
%   \item We identify the invariants and lemmas required to prove correctness of the translation from a clock-free Lustre-style language to a transition system (\autoref{ss:meta-theory}).
%   \item We present a syntax-directed operational semantics for a clock-free Lustre-style language (\autoref{ss:operational-semantics}).
%     % TODO: CUT WAFFLE
%     This syntax-directed semantics is in contrast to previous \emph{relational} operational semantics of Lustre, which are not syntax-directed and require detailed proofs of determinism.
%     Proving determinism on our semantics requires only straightforward induction; we believe that this semantics may be better for proving other properties too.
%   \item We show preliminary results that demonstrate the effectiveness of Pipit by implementing a verified controller for a simple embedded system (\autoref{s:coffee-machine}).
% \end{itemize}


% \begin{itemize}
%   \item an embedded language makes it easier to express interesting programs with a small real-time synchronous core language;
%   \item by embedding in a language with good proof automation support, we can reason about embedded programs without much manual proof effort;
%   \item by embedding in a language with manual proof support, we can prove harder problems than existing model checkers; and
%   \item by embedding in a language with a well-defined extraction to (heap) allocation-free C code, we can get a partially verified compiler; so far we have only proved type preservation
% \end{itemize}

% \section{Pipit in flight}
\pagebreak
\section{Programming and verifying in Pipit}
\label{s:tut}

A common requirement in controllers is to filter an input signal, perhaps using a \emph{finite impulse response} (FIR) filter, which is equivalent to a weighted moving average.
An FIR filter takes an input signal and a vector of coefficients, and computes the dot product of the coefficients and the most recent values of the signal.
We can implement an FIR filter in Pipit as follows:

\begin{tabbing}
  @MM@\= @MMMMMM@ \= \kill
  @let@ fir ($\textit{coefficients}$: list $\RR$) ($s$: stream $\RR$): stream $\RR$ = \\
    \> @match@ $\textit{coefficients}$ @with@ \\
    \> @|@ $[]$ \> $\to 0$ \\
    \> @|@ $c :: \cs $ \> $\to (s \cdot c) + (\xfby{0}{(\mbox{fir~} \cs~s)})$
\end{tabbing}

Our FIR filter takes two arguments, one describing the coefficients and one describing the signal to filter.
The coefficient vector is represented by a list of reals here, while the signal $s$ is a \emph{stream} of reals, and the result is the filtered stream\footnote{The actual implementation uses integers with fixed-point arithmetic, but we use reals here to reduce clutter.}.
The implementation starts by looking at the list of coefficients, and returns zero if the list is empty.
If the list is not empty, then we multiply the most recent value of the stream by the coefficient ($s \cdot c$) and delay the result ($\xfby{0}{\ldots}$) of applying the remaining coefficients to the signal stream ($\mbox{fir~} \cs ~ s$), summing the two parts.
When there is no previous value, as is the case at the start of execution, the delay is given the initial value of zero.

Although this definition is simple, verifying it \emph{and} executing it in Lustre is somewhat impractical, as tool support varies widely.
To write this program in Lustre, we would likely need to reformulate the program to use arrays.
Vélus does not support arrays; Kind2 uses a custom syntax for arrays that no compiler supports; and Lustre v6 does support arrays, but its model-checker Lesar~\cite{raymond2008synchronous} does not.

Instead, we take the embedded language approach of defining a simple core language inside a theorem prover (\fstar{}), inspired by Bedrock~\cite{chlipala2013bedrock}.
By implementing Pipit as an embedded language, we can express the above FIR filter, but the lists are evaluated away by the meta-language to a simple core program which can be easily executed in statically-bounded runtime and space.
For example, we can compute the weighted moving average with two coefficients:

\newcommand\bibo{\mbox{bibo}}
\newcommand\fir{\mbox{fir}}
\newcommand\ii{\textit{input}}
\newcommand\oo{\textit{output}}
\newcommand\ok{\textit{ok}}
\begin{tabbing}
  @MM@\= @MMMMMM@ \= \kill
  @let@ $\mbox{fir}_2$ ($\ii$: stream $\RR$): stream $\RR$ = \\
    \> $\mbox{fir}~[0.7; 0.3] \ii$
\end{tabbing}

Which then normalises to the following simple definition:

\begin{tabbing}
    @MM@\= @MMMMMM@ \= \kill
      @let@ $\mbox{fir}_2$ ($\ii$: stream $\RR$): stream $\RR$ = \\
    \> $(0.7 \cdot \ii) + (\xfby{0}{((0.3 \cdot \ii) + (\xfby{0}{0}))})$
\end{tabbing}

To state properties about our filter, it is useful to be able to state temporal properties.
We do not need a separate specification language; instead, we can implement computable variants of temporal operators from \emph{past-time} linear temporal logic \cite{halbwachs1993executable,lichtenstein1985glory}.
We name the past-globally operator \emph{sofar}, as in \emph{the predicate has been true so far}:

\begin{tabbing}
  @MM@\= @MMMMMM@ \= \kill
  @let@ sofar ($p$: stream $\BB$): stream $\BB$ = \\
    \> $\xrec{p'}{p \wedge (\xfby{\top}{p'})}$
\end{tabbing}

This definition takes a stream of predicates $p$ and introduces a recursive stream $p'$.
At each step, the recursive stream $p'$ checks that the current predicate is true ($p$), and also checks that \emph{sofar} was previously true ($\xfby{\top}{p'}$).
If there is no previous value, it defaults to true.

\subsection{Bounded input, bounded output}
\label{ss:tut:bibo}
We can now state a \emph{bounded-input-bounded-output} (BIBO) property, which says that if the inputs have always been within some particular range, then the outputs are also within the range.
Such properties can occur as an internal invariant in a larger proof.

\begin{tabbing}
  @MM@\= @LET OUTPUT@\= @EXAMPLE1 INPUT@ \= \kill
  @let@ $\mbox{bibo}_2$ (n: $\RRgez$) ($\ii$: stream $\RR$): stream $\RR$ = \\
  \> @check@ $(\mbox{sofar}(|\ii| \le n)) \implies |\mbox{fir}_2~\ii| \le n)$
\end{tabbing}

This property states that, for this particular set of coefficients, if the input has always been in the range $[-n, n]$, then the output is also within the range $[-n, n]$.
Note that the upper bound $n$ is a nonnegative real rather than a stream of reals, which means that $n$ stays constant across the whole stream.
To prove that this property holds, we translate to a transition system.
In this case, simple induction over the transition relation is sufficient to prove the property.
There is some boilerplate required to perform the induction, but both base and step cases are automatically proved by \fstar{}:

\begin{tabbing}
  @MM@\= @MMMMMMMMMMMMMMMMMMMMMMM@ \= \kill
  @let@ $\mbox{proof}_2$ (n: $\RRgez$): Lemma (induct ($\bibo_2$ n)) = \\
  \> @assert@ (base\_case ($\bibo_2 ~n$)) \> @by@ (pipit\_simplify ()); \\
  \> @assert@ (step\_case ($\bibo_2 ~n$)) \> @by@ (pipit\_simplify ())
\end{tabbing}

This definition uses \fstar{}'s \emph{lemma} syntax to state that the BIBO property holds inductively for any $n$.
The two assertions prove the inductive cases separately, using our \emph{simplify} tactic to ensure that the translation to transition system is normalised away, and any translation artefacts are removed.

If we wish to prove a similar BIBO property for more coefficients, standard induction over the transition system is no longer sufficient; we need a stronger invariant.
One simple automated way to strengthen invariants is via \emph{k-induction}~\cite{hagen2008scaling}, which adds more context by assuming that the property holds for $k$ previous steps of the transition relation.
For example, we can define analogous functions $\fir_3$ and $\bibo_3$ which operate on the coefficients $[0.7; 0.2; 0.1]$, and use k-induction for $k = 2$:

\begin{tabbing}
  @MM@\= @MMMMMMMMMMMMMMMMMMMMMMMMMMM@ \= \kill
  @let@ $\mbox{proof}_3$ (n: $\RRgez$): Lemma (induct\_k 2 ($\bibo_3$ n)) = \\
  \> @assert@ (base\_case\_k 2 ($\bibo_3 ~n$)) \> @by@ (pipit\_simplify ()); \\
  \> @assert@ (step\_case\_k 2 ($\bibo_3 ~n$)) \> @by@ (pipit\_simplify ())
\end{tabbing}

Although the properties we have shown here boil down to simple properties about linear arithmetic, we believe that this example demonstrates a promising way to use \fstar{}'s existing proof automation for verifying reactive systems.

\pagebreak
\section{Core language}
\label{s:core}

\input{figures/core-grammar.tex}
% \input{figures/core-typing.tex}
% \input{figures/core-bigstep.tex}

The grammar of Pipit is defined in \autoref{f:core-grammar}.
The expression form $e$ includes standard syntax for values ($v$), variables ($x$) and applications ($e~e'$); however, it does not include any form for defining functions other than reusing closed functions from the \fstar{} meta-language.
Most of the expression forms were introduced informally in \autoref{s:tut} and correspond to the clock-free primitives in Lustre \cite{caspi1995functional}.
% The expression syntax for delayed streams ($\xfby{v}{e}$) denotes the previous value of the stream $e$, with an initial value of $v$ when there is no previous value.
Streams can be composed together using the \emph{then} notation ($\xthen{e}{e'}$) which denotes that the value of stream $e$ is used for the first step, followed by the latest values from stream $e'$ for subsequent steps.

Recursive streams, which can refer to previous values of the stream itself, are defined using the fixpoint operator ($\xrec{x}{e[x]}$); the syntax $e[x]$ means that the variable $x$ can occur in $e$.
% To ensure that streams are productive,
As in Lustre, recursive streams can only refer to their previous values and must be \emph{guarded} by a delay: the stream $(\xrec{x}{\xfby{0}{(x + 1)}})$ is well-defined, but stream $(\xrec{x}{x + 1})$ is invalid and has no computational interpretation.
This form of recursion differs slightly from standard Lustre, which uses a set of mutually-recursive bindings.
We use this form to specify an operational semantics that is syntax-directed, as opposed to the mutually-recursive form in \citet{caspi1995functional} which is not syntax directed.
The syntax-directed semantics simplifies the proof of determinism; we believe it has simplified other necessary proofs too and will perform further evaluation.
Although we cannot express mutually-recursive bindings in the core syntax here, we can express them as a notation on the surface syntax at the expense of potentially duplicating expressions.




\section{Extraction}
\label{s:extraction}

Pipit can generate executable code which is suitable for real-time execution on embedded devices.
The code extraction is implemented in a currently-unverified transform that takes a deeply embedded representation of a Pipit expression and generates an imperative representation of the program.
\fstar{} can generate C code from a subset of the language called \lowstar{}~\cite{protzenko2017verified}.
The result of our translation to imperative code fits in this subset.
During code extraction, we use \fstar{}'s tactic support~\cite{martinez2019meta} to fully normalise the translation to imperative code, similar to staged compilation.

% For the simple examples in \autoref{ss:tut:bibo}, we probably could have proved the properties directly on the generated code.
% In the future, however, we intend to support the abstraction of streams through \emph{contracts}, which require a relational semantics rather than a functional one.

% noextract
% let expr = Sugar.run2 Pump.controller'

% noextract
% let system: Pipit.Exec.Exp.xexec expr =
%   XX.exec_of_exp expr

% [@@(Tac.postprocess_with XL.tac_extract)]
% let reset = XL.mk_reset system

% [@@(Tac.postprocess_with XL.tac_extract)]
% let step (inp: input) = XL.mk_step system (inp.estop, (inp.level_low, ()))
% This allows us to generate C code which executes in bounded space on embedded devices.

\section{Evaluation}
\label{s:coffee-machine}

To demonstrate the feasibility of Pipit, we have implemented and verified a simple controller.
This system controls a water-flow solenoid to fill the reservoir of a coffee machine with multiple safeguards to reduce the risk of flooding.
The controller has two boolean inputs: the \emph{stop} switch and the \emph{low level} indicator; it returns a boolean indicating whether to engage the solenoid.
The stop switch indicates whether the reservoir's lid is open or closed; the system should never operate while the lid is open as water could spill out.
The second safeguard is that the solenoid should not be engaged for more than a minute or so as this may indicate a leak; if so, the controller enters a terminal \emph{stuck} state.
Finally, to avoid banging the solenoid too often, the controller waits for ten seconds of low water level before trying to engage.

\newcommand\estop{\textit{stop}}
\newcommand\low{\textit{low}}
\newcommand\soltry{\textit{try}}
\newcommand\stuck{\textit{stuck}}
\newcommand\solen{\textit{engage}}
\begin{tabbing}
  @MM@\= @let@ engage \= @MMMM@ \= \kill
  @let@ $\mbox{reservoir}$ (\estop{} \low{}: stream $\BB$): stream $\BB$ = \\
  \> @let@ \soltry{} \> = true\_for \textit{TEN\_SECONDS} (not \estop{} $\wedge$ \low{}) @in@ \\
  \> @let@ \stuck{} \> = once (true\_for \textit{ONE\_MINUTE} \soltry{}) @in@ \\
  \> @let@ \solen{} \> = \soltry{} $\wedge$ not \stuck{} @in@ \\
  \> @check@ (\solen{} $\implies$ not \estop{}); \\
  \> @check@ (\solen{} $\implies$ \low{}); \\
  \> \solen{}
\end{tabbing}

As with the examples in \autoref{ss:tut:bibo}, the above properties can be inductively verified by \fstar{}'s proof automation.
We can also generate executable C code, which runs in real-time on a microcontroller in the first author's kitchen.

\section{Related work}

Earlier work verifying reactive systems used model-checking via explicit state-space exploration~\cite{raymond2008synchronous}; more recent work uses SMT solvers to find inductive proofs~\cite{hagen2008scaling,champion2016kind2} or check refinement types~\cite{chen2022synchronous}.
These model-checkers have definite advantages over the general-purpose-prover approach offered here: they can often generate concrete counterexamples that disprove properties; they can also implement advanced invariant generation techniques such as ICE~\cite{garg2014ice} and IC3/PDR~\cite{bradley2011sat,een2011efficient}.
However, these special-purpose model-checkers do not provide much assurance that the semantics they use for proofs matches the compiled code.
We believe that once Pipit's imperative code generation is verified, Pipit will have a stronger assurance case.

Early work embedding a denotational semantics of Lucid Synchrone in an interactive theorem prover focussed on the semantics itself, rather than proving programs~\cite{boulme2001clocked}.
There is ongoing work to construct a denotational semantics of Vélus for program verification~\cite{bourke2022towards}.
We believe that the hybrid SMT approach of \fstar{} will allow for a better mixture of automated proofs with manual proofs;
however, the trusted computing base of Pipit is much larger than Vélus, as we depend on all of \fstar{}, \lowstar{}'s C code extraction, the SMT solver, and our currently-unverified imperative code generator.

% Refinement types have also been used to verify reactive systems~\cite{chen2022synchronous}, but this work does not address the issue of correct compilation.

% cite also:
% hardware language in Agda \cite{harrison2021mechanized}
% Refinement types for Zélus \cite{chen2022synchronous}
% Invariant generation: ICE \cite{garg2014ice}; template-based \cite{kahsai2011instantiation}; PDR explanation \cite{een2011efficient}; IC3 first introduced \cite{bradley2011sat}

% Other compilers for Lustre-style languages, such as Vélus \cite{bourke2017formally} and Heptagon \cite{gerard2012modular} ensure that the generated code can be executed in bounded memory and that each step takes a bounded time.
% With a carefully chosen set of primitives, the core streaming operations shown here would ensure bounded memory and time.
% For practicality, however, we currently allow embedding arbitrary total functions from the \fstar{} meta-language, which are not necessarily bounded in time.
% (Is this the same as Lucid Synchrone and Zélus? \CITE)

\section{Conclusion}

We believe that these preliminary results show promise.
In the intermediate future, we intend to verify the imperative code generation.

TODO
Future work: verify imperative code generation; verify CSE; case studies: antilock braking; clocks \cite{caspi1995functional}; contracts \cite{champion2016kind2}.

% \pagebreak

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{Main}


% \appendix

\end{document}
\endinput
%%
%% End of file `sample-sigplan.tex'.

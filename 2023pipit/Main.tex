%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%% For submission and review of your manuscript please change the
%% command to \documentclass[manuscript, screen, review]{acmart}.
%%
%% When submitting camera ready or to TAPS, please change the command
%% to \documentclass[sigconf]{acmart} or whichever template is required
%% for your publication.
\documentclass[sigplan,screen, review]{acmart}

% any of these necessary?
% \usepackage{amssymb}
\usepackage{amsthm}
% \usepackage{graphicx}
\usepackage{amsmath}
% \usepackage{mathptmx}
\usepackage{mathtools}
% \usepackage{stmaryrd}
% \usepackage{adjustbox}
% \usepackage{hyperref}
% \usepackage{alltt}
% \usepackage{url}
% \usepackage{float}
% \usepackage{minipage-marginpar}

\usepackage{style/utils}
\usepackage{style/code}
\usepackage{style/proof}
\usepackage{style/keywords}
\usepackage{style/judgements}

\setcopyright{acmcopyright}
\copyrightyear{2023}
\acmYear{2023}
\acmDOI{XXXXXXX.XXXXXXX}

\acmConference[TyDe '23]{In submission}{2023}{In submission}
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
% \acmPrice{15.00}
% \acmISBN{978-1-4503-XXXX-X/18/06}
%%\acmSubmissionID{123-A56-BU3}

\begin{document}

\title{Pipit: Reactive Systems in \fstar ~(Extended Abstract)}

\newcommand{\affiliationANU}{
  \affiliation{%
  \institution{Australian National University}
  \city{Canberra}
  \country{Australia}
}
}

\author{Amos Robinson}
% \authornote{}
\email{amos.robinson@anu.edu.au}
\orcid{0009-0004-4837-4981}
\affiliationANU{}
\author{Alex Potanin}
% \authornotemark[1]
\email{alex.potanin@anu.edu.au}
\orcid{0000-0002-4242-2725}
\affiliationANU{}

% \renewcommand{\shortauthors}{Robinson et al.}

\begin{abstract}
  Reactive languages such as Lustre and Scade are used to implement safety-critical control systems; proving such programs correct and having the proved properties apply to the compiled code is therefore equally critical.
  We introduce Pipit, a small reactive language embedded in \fstar{}, designed for verifying control systems and executing them in real-time.
  Pipit includes a verified translation to transition systems; by reusing \fstar{}'s existing proof automation, certain safety properties can be automatically proved by k-induction on the transition system.
  Pipit can also generate imperative code in a subset of \fstar{} which is suitable for compilation and real-time execution on embedded devices.
  This translation to imperative code preserves types by construction; the proof that the imperative code preserves semantics is ongoing.
\end{abstract}

%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
\begin{CCSXML}
<ccs2012>
    <concept>
        <concept_id>10010520.10010553.10010562.10010564</concept_id>
        <concept_desc>Computer systems organization~Embedded software</concept_desc>
        <concept_significance>300</concept_significance>
        </concept>
    <concept>
        <concept_id>10010520.10010570.10010572</concept_id>
        <concept_desc>Computer systems organization~Real-time languages</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
    <concept>
        <concept_id>10003752.10010124.10010138.10010142</concept_id>
        <concept_desc>Theory of computation~Program verification</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
    <concept>
        <concept_id>10003752.10003790.10003793</concept_id>
        <concept_desc>Theory of computation~Modal and temporal logics</concept_desc>
        <concept_significance>100</concept_significance>
        </concept>
    <concept>
        <concept_id>10011007.10011006.10011050.10011023</concept_id>
        <concept_desc>Software and its engineering~Specialized application languages</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
  </ccs2012>
\end{CCSXML}

\ccsdesc[300]{Computer systems organization~Embedded software}
\ccsdesc[500]{Computer systems organization~Real-time languages}
\ccsdesc[500]{Theory of computation~Program verification}
\ccsdesc[100]{Theory of computation~Modal and temporal logics}
\ccsdesc[500]{Software and its engineering~Specialized application languages}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Lustre, streaming, reactive, control}

\received{1 June 2023}
% \received[revised]{12 March 2009}
% \received[accepted]{5 June 2009}

\maketitle

% enable @verbatim@ syntax
\makeatactive

\section{Introduction}

Safety-critical control systems, such as the anti-lock braking systems that are present in most cars today, need to be correct and execute in real-time.
One approach, favoured by parts of the aerospace industry, is to implement the controllers in a high-level language such as Lustre~\cite{caspi1995functional} or Scade~\cite{colaco2017scade}, and verify that the implementations satisfy the high-level specification using a model-checker, such as Kind2~\cite{champion2016kind2}.
These model-checkers can prove many interesting properties automatically, but do not provide many options for manual proofs when the automated proof techniques fail.
Additionally, the semantics used by the model-checker may not match the semantics of the compiled code, in which case properties proved do not necessarily hold on the real system.
This mismatch may occur even when the compiler has been verified correct, as in the case of Vélus~\cite{bourke2017formally}.
For example, in the Vélus compiler, integer division rounds towards zero, matching the semantics of C; however, integer division in Kind2 rounds to negative infinity, matching SMT-lib~\cite{BarFT2016SMTLIB}.
% TODO: link to Kind2 issue?

To be confident that our proofs hold on the real system, we need a single semantics that is shared between the compiler and the model-checker or prover.
In this abstract we introduce Pipit\footnote{Implementation available at \url{https://github.com/songlarknet/pipit}}, an embedded domain-specific language for implementing and verifying controllers in \fstar{}.
Pipit aims to provide a high-level language based on a subset of Lustre, while reusing \fstar{}'s proof automation and manual proofs for verifying controllers~\cite{martinez2019meta}, and using \lowstar{}'s C-code generation for real-time execution~\cite{protzenko2017verified}.
% By designing Pipit as an embedded language, we can reuse many of the \fstar{} meta-language's features while retaining a small core language.
Pipit translates its expression language to a transition system for k-inductive proofs, which is verified; verifying the translation to imperative code is ongoing.

In this extended abstract we briefly describe the following preliminary results, which we intend to describe fully in a future publication:

\begin{itemize}
  \item we motivate Pipit which, as an embedded language, provides syntactic convenience with a small verifiable core language (\autoref{s:tut});
  \item we demonstrate the use of \fstar{}'s existing normalisation and proof automation to prove certain properties with minimal effort (\autoref{ss:tut:bibo});
  \item we describe a key difference between Pipit's core language and Lustre (\autoref{s:core}); and
  % \item we demonstrate the use of normalisation, tactics and \lowstar{} extraction to generate unverified executable code (\autoref{s:extraction}); and
  \item we evaluate Pipit by executing a verified controller on an embedded system (\autoref{s:coffee-machine}).
\end{itemize}

%CUT
% \begin{itemize}
%   \item We identify the invariants and lemmas required to prove correctness of the translation from a clock-free Lustre-style language to a transition system (\autoref{ss:meta-theory}).
%   \item We present a syntax-directed operational semantics for a clock-free Lustre-style language (\autoref{ss:operational-semantics}).
%     % TODO: CUT WAFFLE
%     This syntax-directed semantics is in contrast to previous \emph{relational} operational semantics of Lustre, which are not syntax-directed and require detailed proofs of determinism.
%     Proving determinism on our semantics requires only straightforward induction; we believe that this semantics may be better for proving other properties too.
%   \item We show preliminary results that demonstrate the effectiveness of Pipit by implementing a verified controller for a simple embedded system (\autoref{s:coffee-machine}).
% \end{itemize}


% \begin{itemize}
%   \item an embedded language makes it easier to express interesting programs with a small real-time synchronous core language;
%   \item by embedding in a language with good proof automation support, we can reason about embedded programs without much manual proof effort;
%   \item by embedding in a language with manual proof support, we can prove harder problems than existing model checkers; and
%   \item by embedding in a language with a well-defined extraction to (heap) allocation-free C code, we can get a partially verified compiler; so far we have only proved type preservation
% \end{itemize}

% \section{Pipit in flight}
% \pagebreak
\section{Programming and verifying in Pipit}
\label{s:tut}

A common requirement in controllers is to filter an input signal, perhaps using a \emph{finite impulse response} (FIR) filter, which is equivalent to a weighted moving average.
An FIR filter takes a vector of coefficients and an input signal; at every point in time, it computes the dot product of the coefficients and the most recent values of the signal.
We can implement an FIR filter in Pipit as follows:

\newcommand\signal{\textit{signal}}
\begin{tabbing}
  @MM@\= @MMMMMM@ \= \kill
  @let@ fir ($\textit{coefficients}$: list $\RR$) ($\signal$: stream $\RR$): stream $\RR$ = \\
    \> @match@ $\textit{coefficients}$ @with@ \\
    \> @|@ $[]$ \> $\to 0$ \\
    \> @|@ $c :: \cs $ \> $\to (\signal \cdot c) + (\xfby{0}{(\mbox{fir~} \cs~\signal)})$
\end{tabbing}

% Our FIR filter takes two arguments, one describing the coefficients and one describing the signal to filter.
The coefficient vector is represented by a list of reals, while the signal is a \emph{stream} of reals, and the result is the filtered stream.
% \footnote{The actual implementation uses integers with fixed-point arithmetic, but we use reals here to reduce clutter.}
The implementation starts by looking at the list of coefficients, and returns zero if the list is empty.
If the list is not empty, then we multiply the most recent value of the stream by the coefficient ($\signal \cdot c$); we also take the result of applying the remaining coefficients to the signal stream ($\mbox{fir~} \cs ~ \signal$) and delay it ($\xfby{0}{\ldots}$) before finally summing the two parts.
At the start of execution the delay is initialised to zero.

Although this is a simple definition, verifying it \emph{and} executing it in Lustre is somewhat impractical, as tool support varies widely.
To write this program in Lustre, we would likely need to reformulate the program to use arrays.
Vélus does not support arrays~\cite{bourke2017formally}; Kind2 uses a custom syntax for arrays without compiler support~\cite{champion2016kind2}; and Lustre V6 does support arrays~\cite{jahier2016lustre}, but its model-checker Lesar cannot reason about integers or reals~\cite{raymond2008synchronous}.
%TODO defer explanation to related work

Instead, inspired by Bedrock~\cite{chlipala2013bedrock}, we define Pipit as a small core language embedded inside a theorem prover (\fstar{} in our case).
By implementing Pipit as an embedded language, we can express the above FIR filter, but the lists are evaluated away by the meta-language to a simple core program without lists or arrays.
For example, we can compute the weighted moving average with the following concrete coefficients:

\newcommand\bibo{\mbox{bibo}}
\newcommand\fir{\mbox{fir}}
\newcommand\ii{\textit{input}}
\newcommand\oo{\textit{output}}
\newcommand\ok{\textit{ok}}
\begin{tabbing}
  @MM@\= @MMMMMM@ \= \kill
  @let@ $\mbox{fir}_2$ ($\ii$: stream $\RR$): stream $\RR$ = \\
    \> $\mbox{fir}~[0.7; 0.3] \ii$
\end{tabbing}

Normalising the above definition of $\mbox{fir}_2$ removes all lists.
The result fits in the core language defined in \autoref{s:core}, for which we can generate real-time imperative code:

\begin{tabbing}
    @MM@\= @MMMMMM@ \= \kill
      @let@ $\mbox{fir}_2$ ($\ii$: stream $\RR$): stream $\RR$ = \\
    \> $(0.7 \cdot \ii) + (\xfby{0}{((0.3 \cdot \ii) + (\xfby{0}{0}))})$
\end{tabbing}

The properties that we want to state about reactive programs usually involve some temporal aspect.
Rather than defining a separate specification language, we implement computable variants of temporal operators from \emph{past-time} linear temporal logic \cite{halbwachs1993executable,lichtenstein1985glory}.
We name the past-globally operator \emph{sofar}, as in \emph{the predicate has been true so far}:

\begin{tabbing}
  @MM@\= @MMMMMM@ \= \kill
  @let@ sofar ($p$: stream $\BB$): stream $\BB$ = \\
    \> $\xrec{p'}{p \wedge (\xfby{@true@}{p'})}$
\end{tabbing}

This definition takes a stream of predicates $p$ and introduces a recursive stream $p'$.
At each step, the recursive stream $p'$ checks that the current predicate is true ($p$), and also checks that \emph{sofar} was previously true ($\xfby{@true@}{p'}$).
If there is no previous value, it defaults to true.

\subsection{Bounded input, bounded output}
\label{ss:tut:bibo}
We can now state a \emph{bounded-input-bounded-output} (BIBO) property, which says that if the inputs have always been within some particular range, then the outputs are also within the range.
Properties like this can occur as an internal invariant in a larger system:

\begin{tabbing}
  @MM@\= @LET OUTPUT@\= @EXAMPLE1 INPUT@ \= \kill
  @let@ $\mbox{bibo}_2$ (n: $\RRgez$) ($\ii$: stream $\RR$): stream $\BB$ = \\
  \> @check@ $(\mbox{sofar}(|\ii| \le n) \implies |\mbox{fir}_2~\ii| \le n)$
\end{tabbing}

This property states that if the input has always been in the range $[-n, n]$, then the output is also within the range $[-n, n]$.
Note that the upper bound $n$ is a nonnegative real rather than a stream of reals, which means that $n$ stays constant across the whole stream.
To prove that this property holds, we translate to a transition system and show that the stream is always true.
In this case, induction over the transition relation is sufficient to prove the property.
There is some boilerplate required to perform the induction, but both base and step cases are automatically proved by \fstar{}:

\begin{tabbing}
  @MM@\= @MMMMMMMMMMMMMMMMMMMMMMM@ \= \kill
  @let@ $\mbox{proof}_2$ (n: $\RRgez$): Lemma (induct ($\bibo_2$ n)) = \\
  \> @assert@ (base\_case ($\bibo_2 ~n$)) \> @by@ (pipit\_simplify ()); \\
  \> @assert@ (step\_case ($\bibo_2 ~n$)) \> @by@ (pipit\_simplify ())
\end{tabbing}

This definition uses \fstar{}'s \emph{lemma} syntax to state that the BIBO property holds inductively for any $n$.
The two assertions prove the inductive cases separately, using our \emph{simplify} tactic to ensure that the translation to transition system is normalised away, and any translation artefacts are removed.

If we wish to prove a similar BIBO property for a filter with more coefficients, standard induction over the transition system is no longer sufficient; we need a stronger invariant.
One simple automated way to strengthen invariants is via \emph{k-induction}~\cite{hagen2008scaling}, which adds more context by assuming that the property holds for $k$ previous steps of the transition relation.
We can define analogous functions $\fir_3$ and $\bibo_3$ which operate on the coefficients $[0.7; 0.2; 0.1]$, and use k-induction for $k = 2$ as follows:
% TODO: intuition, (0 fby x) < n = true fby (x < n)

\begin{tabbing}
  @MM@\= @MMMMMMMMMMMMMMMMMMMMMMMMMMM@ \= \kill
  @let@ $\mbox{proof}_3$ (n: $\RRgez$): Lemma (induct\_k 2 ($\bibo_3$ n)) = \\
  \> @assert@ (base\_case\_k 2 ($\bibo_3 ~n$)) \> @by@ (pipit\_simplify ()); \\
  \> @assert@ (step\_case\_k 2 ($\bibo_3 ~n$)) \> @by@ (pipit\_simplify ())
\end{tabbing}

Although the properties here boil down to simple properties about linear arithmetic, we believe that this example demonstrates a promising way to use \fstar{}'s existing proof automation for verifying reactive systems.

% \pagebreak
\section{Core language}
\label{s:core}

\input{figures/core-grammar.tex}
% \input{figures/core-typing.tex}
% \input{figures/core-bigstep.tex}

The grammar of Pipit is defined in \autoref{f:core-grammar}.
The expression form $e$ includes standard syntax for values ($v$), variables ($x$) and applications ($e~e'$); however, it does not include any form for defining functions except reusing closed functions from the \fstar{} meta-language $(\mlamX{})$.
Most of the expression forms were introduced informally in \autoref{s:tut} and correspond to the clock-free primitives in Lustre \cite{caspi1995functional}.
% The expression syntax for delayed streams ($\xfby{v}{e}$) denotes the previous value of the stream $e$, with an initial value of $v$ when there is no previous value.
Streams can be composed together using the \emph{then} notation ($\xthen{e}{e'}$) which denotes that the value of stream $e$ is used for the first step, followed by the latest values from stream $e'$ for subsequent steps.

Recursive streams, which can refer to previous values of the stream itself, are defined using the fixpoint operator ($\xrec{x}{e[x]}$); the syntax $e[x]$ means that the variable $x$ can occur in $e$.
% To ensure that streams are productive,
As in Lustre, recursive streams can only refer to their previous values and must be \emph{guarded} by a delay: the stream $(\xrec{x}{\xfby{0}{(x + 1)}})$ is well-defined, but stream $(\xrec{x}{x + 1})$ is invalid and has no computational interpretation.
This form of recursion differs slightly from standard Lustre, which uses a set of mutually-recursive bindings.
We use this form to define a substitution-based operational semantics that is syntax-directed, as opposed to the mutually-recursive form in \citet{caspi1995functional} which is not syntax directed.
The syntax-directed semantics simplifies the proof of determinism; we believe it has simplified other necessary proofs too and will perform further evaluation.
Although we cannot express mutually-recursive bindings in the core syntax here, we can express them as a notation on the surface syntax at the expense of potentially duplicating expressions.


\section{Extraction}
\label{s:extraction}

Pipit can generate executable code which is suitable for real-time execution on embedded devices.
The code extraction is implemented in a currently-unverified transform that takes a deeply embedded representation of a Pipit expression and generates a shallow imperative representation of the program.
\fstar{} can generate C code from a subset of the language called \lowstar{}~\cite{protzenko2017verified}.
The result of our translation to imperative code fits in this subset.
During code extraction, we use \fstar{}'s tactic support~\cite{martinez2019meta} to fully normalise the translation to imperative code, similar to staged compilation.

% For the simple examples in \autoref{ss:tut:bibo}, we probably could have proved the properties directly on the generated code.
% In the future, however, we intend to support the abstraction of streams through \emph{contracts}, which require a relational semantics rather than a functional one.

% noextract
% let expr = Sugar.run2 Pump.controller'

% noextract
% let system: Pipit.Exec.Exp.xexec expr =
%   XX.exec_of_exp expr

% [@@(Tac.postprocess_with XL.tac_extract)]
% let reset = XL.mk_reset system

% [@@(Tac.postprocess_with XL.tac_extract)]
% let step (inp: input) = XL.mk_step system (inp.estop, (inp.level_low, ()))
% This allows us to generate C code which executes in bounded space on embedded devices.

\section{Evaluation}
\label{s:coffee-machine}

To demonstrate the feasibility of Pipit, we have implemented and verified a simple controller.
This system controls a water-flow solenoid to fill the reservoir of a coffee machine and includes multiple safeguards to reduce the risk of flooding\footnote{For a video of the controller in action, see \url{https://youtu.be/6IybbQFPOl8}}.
The controller has two boolean inputs: the \emph{stop} switch and the \emph{low level} indicator; it returns a boolean indicating whether to engage the solenoid.
The stop switch indicates whether the reservoir's lid is open or closed; the system should never operate while the lid is open as water could spill out.
The controller should not allow water to flow for more than a minute as this may indicate a leak; if so, the controller enters a terminal error state.
Finally, to avoid switching the solenoid too often, the controller waits for ten seconds of low water level before trying to engage.

\newcommand\estop{\textit{stop}}
\newcommand\low{\textit{low}}
\newcommand\soltry{\textit{try}}
\newcommand\error{\textit{error}}
\newcommand\solen{\textit{engage}}
\begin{tabbing}
  @MM@\= @let@ engage \= @MMMM@ \= \kill
  @let@ $\mbox{reservoir}$ (\estop{} \low{}: stream $\BB$): stream $\BB$ = \\
  \> @let@ \soltry{} \> = true\_for \textit{TEN\_SECONDS} (not \estop{} $\wedge$ \low{}) @in@ \\
  \> @let@ \error{} \> = any (true\_for \textit{ONE\_MINUTE} \soltry{}) @in@ \\
  \> @let@ \solen{} \> = \soltry{} $\wedge$ not \error{} @in@ \\
  \> @check@ (\solen{} $\implies$ not \estop{}); \\
  \> @check@ (\solen{} $\implies$ \low{}); \\
  \> \solen{}
\end{tabbing}

% Here, \emph{true\_for t} is time-bounded past-globally and \emph{any} is past-finally.
As with the examples in \autoref{ss:tut:bibo}, the two properties can be automatically verified.
% by \fstar{}'s proof automation.
Pipit generates real-time C code for this example.

\section{Related work}

Earlier work model-checking reactive systems used explicit state-space exploration~\cite{raymond2008synchronous}; more-recent work uses SMT solvers to find inductive proofs~\cite{hagen2008scaling,champion2016kind2} or to check refinement types~\cite{chen2022synchronous}.
These model-checkers have definite advantages over the general-purpose-prover approach offered here: they can often generate concrete counterexamples; they can also implement counterexample-based invariant-generation techniques such as ICE~\cite{garg2014ice} and PDR~\cite{bradley2011sat,een2011efficient}.
However, these model-checkers do not provide high assurance that the semantics they use for proofs matches the compiled code.
We believe that once Pipit's imperative code generation is verified, Pipit will have a stronger assurance case.

The embedded language Copilot generates real-time C code for runtime monitoring and supports model-checking properties \cite{laurent2015assuring}, but suffers from the same semantic gap.

Early work embedding a denotational semantics of Lucid Synchrone in an interactive theorem prover focussed on the semantics itself, rather than proving programs~\cite{boulme2001clocked}.
There is ongoing work to construct a denotational semantics of Vélus for program verification~\cite{bourke2022towards}.
We believe that the hybrid SMT approach of \fstar{} will allow for a better mixture of automated proofs with manual proofs;
however, the trusted computing base of Pipit is much larger than Vélus, as we depend on all of \fstar{}, \lowstar{}'s C code extraction, the SMT solver, and our currently-unverified imperative code generator.

% Refinement types have also been used to verify reactive systems~\cite{chen2022synchronous}, but this work does not address the issue of correct compilation.

% cite also:
% hardware language in Agda \cite{harrison2021mechanized}
% Refinement types for Zélus \cite{chen2022synchronous}
% Invariant generation: ICE \cite{garg2014ice}; template-based \cite{kahsai2011instantiation}; PDR explanation \cite{een2011efficient}; IC3 first introduced \cite{bradley2011sat}

% Other compilers for Lustre-style languages, such as Vélus \cite{bourke2017formally} and Heptagon \cite{gerard2012modular} ensure that the generated code can be executed in bounded memory and that each step takes a bounded time.
% With a carefully chosen set of primitives, the core streaming operations shown here would ensure bounded memory and time.
% For practicality, however, we currently allow embedding arbitrary total functions from the \fstar{} meta-language, which are not necessarily bounded in time.
% (Is this the same as Lucid Synchrone and Zélus? \CITE)

\section{Conclusion}

Our preliminary results show that \fstar{}'s proof automation and code extraction are suitable for verifying reactive systems and executing them in real-time; these results still require further work.
Next, we intend to verify the imperative code generation.
To verify large programs, we also need some way to compose smaller proofs together, such as contracts.
Finally, we need to evaluate Pipit on larger control systems before extending the language with clocks.

% TODO
% Future work: verify imperative code generation; verify CSE; case studies: antilock braking; clocks \cite{caspi1995functional}; contracts \cite{champion2016kind2}.

% \pagebreak

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{Main}


% \appendix

\end{document}
\endinput
%%
%% End of file `sample-sigplan.tex'.

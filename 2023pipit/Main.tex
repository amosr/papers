%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%% For submission and review of your manuscript please change the
%% command to \documentclass[manuscript, screen, review]{acmart}.
%%
%% When submitting camera ready or to TAPS, please change the command
%% to \documentclass[sigconf]{acmart} or whichever template is required
%% for your publication.
\documentclass[sigplan,screen]{acmart}

% any of these necessary?
% \usepackage{amssymb}
\usepackage{amsthm}
% \usepackage{graphicx}
\usepackage{amsmath}
% \usepackage{mathptmx}
% \usepackage{mathtools}
% \usepackage{stmaryrd}
% \usepackage{adjustbox}
% \usepackage{hyperref}
% \usepackage{alltt}
% \usepackage{url}
% \usepackage{float}
% \usepackage{minipage-marginpar}

\usepackage{style/utils}
\usepackage{style/code}
\usepackage{style/proof}
\usepackage{style/keywords}
\usepackage{style/judgements}

\setcopyright{acmcopyright}
\copyrightyear{2023}
\acmYear{2023}
\acmDOI{XXXXXXX.XXXXXXX}

\acmConference[TyDe '23]{In submission}{2023}{In submission}
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
% \acmPrice{15.00}
% \acmISBN{978-1-4503-XXXX-X/18/06}
%%\acmSubmissionID{123-A56-BU3}

\begin{document}

\title{Pipit: Reactive Systems in \fstar ~(Extended Abstract)}

\newcommand{\affiliationANU}{
  \affiliation{%
  \institution{Australian National University}
  \city{Canberra}
  \country{Australia}
}
}

\author{Amos Robinson}
% \authornote{}
\email{amos.robinson@anu.edu.au}
\orcid{0009-0004-4837-4981}
\affiliationANU{}
\author{Alex Potanin}
% \authornotemark[1]
\email{alex.potanin@anu.edu.au}
\orcid{0000-0002-4242-2725}
\affiliationANU{}

% \renewcommand{\shortauthors}{Robinson et al.}

\begin{abstract}
  Safety-critical control systems, such as the anti-lock braking systems in most cars today, need to be correct and execute in real-time.
  We could write these systems directly in an imperative language such as C or Rust and verify them, but it can be difficult to state high-level specifications about such low-level implementations.
  Another approach, favoured by large parts of the aerospace industry, is to implement the controllers in a high-level language such as Lustre or SCADE, and verify that the implementations satisfy the high-level specification using a model-checker.
  These model-checkers can prove many interesting properties automatically, but do not provide many options when the automated proof techniques fail.
  We introduce Pipit, an embedded domain-specific language for implementing and verifying such controllers in \fstar.
  Pipit aims to provide a high-level language similar to Lustre, while reusing \fstar's proof automation and manual proofs for verifying controllers, and using LowStar's C-code generation for real-time execution.
  Pipit translates its expression language to a transition system for k-inductive proofs, which is mostly verified; verifying the translation to imperative code is future work.
\end{abstract}

%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
\begin{CCSXML}
<ccs2012>
    <concept>
        <concept_id>10010520.10010553.10010562.10010564</concept_id>
        <concept_desc>Computer systems organization~Embedded software</concept_desc>
        <concept_significance>300</concept_significance>
        </concept>
    <concept>
        <concept_id>10010520.10010570.10010572</concept_id>
        <concept_desc>Computer systems organization~Real-time languages</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
    <concept>
        <concept_id>10003752.10010124.10010138.10010142</concept_id>
        <concept_desc>Theory of computation~Program verification</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
    <concept>
        <concept_id>10003752.10003790.10003793</concept_id>
        <concept_desc>Theory of computation~Modal and temporal logics</concept_desc>
        <concept_significance>100</concept_significance>
        </concept>
    <concept>
        <concept_id>10011007.10011006.10011050.10011023</concept_id>
        <concept_desc>Software and its engineering~Specialized application languages</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
  </ccs2012>
\end{CCSXML}

\ccsdesc[300]{Computer systems organization~Embedded software}
\ccsdesc[500]{Computer systems organization~Real-time languages}
\ccsdesc[500]{Theory of computation~Program verification}
\ccsdesc[100]{Theory of computation~Modal and temporal logics}
\ccsdesc[500]{Software and its engineering~Specialized application languages}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Lustre, streaming, reactive, control}

\received{1 June 2023}
% \received[revised]{12 March 2009}
% \received[accepted]{5 June 2009}

\maketitle

% enable @verbatim@ syntax
\makeatactive

\section{Introduction}

Cite: Kind2, Lustre, VÃ©lus.
Antilock brakes paper.
The original Kind~\cite{hagen2008verifying}.

\begin{verbatim}
  let veh_speed_estimate ()
\end{verbatim}

\section{Core language}
\label{s:core}

\input{figures/core-grammar.tex}
\input{figures/core-typing.tex}
\input{figures/core-bigstep.tex}

The grammar of Pipit is defined in \autoref{f:core-grammar}.
The expression form $e$ includes standard syntax for values ($v$), variables ($x$) and applications ($e~e'$); however, it does not include any form for defining functions other than reusing closed functions from the \fstar{} meta-language.
Most of the expression forms are equivalent to a simplified, clock-free primitives from standard Lustre-style languages \CITE.
The expression syntax for delayed streams ($\xfby{v}{e}$) denotes the previous value of the stream $e$, with an initial value of $v$ when there is no previous value.
Streams can be composed together using the \emph{then} notation ($\xthen{e}{e'}$) which denotes that the value of stream $e$ is used for the very first step, followed by the latest values from stream $e'$ for subsequent steps.

Recursive streams, which can refer to previous values of the stream itself, are defined using the fixpoint operator ($\xrec{x}{e[x]}$); the syntax $e[x]$ means that the variable $x$ can occur in $e$.
To ensure that streams are productive, recursive equations can only refer to their previous values and must be \emph{guarded} by a delay; this restriction is formalised by the causality check in \REF{}.
This form of recursion differs somewhat from standard Lustre, which uses a set of mutually recursive bindings.
In \autoref{ss:operational-semantics} we will see that this form of recursion allows a syntax-directed semantics, but at the cost of potentially duplicating work.

Let-expressions ($\xlet{x}{e}{e'}$) are standard.
Finally, check-expressions ($\xcheck{e}{e'}$) are used to describe properties that the program should satisfy.
This operation corresponds roughly to the @assert@ primitive in \fstar{}; however we avoid this name, as @assert@ is historically treated as an unchecked assumption in many Lustre languages.

The grammar for values $v$ includes natural numbers, integers and functions embedded from the \fstar{} meta-language.
We denote functions in the meta-language by the explicit meta-lambda notation ($\mlamX{}$) to avoid any potential ambiguity between Pipit expressions ($e$) and meta-expressions ($\metafy{e}$).

\subsection{Typing rules}
\label{ss:typing-rules}

The typing rules of Pipit are defined in \autoref{f:core-typing}, with the judgment form $\typing{\Gamma}{e}{\tau}$ that checks expression $e$ under streaming context $\Gamma$.
The grammar of types (\autoref{f:core-grammar}) distinguishes between bounded-size primitive types ($\primty$) and potentially higher-order types ($\tau$), which allows us to restrict streaming operations to only require bounded buffers.
\TODO{Not sure if this restriction is useful, as arbitrary functions can still use however much memory and time as they want.}

For values (rule TValue), we reuse the \fstar{} meta-language's typing judgment ($\mtyping{}{v}{\tau}$) for typing closed values $v$.
Otherwise, most of the rules are standard.

\subsection{Operational semantics}
\label{ss:operational-semantics}

The operational semantics, expressed as a bigstep relation, are defined in \autoref{f:core-bigstep}.
The judgment form $\bigstep{\Sigma}{e}{v}$ takes a \emph{stream history} ($\Sigma$), which is a non-empty sequence of stores, as well as an expression to evaluate ($e$) and the final value ($v$).

Rule Value denotes that a value evaluates to itself under any streaming history.
Rule Var denotes that evaluating a variable requires looking it up in the right-most (most recent) store; the syntax $\Sigma_\bot; \sigma$ means that this rule applies to any streaming history with one or more steps.
Rule App-Meta allows applying functions on the meta-level; the syntax $(\mlamX{}) v'$ refers to meta-level application of some meta-term.

The rules $\mbox{Fby}_1$ and $\mbox{Fby}_S$ describe the semantics of delayed streams.
Rule $\mbox{Fby}_1$ denotes that when a delay $\xfby{v}{e}$ is evaluated in a context with exactly one step --- that is, at the very start of program execution --- it simply returns the initial value $v$.
Rule $\mbox{Fby}_S$ applies when the same delay is evaluated in a context with strictly more than one step ($\Sigma; \sigma$), in which case, the most recent step is discarded, and the original expression $e$ is evaluated under the previous history.

Next, rules ($\xthenarrow_1$) and ($\xthenarrow_S$) describe the semantics of streams composed by \emph{then}-expressions; as with the rules for delayed streams, the first rule applies when the streaming history contains exactly one step, while the second applies for histories of strictly more than one step.

Rule ($\mu{}$) describes the semantics of recursive streams.
This rule performs a single unfolding of a recursive expression $\xrec{x}{e[x]}$ so that all occurrences of $x$ inside $e$ are replaced with the recursive expression itself.
This rule is not trivially terminating, but so long as any occurrences of the recursive binder are guarded by a delay, then all occurrences of the recursive binder will have a shorter stream history.
This intuition is formalised in \REF{}.

Rule Let uses a standard substitution-based semantics for let-expressions.
Finally, rule Check evaluates a property and requires it to be true ($\top$).

The semantics here, particularly the recursive rule, differ from previous semantics of Lustre.
In the reactive semantics of \CITEME{88}, as well as the coinductive semantics of VÃ©lus \CITEME{VÃ©lus}, the semantics for mutually recursive definitions is locally non-deterministic, in that the semantics does not define which particular order mutual definitions are evaluated in.
This local non-determinism complicates certain proofs, even though the overall evaluation \emph{is} deterministic \TODO{vague}.

In contrast, the semantics presented here is syntax-directed and completely deterministic.
We have a mechanised proof of variant of progress theorem for well-formed (\emph{causal}) programs as well as closure under substitution and determinism, which is described in \REF.
However, the substitution-based semantics here can duplicate expressions, and encoding mutually recursive definitions requires multiple substitutions.
For this reason, the semantics here is not suitable for actual execution.

\pagebreak
% \begin{acks}
%   acknowledgement
% \end{acks}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{Main}


% \appendix

\end{document}
\endinput
%%
%% End of file `sample-sigplan.tex'.

%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%% For submission and review of your manuscript please change the
%% command to \documentclass[manuscript, screen, review]{acmart}.
%%
%% When submitting camera ready or to TAPS, please change the command
%% to \documentclass[sigconf]{acmart} or whichever template is required
%% for your publication.
\documentclass[sigplan,screen]{acmart}

% any of these necessary?
% \usepackage{amssymb}
\usepackage{amsthm}
% \usepackage{graphicx}
\usepackage{amsmath}
% \usepackage{mathptmx}
% \usepackage{mathtools}
% \usepackage{stmaryrd}
% \usepackage{adjustbox}
% \usepackage{hyperref}
% \usepackage{alltt}
% \usepackage{url}
% \usepackage{float}
% \usepackage{minipage-marginpar}

\usepackage{style/utils}
\usepackage{style/code}
\usepackage{style/proof}
\usepackage{style/keywords}
\usepackage{style/judgements}

\setcopyright{acmcopyright}
\copyrightyear{2023}
\acmYear{2023}
\acmDOI{XXXXXXX.XXXXXXX}

\acmConference[TyDe '23]{In submission}{2023}{In submission}
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
% \acmPrice{15.00}
% \acmISBN{978-1-4503-XXXX-X/18/06}
%%\acmSubmissionID{123-A56-BU3}

\begin{document}

\title{Pipit: Reactive Systems in \fstar ~(Extended Abstract)}

\newcommand{\affiliationANU}{
  \affiliation{%
  \institution{Australian National University}
  \city{Canberra}
  \country{Australia}
}
}

\author{Amos Robinson}
% \authornote{}
\email{amos.robinson@anu.edu.au}
\orcid{0009-0004-4837-4981}
\affiliationANU{}
\author{Alex Potanin}
% \authornotemark[1]
\email{alex.potanin@anu.edu.au}
\orcid{0000-0002-4242-2725}
\affiliationANU{}

% \renewcommand{\shortauthors}{Robinson et al.}

\begin{abstract}
  Safety-critical control systems, such as the anti-lock braking systems in most cars today, need to be correct and execute in real-time.
  We could write these systems directly in an imperative language such as C or Rust and verify them, but it can be difficult to state high-level specifications about such low-level implementations.
  Another approach, favoured by large parts of the aerospace industry, is to implement the controllers in a high-level language such as Lustre or SCADE, and verify that the implementations satisfy the high-level specification using a model-checker.
  These model-checkers can prove many interesting properties automatically, but do not provide many options when the automated proof techniques fail.
  We introduce Pipit, an embedded domain-specific language for implementing and verifying such controllers in \fstar.
  Pipit aims to provide a high-level language similar to Lustre, while reusing \fstar's proof automation and manual proofs for verifying controllers, and using LowStar's C-code generation for real-time execution.
  Pipit translates its expression language to a transition system for k-inductive proofs, which is mostly verified; verifying the translation to imperative code is future work.
\end{abstract}

%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
\begin{CCSXML}
<ccs2012>
    <concept>
        <concept_id>10010520.10010553.10010562.10010564</concept_id>
        <concept_desc>Computer systems organization~Embedded software</concept_desc>
        <concept_significance>300</concept_significance>
        </concept>
    <concept>
        <concept_id>10010520.10010570.10010572</concept_id>
        <concept_desc>Computer systems organization~Real-time languages</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
    <concept>
        <concept_id>10003752.10010124.10010138.10010142</concept_id>
        <concept_desc>Theory of computation~Program verification</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
    <concept>
        <concept_id>10003752.10003790.10003793</concept_id>
        <concept_desc>Theory of computation~Modal and temporal logics</concept_desc>
        <concept_significance>100</concept_significance>
        </concept>
    <concept>
        <concept_id>10011007.10011006.10011050.10011023</concept_id>
        <concept_desc>Software and its engineering~Specialized application languages</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
  </ccs2012>
\end{CCSXML}

\ccsdesc[300]{Computer systems organization~Embedded software}
\ccsdesc[500]{Computer systems organization~Real-time languages}
\ccsdesc[500]{Theory of computation~Program verification}
\ccsdesc[100]{Theory of computation~Modal and temporal logics}
\ccsdesc[500]{Software and its engineering~Specialized application languages}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Lustre, streaming, reactive, control}

\received{1 June 2023}
% \received[revised]{12 March 2009}
% \received[accepted]{5 June 2009}

\maketitle

% enable @verbatim@ syntax
\makeatactive

\section{Introduction}

We are interested in verifying an antilock braking system for a motorcycle\cite{huang2010design}.

\begin{tabbing}
  @MM@\= @let @\= \kill
  @let@ veh\_speed\_estimate $\omega_F$ $\omega_R$ $a_z$ = \\
    \> @let@ $v_F$ = $\omega_F \cdot $ circumference @in@ \\
    \> @let@ $v_R$ = $\omega_R \cdot $ circumference @in@ \\
    \\
    \> @let rec@ $\floor{\hat{v}}$ = @if@ $v_F \approx_\epsilon v_R$ \\
    \> \> @then@ $\min v_F v_R$ \\
    \> \> @else@ $(\xthen{\min v_F v_R}{\xfby{0}{\floor{\hat{v}}}}) + a_z - \epsilon$ @in@ \\
    \> @let rec@ $\ceil{\hat{v}}$ = @if@ $v_F \approx_\epsilon v_R$ \\
    \> \> @then@ $\max v_F v_R$ \\
    \> \> @else@ $(\xthen{\max v_F v_R}{\xfby{0}{\ceil{\hat{v}}}}) + a_z + \epsilon$ @in@ \\
    \\
    \> $(\floor{\hat{v}}, \ceil{\hat{v}})$
\end{tabbing}

Cite: Kind2\cite{champion2016kind2}, Lustre\cite{caspi1995functional}, Vélus\cite{bourke2017formally}.
The original Kind\cite{hagen2008scaling}.

Past-time modal temporal logic \cite{lichtenstein1985glory}
Lustre support for temporal logic \cite{halbwachs1993executable}

\section{Core language}
\label{s:core}

\input{figures/core-grammar.tex}
\input{figures/core-typing.tex}
\input{figures/core-bigstep.tex}

The grammar of Pipit is defined in \autoref{f:core-grammar}.
The expression form $e$ includes standard syntax for values ($v$), variables ($x$) and applications ($e~e'$); however, it does not include any form for defining functions other than reusing closed functions from the \fstar{} meta-language.
Most of the expression forms are equivalent to a simplified, clock-free primitives from standard Lustre-style languages \cite{caspi1995functional}.
The expression syntax for delayed streams ($\xfby{v}{e}$) denotes the previous value of the stream $e$, with an initial value of $v$ when there is no previous value.
Streams can be composed together using the \emph{then} notation ($\xthen{e}{e'}$) which denotes that the value of stream $e$ is used for the very first step, followed by the latest values from stream $e'$ for subsequent steps.

Recursive streams, which can refer to previous values of the stream itself, are defined using the fixpoint operator ($\xrec{x}{e[x]}$); the syntax $e[x]$ means that the variable $x$ can occur in $e$.
To ensure that streams are productive, recursive equations can only refer to their previous values and must be \emph{guarded} by a delay; this restriction is formalised by the causality check in \REF{}.
This form of recursion differs somewhat from standard Lustre, which uses a set of mutually recursive bindings.
In \autoref{ss:operational-semantics} we will see that this form of recursion allows a syntax-directed semantics, but at the cost of potentially duplicating work.

Let-expressions ($\xlet{x}{e}{e'}$) are standard.
Finally, check-expressions ($\xcheck{e}{e'}$) are used to describe properties that the program should satisfy.
This operation corresponds roughly to the @assert@ primitive in \fstar{}; however we avoid this name, as @assert@ is historically treated as an unchecked assumption in many Lustre languages.

The grammar for values $v$ includes natural numbers, integers and functions embedded from the \fstar{} meta-language.
We denote functions in the meta-language by the explicit meta-lambda notation ($\mlamX{}$) to avoid any potential ambiguity between Pipit expressions ($e$) and meta-expressions ($\metafy{e}$).

\subsection{Typing rules}
\label{ss:typing-rules}

The typing rules of Pipit are defined in \autoref{f:core-typing}, with the judgment form $\typing{\Gamma}{e}{\tau}$ that checks expression $e$ under streaming context $\Gamma$.
% The grammar of types (\autoref{f:core-grammar}) distinguishes between bounded-size primitive types ($\primty$) and potentially higher-order types ($\tau$), which allows us to restrict streaming operations to only require bounded buffers.
% \TODO{Not sure if this restriction is useful, as arbitrary functions can still use however much memory and time as they want.}

For values (rule TValue), we reuse the \fstar{} meta-language's typing judgment ($\mtyping{}{v}{\tau}$) for typing closed values $v$.
Otherwise, most of the rules are standard.

\subsection{Operational semantics}
\label{ss:operational-semantics}

The operational semantics, expressed as a bigstep relation, are defined in \autoref{f:core-bigstep}.
The judgment form $\bigstep{\Sigma}{e}{v}$ takes a \emph{stream history} ($\Sigma$), which is a non-empty sequence of stores, as well as an expression to evaluate ($e$) and the final value ($v$).

Rule Value denotes that a value evaluates to itself under any streaming history.
Rule Var denotes that evaluating a variable requires looking it up in the right-most (most recent) store; the syntax $\Sigma_\bot; \sigma$ means that this rule applies to any streaming history with one or more steps.
Rule App-Meta allows applying functions on the meta-level; the syntax $(\mlamX{}) v'$ refers to meta-level application of some meta-term.

The rules $\mbox{Fby}_1$ and $\mbox{Fby}_S$ describe the semantics of delayed streams.
Rule $\mbox{Fby}_1$ denotes that when a delay $\xfby{v}{e}$ is evaluated in a context with exactly one step --- that is, at the very start of program execution --- it simply returns the initial value $v$.
Rule $\mbox{Fby}_S$ applies when the same delay is evaluated in a context with strictly more than one step ($\Sigma; \sigma$), in which case, the most recent step is discarded, and the original expression $e$ is evaluated under the previous history.

Next, rules ($\xthenarrow_1$) and ($\xthenarrow_S$) describe the semantics of streams composed by \emph{then}-expressions; as with the rules for delayed streams, the first rule applies when the streaming history contains exactly one step, while the second applies for histories of strictly more than one step.

Rule ($\mu{}$) describes the semantics of recursive streams.
This rule performs a single unfolding of a recursive expression $\xrec{x}{e[x]}$ so that all occurrences of $x$ inside $e$ are replaced with the recursive expression itself.
This rule is not trivially terminating, but so long as any occurrences of the recursive binder are guarded by a delay, then all occurrences of the recursive binder will have a shorter stream history.
This intuition is formalised in \REF{}.

Rule Let uses a standard substitution-based semantics for let-expressions.
Finally, rule Check evaluates a property and requires it to be true ($\top$).

The semantics here, particularly the recursive rule, differ from previous semantics of Lustre.
In the reactive semantics of \cite{caspi1995functional}, as well as the coinductive semantics of Vélus \CITE{bourke2017formally find best paper}, the semantics for mutually recursive definitions is locally non-deterministic, in that the semantics does not define which particular order mutual definitions are evaluated in.
This local non-determinism complicates certain proofs, even though the overall evaluation \emph{is} deterministic \TODO{vague}.

In contrast, the semantics presented here is syntax-directed and completely deterministic.
We have a mechanised proof of variant of progress theorem for well-formed (\emph{causal}) programs as well as closure under substitution and determinism, which is described in \autoref{ss:meta-theory}.
However, the substitution-based semantics here can duplicate expressions, and encoding mutually recursive definitions requires multiple substitutions.
For this reason, the semantics here is not suitable for actual execution.

\subsection{Causality}
\label{ss:causality}

Talk about the causality restriction.
Does expression $e$ have a dependency on the most-recent value of expression $e'$?

\begin{code}
let rec direct_dependency (e e': exp) : bool =
  if e = e' then true
  else
  match e with
  | XVal _ -> false
  | XVar x' -> false
  | XPrim2 _ e1 e2 -> direct_dependency e1 e' || direct_dependency e2 e'
  | XIte ep et ef -> direct_dependency ep e' || direct_dependency et e' || direct_dependency ef e'
  | XThen e1 e2 -> direct_dependency e1 e' || direct_dependency e2 e'
  | XPre _ -> false
  | XMu e1 -> direct_dependency e1 (lift e' 0)
  | XLet e1 e2 -> direct_dependency e1 e' || direct_dependency e2 (lift e' 0)

let rec causal (e: exp): bool =
  match e with
  | XVal _ -> true
  | XVar x' -> true
  | XPrim2 _ e1 e2 -> causal e1 && causal e2
  | XIte ep e1 e2 -> causal ep && causal e1 && causal e2
  | XThen e1 e2 -> causal e1 && causal e2
  | XPre e1 -> causal e1
  | XMu e1 -> causal e1 && not (direct_dependency e1 (XVar 0))
  | XLet e1 e2 -> causal e1 && causal e2
\end{code}


\begin{lemma}[no dependency, no difference]
If $e$ does not have a direct depend on $x$, then any evaluation of $e$ cannot depend on the current value of $x$.
  
For all expressions $e$ and well-scoped variables $x$,
if $\neg \mbox{directly} ~e~ x$ and
$\bigstep{\Sigma; (\sigma, x \mapsto v_x)}{e}{v}$
then for any $v_x'$, evaluation is unchanged
$\bigstep{\Sigma; (\sigma, x \mapsto v_x')}{e}{v}$
\end{lemma}

We also need:
\begin{lemma}[Bigstep recursive XMu]
  If a recursive expression $\xrec{x}{e}$ evaluates to some sequence of values $v$, then evaluating the recursive expression doesn't depend on the last value in the sequence:

  if $\bigsteps{\Sigma}{\xrec{x}{e}}{v_0 v_1 \cdots v_{n-1} v_n }$
  then for any $v'$,
  $\bigsteps{\Sigma \triangleright^{\uparrow} (v_0 v_1 \cdots v_{n-1} v')}{e}{v_0 v_1 \cdots v_{n-1} v_n}$
\end{lemma}

% let bigstep_recursive_XMu (#outer #inner: nat) (e: exp)
%   (streams: C.table (outer + 1) inner)
%   (vs: C.vector value outer) (v v': value)
%   (hBSmu: bigstep streams (XMu e) (v :: vs)):
%     bigstep (C.table_map_append (C.table_of_values (v' :: vs)) streams) e (v :: vs) =

\begin{lemma}[progress]
  if expression is causal, then for any valid stream history it should evaluate to a value:

  if $\typing{\Gamma}{e}{\tau}$ and $e \mbox{causal}$ and $\Gamma \vdash* \Sigma$, then exists $v$ such that
  $\bigstep{\Sigma}{e}{v}$ and $\mtyping{}{v}{\tau}$
\end{lemma}

\begin{lemma}[monotonic progress]
  if an expression $e$ evaluates to a sequence $vs$ under a stream history $\Sigma$ and a new stream store $\sigma$ is valid, then
  there exists some $v'$ such that
  $\bigsteps{\Sigma; \sigma}{e}{vs; v}$
\end{lemma}

\subsection{Meta-theory}
\label{ss:meta-theory}

We use a typed representation, which ensures an intrinsic variant of preservation.
For programs that satisfy the causality restriction, we have proved a variant of the progress theorem.

\begin{code}
let bigstep_deterministic
  (#streams: list (C.row 'c))
  (#e: exp 'c 'a)
  (#v1 #v2: 'a)
  (hBS1: bigstep streams e v1) (hBS2: bigstep streams e v2):
    Lemma (ensures (v1 == v2)) (decreases hBS1) =
  bigstep_proof_equivalence hBS1 hBS2
\end{code}

Monotonicity

Substitution-closure
\begin{code}
let rec bigstep_substitute_as_var (e p: exp)
  (streams1: C.table outer inner1)
  (streams2: C.table outer inner2)
  (vsp vsep: C.vector value outer)
  (hBSp: bigstep (C.table_map_append streams1 streams2) p vsp)
  (hBSep: bigstep (C.table_map_append streams1 streams2) (subst e inner1 p) vsep):
    Tot (bigstep (C.table_map_append streams1 (C.table_map_append (C.table_of_values vsp) streams2)) e vsep) (decreases hBSep) =

\end{code}



\section{Proving it with transition systems}

Describe the translation from Pipit expressions to labelled transition systems.

K-induction

Statement of LTS soundness:
\begin{code}
let system_eval_complete'
    (#outer: nat) (#vars: nat)
    (e: exp { causal e /\ wf e vars })
    (streams: C.table outer vars)
    (vs: C.vector value outer)
    (hBS: bigstep streams e vs):
      Lemma (exists (s': option (state_of_exp e)).
        system_stepn'
          (system_of_exp e vars)
          (C.Table?._0 streams) vs s') =
    match outer with
    | 0 -> assert
      (system_stepn'
        (system_of_exp e vars)
        (C.Table?._0 streams) vs None)
    | _ -> system_eval_complete e streams vs hBS
\end{code}

Tactics: \cite{martinez2019meta}.

Invariant generation: ICE\cite{garg2014ice}; template-based\cite{kahsai2011instantiation}; PDR explanation\cite{een2011efficient}; IC3 first introduced\cite{bradley2011sat}

\section{Execution}

We have implemented an unverified imperative code generation transform, by making use of \fstar{}'s existing C code extraction support\cite{protzenko2017verified}.
% This transform generates \fstar{} functions in the 

This allows us to generate C code which executes in bounded space on embedded devices.

Other compilers for Lustre-style languages, such as Vélus\cite{bourke2017formally} and Heptagon \cite{gerard2012modular} ensure that the generated code can be executed in bounded memory and that each step takes a bounded time.
With a carefully chosen set of primitives, the core streaming operations shown here would ensure bounded memory and time.
For practicality, however, we currently allow embedding arbitrary total functions from the \fstar{} meta-language, which are not necessarily bounded in time.
(Is this the same as Lucid Synchrone and Zélus? \CITE)

\section{Related work}

hardware language in Agda \cite{harrison2021mechanized}

Refinement types for Zélus \cite{chen2022synchronous}

\section{Conclusion and future work}

Future work: verify imperative code generation; verify CSE; case studies: antilock braking; clocks \cite{caspi1995functional}; contracts \cite{champion2016kind2}.

\pagebreak
% \begin{acks}
%   acknowledgement
% \end{acks}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{Main}


% \appendix

\end{document}
\endinput
%%
%% End of file `sample-sigplan.tex'.

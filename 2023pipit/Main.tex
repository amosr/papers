%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%% For submission and review of your manuscript please change the
%% command to \documentclass[manuscript, screen, review]{acmart}.
%%
%% When submitting camera ready or to TAPS, please change the command
%% to \documentclass[sigconf]{acmart} or whichever template is required
%% for your publication.
\documentclass[sigplan,screen]{acmart}

% any of these necessary?
% \usepackage{amssymb}
\usepackage{amsthm}
% \usepackage{graphicx}
\usepackage{amsmath}
% \usepackage{mathptmx}
\usepackage{mathtools}
% \usepackage{stmaryrd}
% \usepackage{adjustbox}
% \usepackage{hyperref}
% \usepackage{alltt}
% \usepackage{url}
% \usepackage{float}
% \usepackage{minipage-marginpar}

% \usepackage{cite}

\usepackage{style/utils}
\usepackage{style/code}
\usepackage{style/proof}
\usepackage{style/keywords}
\usepackage{style/judgements}

\setcopyright{acmcopyright}
\copyrightyear{2023}
\acmYear{2023}
\acmDOI{XXXXXXX.XXXXXXX}

\acmConference[TyDe '23]{In submission}{2023}{In submission}
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
% \acmPrice{15.00}
% \acmISBN{978-1-4503-XXXX-X/18/06}
%%\acmSubmissionID{123-A56-BU3}

\begin{document}

\title{Pipit: Reactive Systems in \fstar ~(Extended Abstract)}

\newcommand{\affiliationANU}{
  \affiliation{%
  \institution{Australian National University}
  \city{Canberra}
  \country{Australia}
}
}

\author{Amos Robinson}
% \authornote{}
\email{amos.robinson@anu.edu.au}
\orcid{0009-0004-4837-4981}
\affiliationANU{}
\author{Alex Potanin}
% \authornotemark[1]
\email{alex.potanin@anu.edu.au}
\orcid{0000-0002-4242-2725}
\affiliationANU{}

% \renewcommand{\shortauthors}{Robinson et al.}

\begin{abstract}
  Reactive languages such as Lustre and Scade are used to implement safety-critical control systems; proving such programs correct and having the proved properties apply to the compiled code is therefore equally critical.
  We introduce Pipit, a simple reactive language embedded in \fstar{}, designed for verifying control systems and executing them in real-time.
  Pipit includes a verified translation to transition systems; by reusing \fstar{}'s existing proof automation, certain safety properties can be automatically proved using k-induction on the transition system.
  Pipit can also generate imperative code in \lowstar{}, a subset of \fstar{} which is suitable for compilation and real-time execution on embedded devices.
  This translation to imperative code has been proved to preserve types; the proof that the generated imperative code preserves semantics is future work.
\end{abstract}

%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
\begin{CCSXML}
<ccs2012>
    <concept>
        <concept_id>10010520.10010553.10010562.10010564</concept_id>
        <concept_desc>Computer systems organization~Embedded software</concept_desc>
        <concept_significance>300</concept_significance>
        </concept>
    <concept>
        <concept_id>10010520.10010570.10010572</concept_id>
        <concept_desc>Computer systems organization~Real-time languages</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
    <concept>
        <concept_id>10003752.10010124.10010138.10010142</concept_id>
        <concept_desc>Theory of computation~Program verification</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
    <concept>
        <concept_id>10003752.10003790.10003793</concept_id>
        <concept_desc>Theory of computation~Modal and temporal logics</concept_desc>
        <concept_significance>100</concept_significance>
        </concept>
    <concept>
        <concept_id>10011007.10011006.10011050.10011023</concept_id>
        <concept_desc>Software and its engineering~Specialized application languages</concept_desc>
        <concept_significance>500</concept_significance>
        </concept>
  </ccs2012>
\end{CCSXML}

\ccsdesc[300]{Computer systems organization~Embedded software}
\ccsdesc[500]{Computer systems organization~Real-time languages}
\ccsdesc[500]{Theory of computation~Program verification}
\ccsdesc[100]{Theory of computation~Modal and temporal logics}
\ccsdesc[500]{Software and its engineering~Specialized application languages}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Lustre, streaming, reactive, control}

\received{1 June 2023}
% \received[revised]{12 March 2009}
% \received[accepted]{5 June 2009}

\maketitle

% enable @verbatim@ syntax
\makeatactive

\section{Introduction}

Safety-critical control systems, such as the anti-lock braking systems that occur in most cars today, need to be correct and execute in real-time.
One approach, favoured by parts of the aerospace industry, is to implement the controllers in a high-level language such as Lustre~\cite{caspi1995functional} or Scade, and verify that the implementations satisfy the high-level specification using a model-checker, such as Kind2~\cite{champion2016kind2}.
These model-checkers can prove many interesting properties automatically, but do not provide many options for manual proofs when the automated proof techniques fail.
Additionally, the semantics used by the model-checker may not match the semantics of the compiled code, in which case properties proved do not necessarily hold on the real system.
This mismatch may occur even when the compiler has been verified correct, as in the case of Vélus~\cite{bourke2017formally}.
For example, in the Vélus compiler, integer division rounds towards zero, matching the semantics of C; however, integer division in Kind2 rounds to negative infinity, matching SMT-lib~\cite{BarFT2016SMTLIB}.

To be confident that our proofs hold on the real system, we need a single semantics that is shared between the compiler and the model-checker or prover.
In the following, we introduce Pipit, an embedded domain-specific language for implementing and verifying controllers in \fstar{}.
Pipit aims to provide a high-level language based on a clock-free subset of Lustre, while reusing \fstar{}'s proof automation and manual proofs for verifying controllers, and using \lowstar{}'s C-code generation for real-time execution.
% By designing Pipit as an embedded language, we can reuse many of the \fstar{} meta-language's features while retaining a small core language.
Pipit translates its expression language to a transition system for k-inductive proofs, which is verified\footnote{The translation is verified for a previous untyped expression representation; we are still finishing porting the proofs to the new typed representation.}; verifying the translation to imperative code is future work.

In this extended abstract, we will briefly describe the following preliminary results, which we intend to publish pending further evaluation:
\begin{itemize}
  \item We identify the invariants and lemmas required to prove correctness of the translation from a clock-free Lustre-style language to a transition system (\autoref{ss:meta-theory}).
  \item We present a syntax-directed operational semantics for a clock-free Lustre-style language (\autoref{ss:operational-semantics}).
    % TODO: CUT WAFFLE
    This syntax-directed semantics is in contrast to previous \emph{relational} operational semantics of Lustre, which are not syntax-directed and require detailed proofs of determinism.
    Proving determinism on our semantics requires only straightforward induction; we believe that this semantics may be better for proving other properties too.
  \item We show preliminary results that demonstrate the effectiveness of Pipit by implementing a verified controller for a simple embedded system (\autoref{s:coffee-machine}).
\end{itemize}


% \begin{itemize}
%   \item an embedded language makes it easier to express interesting programs with a small real-time synchronous core language;
%   \item by embedding in a language with good proof automation support, we can reason about embedded programs without much manual proof effort;
%   \item by embedding in a language with manual proof support, we can prove harder problems than existing model checkers; and
%   \item by embedding in a language with a well-defined extraction to (heap) allocation-free C code, we can get a partially verified compiler; so far we have only proved type preservation
% \end{itemize}

\section{Pipit in flight}

A common requirement in controllers is to filter an input signal, perhaps using a \emph{finite impulse response} (FIR) filter, which is equivalent to a weighted moving average.
An FIR filter takes an input signal and a vector of coefficients, and computes the dot product of the coefficients and the most recent values of the signal.
We can implement an FIR filter in Pipit as follows:

\begin{tabbing}
  @MM@\= @MMMMMM@ \= \kill
  @let@ fir ($\textit{coefficients}$: list $\RR$) ($s$: stream $\RR$): stream $\RR$ = \\
    \> @match@ $\textit{coefficients}$ @with@ \\
    \> @|@ $[]$ \> $\to 0$ \\
    \> @|@ $c :: \cs $ \> $\to (s \cdot c) + (\xfby{0}{(\mbox{fir~} \cs~s)})$
\end{tabbing}

Our FIR filter takes two arguments, one describing the coefficients and one describing the signal to filter.
The coefficient vector is represented by a list of reals here, while the signal $s$ is a \emph{stream} of reals, and the result is the filtered stream\footnote{The actual implementation uses integers with fixed-point arithmetic, but we use reals here to reduce clutter.}.
The implementation starts by looking at the list of coefficients, and returns zero if the list is empty.
If the list is not empty, then we multiply the most recent value of the stream by the coefficient ($s \cdot c$) and delay the result ($\xfby{0}{\ldots}$) of applying the remaining coefficients to the signal stream ($\mbox{fir~} \cs ~ s$), summing the two parts.
When there is no previous value, as is the case at the start of execution, the delay is given the initial value of zero.

Although this definition is simple, verifying it \emph{and} executing it in Lustre is somewhat impractical, as tool support varies widely.
To write this program in Lustre, we would likely need to reformulate the program to use arrays.
Vélus does not support arrays; Kind2 uses a custom syntax for arrays that no compiler supports; and Lustre v6 does support compiling arrays and recursive nodes, but its model-checker, Lesar~\cite{raymond2008synchronous} does not.

Instead, we take the embedded language approach of defining a simple core language inside a theorem prover (\fstar{}).
By implementing Pipit as an embedded language, we can express the above FIR filter, but the lists are evaluated away by the meta-language to a simple core program which can be easily executed in statically-bounded runtime and space.
For example, we can compute the weighted moving average with two coefficients:

\newcommand\bibo{\mbox{bibo}}
\newcommand\fir{\mbox{fir}}
\newcommand\ii{\textit{input}}
\newcommand\oo{\textit{output}}
\newcommand\ok{\textit{ok}}
\begin{tabbing}
  @MM@\= @MMMMMM@ \= \kill
  @let@ $\mbox{fir}_2$ ($\ii$: stream $\RR$): stream $\RR$ = \\
    \> $\mbox{fir}~[0.7; 0.3] \ii$
\end{tabbing}

Which then normalises to the following simple definition:

\begin{tabbing}
    @MM@\= @MMMMMM@ \= \kill
      @let@ $\mbox{fir}_2$ ($\ii$: stream $\RR$): stream $\RR$ = \\
    \> $(0.7 \cdot \ii) + (\xfby{0}{((0.3 \cdot \ii) + (\xfby{0}{0}))})$
\end{tabbing}

To state properties about our filter, it is useful to be able to state temporal properties.
We do not need a separate specification language; instead, we can implement computable variants of temporal operators from \emph{past-time} linear temporal logic \cite{halbwachs1993executable,lichtenstein1985glory}.
We name the past-globally operator \emph{sofar}, as in \emph{the property has been true so far}:

\begin{tabbing}
  @MM@\= @MMMMMM@ \= \kill
  @let@ sofar ($p$: stream $\BB$): stream $\BB$ = \\
    \> $\xrec{p'}{p \wedge (\xfby{\top}{p'})}$
\end{tabbing}

This definition takes a stream of predicates $p$ and introduces a recursive stream $p'$.
At each step, the recursive stream $p'$ checks that the current predicate is true ($p$), and also checks that \emph{sofar} was previously true ($\xfby{\top}{p'}$).
If there is no previous value, it defaults to true.

We can now state a \emph{bounded-input-bounded-output} (BIBO) property, which says that if the inputs have always been within some particular range, then the outputs are also within the range.
Such properties can occur as an internal invariant in a larger proof.

\begin{tabbing}
  @MM@\= @LET OUTPUT@\= @EXAMPLE1 INPUT@ \= \kill
  @let@ $\mbox{bibo}_2$ (n: $\RRgez$) ($\ii$: stream $\RR$): stream $\RR$ = \\
  \> @check@ $(\mbox{sofar}(|\ii| \le n)) \implies |\mbox{fir}_2~\ii| \le n)$
\end{tabbing}

This property states that, for this particular set of coefficients, if the input has always been in the range $[-n, n]$, then the output is also within the range $[-n, n]$.
Note that the upper bound $n$ is a nonnegative real rather than a stream of reals, which means that $n$ stays constant across the whole stream.
To prove that this property holds, we translate to a transition system.
In this case, simple induction over the transition relation is sufficient to prove the property.
There is some boilerplate required to perform the induction, but the step case and base case are automatically proved by \fstar{}:

\begin{tabbing}
  @MM@\= @MMMMMMMMMMMMMMMMMMMMMMM@ \= \kill
  @let@ $\mbox{proof}_2$ (n: $\RRgez$): Lemma (induct ($\bibo_2$ n)) = \\
  \> @assert@ (base\_case ($\bibo_2 ~n$)) \> @by@ (pipit\_simplify ()); \\
  \> @assert@ (step\_case ($\bibo_2 ~n$)) \> @by@ (pipit\_simplify ())
\end{tabbing}

This definition uses \fstar{}'s \emph{lemma} syntax to state that the BIBO property holds inductively for any $n$.
The two assertions prove the inductive cases separately, using our \emph{simplify} tactic to ensure that the translation to transition system is normalised away, and any translation artefacts are removed.

If we wish to prove a similar BIBO property for three or more coefficients, this standard induction over the transition system is no longer sufficient, and we need a stronger invariant.
One simple automated way to strengthen the invariants is via \emph{k-induction}~\cite{hagen2008scaling}, which looks at multiple steps of the transition relation at a time.
For example, we can define analogous functions $\fir_3$ and $\bibo_3$ which operate on the coefficients $[0.7; 0.2; 0.1]$, and use k-induction for $k = 2$:

\begin{tabbing}
  @MM@\= @MMMMMMMMMMMMMMMMMMMMMMMMMMM@ \= \kill
  @let@ $\mbox{proof}_3$ (n: $\RRgez$): Lemma (induct\_k 2 ($\bibo_3$ n)) = \\
  \> @assert@ (base\_case\_k 2 ($\bibo_3 ~n$)) \> @by@ (pipit\_simplify ()); \\
  \> @assert@ (step\_case\_k 2 ($\bibo_3 ~n$)) \> @by@ (pipit\_simplify ())
\end{tabbing}

% The issue is that each delayed values inside the FIR filter becomes a separate state variable in the transition system.
% When looking at the result of a single step of the transition relation in isolation, we can prove that $(\xfby{0}{\ii}) \le n$ is equivalent to $\xfby{\top}{(\ii \le n)}$.
% When nesting delays, however, the same sort of distributive property is not clear from just a single step of the transition relation; each delay gets its own state variable, and the relationship between the different state variables is lost.
% We really need a stronger invariant to do this.


% \TODO{Required for submission: writing}
% \begin{itemize}
%   \item introduction
%   \item running example: FIR?
%   \item describe translation to transition system? detail probably won't fit, translation invariant is the most interesting part.
% \end{itemize}
% \TODO{Required for submission: implementation}
% \begin{itemize}
%   \item finish proof of system correctness
%   \item state end-to-end / capstone theorem that k-inductively verified systems apply to original semantics
%   \item implement unverified CSE pass
%   \item verify running example, with CSE and k-induction
% \end{itemize}

% Cite: Kind2 \cite{champion2016kind2}, Lustre \cite{caspi1995functional}, Vélus \cite{bourke2017formally}.
% Cite: the original Kind \cite{hagen2008scaling}.
% \CITEME{2022 thesis on Agda semantics of Lustre?}
% Past-time modal temporal logic \cite{lichtenstein1985glory}
% Lustre support for temporal logic \cite{halbwachs1993executable}

\section{Core language}
\label{s:core}

\input{figures/core-grammar.tex}
\input{figures/core-typing.tex}
\input{figures/core-bigstep.tex}

The grammar of Pipit is defined in \autoref{f:core-grammar}.
The expression form $e$ includes standard syntax for values ($v$), variables ($x$) and applications ($e~e'$); however, it does not include any form for defining functions other than reusing closed functions from the \fstar{} meta-language.
Most of the expression forms are equivalent to a simplified, clock-free primitives from standard Lustre-style languages \cite{caspi1995functional}.
The expression syntax for delayed streams ($\xfby{v}{e}$) denotes the previous value of the stream $e$, with an initial value of $v$ when there is no previous value.
Streams can be composed together using the \emph{then} notation ($\xthen{e}{e'}$) which denotes that the value of stream $e$ is used for the very first step, followed by the latest values from stream $e'$ for subsequent steps.

Recursive streams, which can refer to previous values of the stream itself, are defined using the fixpoint operator ($\xrec{x}{e[x]}$); the syntax $e[x]$ means that the variable $x$ can occur in $e$.
To ensure that streams are productive, recursive equations can only refer to their previous values and must be \emph{guarded} by a delay; this restriction is formalised by the causality check in \REF{}.
This form of recursion differs somewhat from standard Lustre, which uses a set of mutually recursive bindings.
In \autoref{ss:operational-semantics} we will see that this form of recursion allows a syntax-directed semantics, but at the cost of potentially duplicating work.

Let-expressions ($\xlet{x}{e}{e'}$) are standard.
Finally, check-expressions ($\xcheck{e}{e'}$) are used to describe properties that the program should satisfy.
This operation corresponds roughly to the @assert@ primitive in \fstar{}; however we avoid this name, as @assert@ is historically treated as an unchecked assumption in many Lustre languages.

The grammar for values $v$ includes natural numbers, integers and functions embedded from the \fstar{} meta-language.
We denote functions in the meta-language by the explicit meta-lambda notation ($\mlamX{}$) to avoid any potential ambiguity between Pipit expressions ($e$) and meta-expressions ($\metafy{e}$).

\subsection{Typing rules}
\label{ss:typing-rules}

The typing rules of Pipit are defined in \autoref{f:core-typing}, with the judgment form $\typing{\Gamma}{e}{\tau}$ that checks expression $e$ under streaming context $\Gamma$.
% The grammar of types (\autoref{f:core-grammar}) distinguishes between bounded-size primitive types ($\primty$) and potentially higher-order types ($\tau$), which allows us to restrict streaming operations to only require bounded buffers.
% \TODO{Not sure if this restriction is useful, as arbitrary functions can still use however much memory and time as they want.}

For values (rule TValue), we reuse the \fstar{} meta-language's typing judgment ($\mtyping{}{v}{\tau}$) for typing closed values $v$.
Otherwise, most of the rules are standard.

\subsection{Operational semantics}
\label{ss:operational-semantics}

The operational semantics, expressed as a bigstep relation, are defined in \autoref{f:core-bigstep}.
The judgment form $\bigstep{\Sigma}{e}{v}$ takes a \emph{stream history} ($\Sigma$), which is a non-empty sequence of stores, as well as an expression to evaluate ($e$) and the final value ($v$).

Rule Value denotes that a value evaluates to itself under any streaming history.
Rule Var denotes that evaluating a variable requires looking it up in the right-most (most recent) store; the syntax $\Sigma_\bot; \sigma$ means that this rule applies to any streaming history with one or more steps.
Rule App-Meta allows applying functions on the meta-level; the syntax $(\mlamX{}) v'$ refers to meta-level application of some meta-term.

The rules $\mbox{Fby}_1$ and $\mbox{Fby}_S$ describe the semantics of delayed streams.
Rule $\mbox{Fby}_1$ denotes that when a delay $\xfby{v}{e}$ is evaluated in a context with exactly one step --- that is, at the very start of program execution --- it simply returns the initial value $v$.
Rule $\mbox{Fby}_S$ applies when the same delay is evaluated in a context with strictly more than one step ($\Sigma; \sigma$), in which case, the most recent step is discarded, and the original expression $e$ is evaluated under the previous history.

Next, rules ($\xthenarrow_1$) and ($\xthenarrow_S$) describe the semantics of streams composed by \emph{then}-expressions; as with the rules for delayed streams, the first rule applies when the streaming history contains exactly one step, while the second applies for histories of strictly more than one step.

Rule ($\mu{}$) describes the semantics of recursive streams.
This rule performs a single unfolding of a recursive expression $\xrec{x}{e[x]}$ so that all occurrences of $x$ inside $e$ are replaced with the recursive expression itself.
This rule is not trivially terminating, but so long as any occurrences of the recursive binder are guarded by a delay, then all occurrences of the recursive binder will have a shorter stream history.
This intuition is formalised in \REF{}.

Rule Let uses a standard substitution-based semantics for let-expressions.
Finally, rule Check evaluates a property and requires it to be true ($\top$).

The semantics here, particularly the recursive rule, differ from previous semantics of Lustre.
In the reactive semantics of \citet{caspi1995functional}, as well as the coinductive semantics of Vélus \cite{bourke2017formally} (\CITEME{find best paper}), the semantics for mutually recursive definitions is locally non-deterministic, in that the semantics does not define which particular order mutual definitions are evaluated in.
This local non-determinism complicates certain proofs, even though the overall evaluation \emph{is} deterministic \TODO{vague}.

In contrast, the semantics presented here is syntax-directed and completely deterministic.
We have a mechanised proof of variant of progress theorem for well-formed (\emph{causal}) programs as well as closure under substitution and determinism, which is described in \autoref{ss:meta-theory}.
However, the substitution-based semantics here can duplicate expressions, and encoding mutually recursive definitions requires multiple substitutions.
For this reason, the semantics here is not suitable for actual execution.

\subsection{Causality}
\label{ss:causality}

Talk about the causality restriction.
Does expression $e$ have a dependency on the most-recent value of expression $e'$?

\begin{code}
let rec direct_dependency (e e': exp) : bool =
  if e = e' then true
  else
  match e with
  | XVal _ -> false
  | XVar x' -> false
  | XPrim2 _ e1 e2 -> direct_dependency e1 e' || direct_dependency e2 e'
  | XIte ep et ef -> direct_dependency ep e' || direct_dependency et e' || direct_dependency ef e'
  | XThen e1 e2 -> direct_dependency e1 e' || direct_dependency e2 e'
  | XPre _ -> false
  | XMu e1 -> direct_dependency e1 (lift e' 0)
  | XLet e1 e2 -> direct_dependency e1 e' || direct_dependency e2 (lift e' 0)

let rec causal (e: exp): bool =
  match e with
  | XVal _ -> true
  | XVar x' -> true
  | XPrim2 _ e1 e2 -> causal e1 && causal e2
  | XIte ep e1 e2 -> causal ep && causal e1 && causal e2
  | XThen e1 e2 -> causal e1 && causal e2
  | XPre e1 -> causal e1
  | XMu e1 -> causal e1 && not (direct_dependency e1 (XVar 0))
  | XLet e1 e2 -> causal e1 && causal e2
\end{code}


\begin{lemma}[no dependency, no difference]
If $e$ does not have a direct depend on $x$, then any evaluation of $e$ cannot depend on the current value of $x$.
  
For all expressions $e$ and well-scoped variables $x$,
if $\neg \mbox{directly} ~e~ x$ and
$\bigstep{\Sigma; (\sigma, x \mapsto v_x)}{e}{v}$
then for any $v_x'$, evaluation is unchanged
$\bigstep{\Sigma; (\sigma, x \mapsto v_x')}{e}{v}$
\end{lemma}

We also need:
\begin{lemma}[Bigstep recursive XMu]
  If a recursive expression $\xrec{x}{e}$ evaluates to some sequence of values $v$, then evaluating the recursive expression doesn't depend on the last value in the sequence:

  if $\bigsteps{\Sigma}{\xrec{x}{e}}{v_0 v_1 \cdots v_{n-1} v_n }$
  then for any $v'$,
  $\bigsteps{\Sigma \triangleright^{\uparrow} (v_0 v_1 \cdots v_{n-1} v')}{e}{v_0 v_1 \cdots v_{n-1} v_n}$
\end{lemma}

% let bigstep_recursive_XMu (#outer #inner: nat) (e: exp)
%   (streams: C.table (outer + 1) inner)
%   (vs: C.vector value outer) (v v': value)
%   (hBSmu: bigstep streams (XMu e) (v :: vs)):
%     bigstep (C.table_map_append (C.table_of_values (v' :: vs)) streams) e (v :: vs) =

\begin{lemma}[progress]
  if expression is causal, then for any valid stream history it should evaluate to a value:

  if $\typing{\Gamma}{e}{\tau}$ and $e \mbox{causal}$ and $\Gamma \vdash* \Sigma$, then exists $v$ such that
  $\bigstep{\Sigma}{e}{v}$ and $\mtyping{}{v}{\tau}$
\end{lemma}

\begin{lemma}[monotonic progress]
  if an expression $e$ evaluates to a sequence $vs$ under a stream history $\Sigma$ and a new stream store $\sigma$ is valid, then
  there exists some $v'$ such that
  $\bigsteps{\Sigma; \sigma}{e}{vs; v}$
\end{lemma}

\subsection{Meta-theory}
\label{ss:meta-theory}

We use a typed representation, which ensures an intrinsic variant of preservation.
For programs that satisfy the causality restriction, we have proved a variant of the progress theorem.

\begin{code}
let bigstep_deterministic
  (#streams: list (C.row 'c))
  (#e: exp 'c 'a)
  (#v1 #v2: 'a)
  (hBS1: bigstep streams e v1) (hBS2: bigstep streams e v2):
    Lemma (ensures (v1 == v2)) (decreases hBS1) =
  bigstep_proof_equivalence hBS1 hBS2
\end{code}

Monotonicity

Substitution-closure
\begin{code}
let rec bigstep_substitute_as_var (e p: exp)
  (streams1: C.table outer inner1)
  (streams2: C.table outer inner2)
  (vsp vsep: C.vector value outer)
  (hBSp: bigstep (C.table_map_append streams1 streams2) p vsp)
  (hBSep: bigstep (C.table_map_append streams1 streams2) (subst e inner1 p) vsep):
    Tot (bigstep (C.table_map_append streams1 (C.table_map_append (C.table_of_values vsp) streams2)) e vsep) (decreases hBSep) =

\end{code}



\section{Proving it with transition systems}

Describe the translation from Pipit expressions to labelled transition systems.

K-induction

Statement of LTS soundness:
\begin{code}
let system_eval_complete'
    (#outer: nat) (#vars: nat)
    (e: exp { causal e /\ wf e vars })
    (streams: C.table outer vars)
    (vs: C.vector value outer)
    (hBS: bigstep streams e vs):
      Lemma (exists (s': option (state_of_exp e)).
        system_stepn'
          (system_of_exp e vars)
          (C.Table?._0 streams) vs s') =
    match outer with
    | 0 -> assert
      (system_stepn'
        (system_of_exp e vars)
        (C.Table?._0 streams) vs None)
    | _ -> system_eval_complete e streams vs hBS
\end{code}

Tactics: \cite{martinez2019meta}.

Invariant generation: ICE \cite{garg2014ice}; template-based \cite{kahsai2011instantiation}; PDR explanation \cite{een2011efficient}; IC3 first introduced \cite{bradley2011sat}

\section{Execution}

We have implemented an unverified imperative code generation transform, by making use of \fstar{}'s existing C code extraction support \cite{protzenko2017verified}.
% This transform generates \fstar{} functions in the 

This allows us to generate C code which executes in bounded space on embedded devices.

Other compilers for Lustre-style languages, such as Vélus \cite{bourke2017formally} and Heptagon \cite{gerard2012modular} ensure that the generated code can be executed in bounded memory and that each step takes a bounded time.
With a carefully chosen set of primitives, the core streaming operations shown here would ensure bounded memory and time.
For practicality, however, we currently allow embedding arbitrary total functions from the \fstar{} meta-language, which are not necessarily bounded in time.
(Is this the same as Lucid Synchrone and Zélus? \CITE)

\section{Coffee machine}
\label{s:coffee-machine}

\section{Related work}

hardware language in Agda \cite{harrison2021mechanized}

Refinement types for Zélus \cite{chen2022synchronous}

\TODO{discuss TCB: big, much bigger than Vélus}


\section{Conclusion and future work}

Future work: verify imperative code generation; verify CSE; case studies: antilock braking; clocks \cite{caspi1995functional}; contracts \cite{champion2016kind2}.

% \pagebreak
% \begin{acks}
%   acknowledgement
% \end{acks}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{Main}


% \appendix

\end{document}
\endinput
%%
%% End of file `sample-sigplan.tex'.

%!TEX root = ../Main.tex
\section{Merging machines}
\label{s:Merging}

This section describes how machines can be merged together to form a single machine that computes both.

The idea is to create a new machine with the product of the two states; at each state, one or the other of the machines may be able to take a step.
If so, we update that machine's state and leave the other one as-is.
For shared inputs or outputs, both machines must take the steps at the same time: if they both pull from the same input, they must pull at the same time.
Similarly, if one machine produces an input and the other reads it, the first machine can only produce its output if the second is pulling on it.

If neither machine can make a move, the program is disallowed.
For example, if the first machine is trying to read from a shared input while the second tries to read from the first machine's input, executing it may require buffering the input until the second machine catches up.

However, the above explanation is too strict and outlaws programs such as @zip xs ys@ merged with @zip ys xs@, as neither machine can progress until the other does, leading to deadlock.
To resolve this, we add to the resulting machine's state a set of pending events for each machine.
The first machine may read from a shared input as long as there is not already a ``read'' event pending for the other machine to deal with.
Reading from a shared input adds a pending ``read'' event to the other machine, and the other machine may then skip past a @Pull@ for that source, as it is known that the other machine has already pulled on it.

\subsection{General merging}
Let us define the potential pending events on a machine.
One machine may have read from a shared input, but the other has not.
Similarly, if one machine has tried to read from a shared input but the input is empty, when the other machine attempts to read it can skip directly to the @None@ case.

The other cases are when one machine produces a value, and another consumes it.
Here, the producer may have produced a value, or may have finished producing on that channel.

\begin{tabbing}
MM \= MM \= MMMMMM \= M\kill
$\Psi$ \> $=$  \> @Value@     \> $n$         \\
       \> $~|$ \> @Finished@  \> $n$         \\
       \> $~|$ \> @Closed@    \> $n$         \\
\end{tabbing}

The @merge@ function takes two machines with states $l_1$ and $l_2$, and produces a new machine with state $l_1 \times \{\Psi\} \times l_2 \times \{\Psi\}$.
It starts by creating an empty machine, and inserting states one by one, starting from the initial state as the initial state of each machine, and empty pending sets.
Then, for each output transition of the input machines, states are recursively added.

\begin{tabbing}
MMMMMMM \= MM \= MMMMMM \= M\kill
@merge@ \> $:$ \> $@Machine @l_1 \times @Machine @l_2$ \\
        \> $\to$ \> $@Machine @(l_1 \times \{\Psi\} \times l_2 \times \{\Psi\})$ \\
\\
@merge @$m_1~m_2$ \> $=$ \> $@merge@'~(@init @m_1)~(@init @m_2)~\{\}~@empty@$ \\
\\
$@merge@'$ \> $:$ \> $l_1 \times \{\Psi\} \times l_2 \times \{\Psi\}$               \\
           \> $\times$ \> $@Machine @(l_1 \times \{\Psi\} \times l_2 \times \{\Psi\})$ \\
           \> $\to$ \> $@Machine @(l_1 \times \{\Psi\} \times l_2 \times \{\Psi\})$ \\
\\
MMM \= M \= MMMMMMMMMM \= M \=\kill
$@merge@'~s_1~\psi_1~s_2~\psi_2~m$ \\
 \> $~|$ \> $(s_1, \psi_1, s_2, \psi_2) \in m$  \\
 \> $=$  \> $m$ \\
 \> $~|$ \> $(\gamma,\delta) \in @move@~s_1~\psi_1~s_2~\psi_2$ \\
 \> $=$  \> $@fold@~@merge@'~(m \cup \gamma \cup \delta)~\delta$ \\
\end{tabbing}

The $@merge@'$ function adds the given state and recursively adds the successor states to the given machine.
If the given state has already been added --- for example the state is reachable by multiple states --- the state need not be added.

\begin{tabbing}
MMM \= M \= MMMMMMM\kill
$@move@$ \> $:$ \> $l_1 \times \{\Psi\} \times l_2 \times \{\Psi\}$ \\
           \> $\to$ \> $\Gamma \times \{\Sigma \times (l_1 \times \{\Psi\} \times l_2 \times \{\Psi\})\}$ \\
\end{tabbing}

The @move@ function computes the states and transitions of the merged machine.
These are added to the machine by $@merge@'$ above.

\input{figures/MergeGen.tex}

If either of the machines are attempting to update their local state, this can be done easily without interfering with the other machine.

Skips are dealt with in the same way, affecting only one machine.

Similarly, @If@s only affect one of the machines, leaving the other in its original state.
If we had an oracle for checking functional equivalence, we could check whether two @If@s had the same function and inputs and potentially allow more programs.
However, lacking an oracle, even if both machines have @If@s with the same predicate, we generate a machine for all possible result combinations (all four of them).

If both machines are @Done@, the resulting machine will also be @Done@.

The previous cases have been rather trivial as they require no synchronisation between the machines, but the remaining cases of @Pull@, @Release@, @Out@ and @OutDone@ are more complicated.

If the first machine is producing an output on channel $n$ and the second machine uses $n$, the first machine would usually have to wait until the second machine is ready to accept new data.
However, if the second machine has closed $n$, the will never pull on $n$ again, so the first machine may output to the channel as frequently as it likes.
Note that the output channels may have multiple consumers, so continuing to output after a consumer has finished is not as futile as it may seem at first.

Again, if the first machine is producing and the second is consuming, the first machine may only produce if there is no unhandled value on the channel.
This is what $\psi$ and $\phi$ are for.
If there is a value in the other machine's event set, $\phi$, a later case may allow the second machine to pull from it.

The final case for @Out@ is when the second machine does not use this output, allowing the first machine to output at any time.

The cases for @OutDone@ proceed similarly to @Out@.

Pulls now.

Releases.

If none of the above cases apply, it means the machines cannot be fused.
Either they require more than one element of buffering, or reasoning about function equality would be required to prove that they do not.
The only unhandled cases above are where the two machines share input or outputs, and there are existing values buffered in $\psi$.
In which case, we give a compile time error indicating that these two machines cannot be fused.




\subsection{Producer-consumer}
The general case above is sufficient, but in some cases can generate larger machines than necessary.
Talk about special case for producer-consumers.

\begin{code}
data Which = LeftExec | RightExec

mergeV :: Machine l1 -> Machine l2
       -> Machine (l1, l2, Which)
\end{code}


\subsection{Theorems we want to prove}

As we do not wish to handle recursive combinators, we also do not need to handle merging cyclic machines.
This is one case that regular dataflow handles but we do not.
The predicate below checks if either of the machines does not use the other's input; if both used the other's input, it would create a cycle.

\begin{tabbing}
MMMMMMM \= MM \= \kill
$@acyclic@~a~b$
\> $:=$
\> $\outputs{a}~\cap~\inputs{b}~=~\emptyset$
\\
\> $~\vee$ \> $\outputs{b}~\cap~\inputs{a}~=~\emptyset$
\end{tabbing}

Two machines cannot be merged if they both provide the same output, or write to the same output channel.

\begin{tabbing}
MMMMMMM \= MM \= \kill
$@distinct@~a~b$
\> $:=$
\> $\outputs{a}~\cap~\outputs{b}~=\emptyset$
\end{tabbing}

For the special case of vertical fusion, we require there be one output used as the other machine's sole input, and no other sharing.
Both machines may have multiple outputs, and the producer may have multiple inputs, but the consumer can only have one input.

\begin{tabbing}
MMMMMMM \= MM \= MM \= \kill
$@vertical@~a~b$
\> $:=$
\> $\exists n.$
\> $(n \in \outputs{a} \wedge \sgl{n} = \inputs{b})$
\\
\>
\> $~\vee$
\> $(n \in \outputs{b} \wedge \sgl{n} = \inputs{a})$
\end{tabbing}

\subsubsection{General preservation}
The result of merging two machines should maintain the pull invariants (\S~\ref{s:Machines:Invariants}), provided that the input machines also maintain their invariants.

\begin{tabbing}
MMMMMMM \= MM \= MM \= \kill
$\forall a~b.$
\>
\> $a~@ok@~\wedge~b~@ok@$
\\
\> $\wedge$
\> $@acyclic@~a~b$
\\
\> $\wedge$
\> $@distinct@~a~b$
\\
\> $\implies$
\> $\forall c \in (@merge@~a~b).\ c~@ok@$
\end{tabbing}

\paragraph{Lemma transitions:} for each state $u$ of $@merge@~a~b$ and corresponding states $s$ and $t$ of $a$ and $b$, any output transitions from $u$ either move along $s$'s output transitions or $t$'s output transitions, but not both.
Similarly, the state type of $u$ will either be the type of $s$, the type of $t$, or a @Skip@.

\paragraph{Lemma appears:} for all states $s$ in $a$, if there is a path from $@initial@~a$ to $s$, then:
\begin{itemize}
\item if $s$ is a @Close@, either $s$ or a @Finish@ or a @Close@ from the other machine $b$ will appear in the output ($@merge@~a~b$);
\item if $s$ is an @Out@, @Update@, @If@, $s$ will appear in the output;
\item otherwise, $s$ 
\end{itemize}
ACTUALLY, \textbf{appears} isn't true.


\paragraph{Proof sketch:} each state in $a$ and $b$ has an associated set of $\Psi$.
If we deconstruct each state of $c$, it has a state of $a$, a state of $b$, and a $\Psi$ set for each.

Show that in this $(\sptpC)$, the $\psi$ and $\phi$ is something similar to $s$ and $t$'s $\Psi$ set.

Total $\Psi$ is the union of $\psi$ and $\phi$, except if one set has @Closed@ but the other doesn't, that channel is still open.

Then, look at each rule in @move@, and the preconditions should translate to sufficient preconditions on $\Psi$:

@Skip@, @Update@ and @If@ are trivial.

If both machines are @Done@, since both machines are also @ok@, all their inputs and outputs must be closed..

\subsubsection{Vertical preservation}

\begin{tabbing}
MMMMMMM \= MM \= MM \= \kill
$\forall a~b.$
\>
\> $a~@ok@~\wedge~b~@ok@$
\\
\> $\wedge$
\> $@acyclic@~a~b$
\\
\> $\wedge$
\> $@vertical@~a~b$
\\
\> $\wedge$
\> $@distinct@~a~b$
\\
\> $\implies$
\> $\forall c \in (@mergeV@~a~b).\ c~@ok@$
\end{tabbing}


\subsubsection{Vertical progress}

\begin{tabbing}
MMMMMMM \= MM \= MM \= \kill
$\forall a~b.$
\>
\> $a~@ok@~\wedge~b~@ok@$
\\
\> $\wedge$
\> $@acyclic@~a~b$
\\
\> $\wedge$
\> $@vertical@~a~b$
\\
\> $\wedge$
\> $@distinct@~a~b$
\\
\> $\implies$
\> $\exists c.\ c \in @mergeV@~a~b$
\end{tabbing}




%!TEX root = ../Main.tex
\section{Proofs}
\label{s:Proofs}

As we do not wish to handle recursive combinators, we also do not need to handle merging cyclic machines.
This is one case that regular dataflow handles but we do not.
The predicate below checks if either of the machines does not use the other's input; if both used the other's input, it would create a cycle.

\begin{tabbing}
MMMMMMM \= MM \= \kill
$@acyclic@~a~b$
\> $:=$
\> $\outputs{a}~\cap~\inputs{b}~=~\emptyset$
\\
\> $~\vee$ \> $\outputs{b}~\cap~\inputs{a}~=~\emptyset$
\end{tabbing}

Two machines cannot be merged if they both provide the same output, or write to the same output channel.

\begin{tabbing}
MMMMMMM \= MM \= \kill
$@distinct@~a~b$
\> $:=$
\> $\outputs{a}~\cap~\outputs{b}~=\emptyset$
\end{tabbing}

\subsection{Preservation}
The result of merging two machines should maintain the pull invariants (\S\ref{s:Machines:Invariants}), provided that the input machines also maintain their invariants.

\begin{tabbing}
MMMMMMM \= MM \= MM \= \kill
$\forall a~b.$
\>
\> $a~@ok@~\wedge~b~@ok@$
\\
\> $\wedge$
\> $@acyclic@~a~b$
\\
\> $\wedge$
\> $@distinct@~a~b$
\\
\> $\implies$
\> $\forall c \in (@merge@~a~b).\ c~@ok@$
\end{tabbing}

\paragraph{Lemma values:} 
for each state $u$ of $@merge@~a~b$, if either event set contain a @Value n@, then the machine's invariant set will contain @Value n@ at state $u$.
(Note that the converse is not true, as @Value n@ will appear in the invariant set, but neither event set for local @Out@s)

We proceed by induction over the @move@ rules.

The only way that @Value n@ can be added to the event set is through the rules (Shared output, ready to read) and (Shared pull, no pending values).
These rules themselves produce state types of @Out@ and @Pull@ respectively, and by the definition of invariant sets @Value@ is inserted for these transitions.

For rule (Local release), the state type is @Release n@ which removes @Value n@ from the invariant set.
Due to the locality preconditions $n~\not\in~@inputs@~m_2$ and $n~\not\in~@outputs@~m_2$, we know that neither of the rules to add @n@ could apply, so neither event set can contain @Value n@.

For the cases that remove a @Value n@ from the event set, the first two, (Release of output) and (Shared release: first release is skip) both only emit skips, so do not affect the invariant set.
This means that while the invariant set may still contain a @Value n@, it is not obliged to.
We appeal to the induction hypothesis for the input transitions, since earlier input transitions must have added the @Value n@ to both sets.

The last case that removes a @Value n@ from the event set is (Shared release: other machine already released).
Here, we know the first machine's event set, $e_1$, contains a @Value n@ and that the second machine's event set, $e_2$, does not.
This means that after removing the @Value n@ from $e_1$, neither set will have one.
The produced state type also means that the invariant set will no longer have a @Value n@.

For the remaining cases, the @Value@s inside the event sets are left alone, and their state types do not explicitly remove any @Value n@s from the invariant set either.
We can conclude that any @Value@s in the sets have been added by other states, and not removed.
The last thing is that @Value@s can be implicitly removed at join-points of states.
However, in order for a state to have @Value@s in its sets, all transitions into this state must have either inserted @Value@s itself, or kept @Value@s from its predecessors in turn; otherwise it would not have a transition to a state with @Value@s in its sets.

\paragraph{Lemma closes and finishes:} 
for each state $u$ of $@merge@~a~b$, if \emph{either} event set contains a @Finish n@, the invariant set at state $u$ will also contain a @Finish n@.
If \emph{both} event sets contain a @Close n@, the invariant set will contain a @Close n@.

This proof proceeds very similarly to the above lemma.
For (Finish shared output, no pending events), a @Finished n@ is added to $e_2$, while @OutFinished n@ adds a @Finish n@ to the invariant set.
For (Shared pull, no pending values), a @Pull@ is emitted, and the @None@ case adds @Finished n@ to both sets, as with the invariant set.


\paragraph{Lemma locals:} for any reads, outs or closes in one machine that are not in @inputs@ or @outputs@ of the other machine, no state in the other machine will affect the invariant set relating to these channels.
By definition of @inputs@ and @outputs@.

\paragraph{Lemma transitions:} for each state $u$ of $@merge@~a~b$ and corresponding states $s$ and $t$ of $a$ and $b$, any output transitions from $u$ either move along $s$'s output transitions or $t$'s output transitions, but not both.
Similarly, the state type of $u$ will either be the type of $s$, the type of $t$, or a @Skip@.
By inspection of each rule of @move@.

\paragraph{Lemma paths:} for two given states $u$ and $v$ of $@merge@~a~b$, and their corresponding input machine states $s$ and $t$, for each path between $u$ and $v$, there exists a path between $s$ and $t$ such that all states in the $st$ path are in the $uv$ path, \emph{except}:
\begin{itemize}
\item @Pull@s can be omitted if every predecessor path of the @Pull@ has a @Pull@, @Out@ or @OutFinished@ on the same channel;
\item @Release@s can be omitted if the channel is an output of the other machine;
\item @Release@s can be omitted if every successor path has a @Release@ on the same channel;
\item @Close@s can be omitted if every successor path has a @Close@ or @Pull@ on the same channel.
\end{itemize}

It is easy to see that for non-interfering transitions @Update@, @Skip@, @If@ and @Done@, this holds.
For the other cases, it is necessary to perform induction over the @move@ rules, and inspect the event sets.
If one of the input machine's states is a @Pull@, then either a @Pull@ or a @Skip@ may be produced.
@Skip@s are only produced if the event set already contains a @Value@ or a @Finished@, which can only be produced by an earlier @Pull@, @Out@ or @OutFinished@.
Likewise for the remaining cases.


\paragraph{Proof sketch:} 
We can use the above lemmas to show that if the two input machines are valid, the result of @merge@ will also be valid.
For non-shared or local channels, it is easy to see that the invariant set for these channels will be exactly as it was in the input machine (lemma locals).

For shared inputs, since each input machine is valid, we know all @Pull@s are paired with @Release@s.
Given lemma values, and that @Release@s remove @Value@s from the invariant set, we can see that each generated @Pull@ on a shared resource will only be generated when the invariant set has no @Value@s, and will be similarly paired for @Release@s.

For shared outputs, we just need to verify that the only way the reading machine can reach a reading state is while there is a @Value n@ in the invariant set, and this also follows easily from lemma values.

Finally, we can see as a result of lemma closes and finishes and paths, that since both machines finish or close their inputs and outputs by their @Done@ state, then by the @Done@ of the merged machine, where both machines are also @Done@, all channels must be similarly closed at the end.




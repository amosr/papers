%!TEX root = ../Main.tex
\section{Notes}
\label{s:Notes}

Despite the years of work on array combinator fusion, scheduling dataflow networks and streaming languages, it seems one combinator has been cast aside as jetsam: the humble merge join.
Unlike the simple access patterns of append or zip, the merge join consumes from each of its inputs in a value-dependent order, always pulling from the input with the lowest associated key.
Most dataflow language optimisations tend to focus on fully static networks where the exact access pattern is known at compile time\cite{thies2002streamit}, but disallowing combinators like merge join, append and filter.
At the other side of the spectrum, some dataflow languages such as Lucid\cite{stephens1997survey} focus on expressivity, forgoing any kind of static analyses for optimisations.

Merge joins, appends, and filters are not typically necessary for the bulk kind of operations such as audio transforms, video compression and so on, that regular dataflow has found its applications in\cite{johnston2004advances}.
However, for querying large data sets, these kind of combinators are essential.
The ``MapReduce'' framework has been touted as a solution to easy distribution of workloads, but has been found to be lacking in flexibility\cite{vrba2009kahn}, in favour of Kahn process networks.
Kahn process networks alone are too flexible: many interesting properties we would like to assure, such as the absence of deadlocks, and ability to run in bounded memory, are undecidable.
Regular dataflow languages correspond to a subset of Kahn process networks, restricted to the point of keeping these desired properties\cite{thies2009language}.

Our goal, then, appears relatively simple: to extend the regular dataflow languages enough to allow this subset of dynamic combinators, while keeping the desired properties, for the purpose of compilation and optimisation.

\subsection{Streams and combinators}
First, we define an abstraction of two-input combinators, very similar to stream fusion\CITE or co-iterative stream functions of Caspi and Pouzet\cite{caspi1998co}.
We present a simplified stateless version here, which would not be able to express all useful combinators (such as segmented scan) but suffices for merge, append and zip.
We also only treat combinators that consume both input streams linearly, which excludes combinators like cross product or gather.
In Coq\footnote{The definitions have been reordered for clarity}:

\begin{code}
Definition Stream2 (a b c : Set)
 := option a -> option b -> Step2 c

Inductive Step2 c :=
 | MkStep2 : Move -> Move -> option c -> Step2 c
 | Done    : Step2 c.

Inductive Move :=
 | Forward
 | Stay.
\end{code}

At each evaluation step, a @Stream2@ is called with the value at each input stream, or @None@ if the input stream is finished.
The return of each @Stream2@ evaluation step can be either a @MkStep2@ indicating that further processing is possible, or @Done@, in which case the combinator has finished.
A @MkStep2@ contains two @Move@s, which designate which input streams should be consumed and the next value pulled, and which should stay where they are.
@MkStep2@ also contains an optional output value.

\subsubsection{Examples}

Below, we show example combinators.
The first combinator pairwise zips two streams together, consuming both streams in lock-step.

\begin{code}
Definition Zip (A B : Set)
 :  Stream2 A B (A*B)
 := fun a b =>
    match (a,b) with
    | (Some a, Some b)
    => MkStep2 Forward Forward (Some (a,b))
    | _               
    => Done
    end.
\end{code}

Next, append consumes from the left stream until it is empty, then consumes the right stream.
\begin{code}
Definition Append (A : Set)
 :  Stream2 A A A
 := fun a b =>
    match (a,b) with
    | (Some a, _)
    => MkStep2 Forward Stay    (Some a)
    | (None,   Some b)
    => MkStep2 Stay    Forward (Some b)
    | (None,   None)               
    => Done
    end.
\end{code}

As a final example, the merge join inspects both its input elements, and consumes the one with the smallest value.
There are many variations on this theme, but this particular version that outputs all values in order is actually equivalent to a segmented append.

\begin{code}
Definition MergeJoin (A : Set)
 :  Stream2 (nat*A) (nat*A) (nat*A)
 := fun a b =>
    match (a,b) with
    | (Some (ia,a), Some (ib, b))
    => if   le_dec ia ib
       then MkStep2 Forward Stay (Some (ia, a))
       else MkStep2 Stay Forward (Some (ib, b))
    | (Some (ia,a), None)
    =>      MkStep2 Forward Stay (Some (ia,a))
    | (None, Some (ib,b))
    =>      MkStep2 Stay Forward (Some (ib,b))
    | (None, None)
    =>      Done
    end.
\end{code}

%!TEX root = ../Main.tex
\section{Machines}
\label{s:Machines}

We use a particular type of deterministic finite automata (DFAs) where each state has a type that restricts the alphabet of output transitions.
We use state types such as @Pull a@ with output transitions @Some a@ and @None@, or type @Out b@ with single output transition @Unit@.

\subsection{Restricted DFA}

We describe a restricted automaton as a eight-tuple, extending the standard description by three elements: $(Q, \Sigma, \delta, q_0, F, \Gamma, \gamma, \sigma)$.

As usual, $Q$ is the set of states, $\Sigma$ the alphabet, but in addition $\Gamma$ is a set of state types.
We define the types of functions as follows:

\[ \gamma : Q \to \Gamma \]
Every state has a type.

\[ \sigma : \Gamma \to \{ \Sigma \} \]
Every type has some subset of the alphabet that transitions are required for.

\[ \delta : \forall q : Q. \sigma(\gamma(q)) \to Q \]
For each state, the transition function need only be defined for those letters of the state's type.

These restricted DFAs can be converted to normal automata by adding a rejecting sink state, and adding transitions for all missing letters of the alphabet to this rejecting state.

\subsection{State types}
We now describe a set of types and alphabet for describing combinator programs as a restricted DFA.
These are parameterised by both the names of sources, sinks and bindings $n$, and the type of worker functions $f$ (such as @Expression@ for code generation).

\begin{tabbing}
MM \= MM \= MMMMMM \= M \= M \kill
$\Gamma$ \> $=$ \> @Pull@     \>     \> $n$         \\
         \>     \> (Attempt to read from a named input) \\

         \> $~|$\> @Release@  \>     \> $n$         \\
         \>     \> (Read inputs must be released) \\

         \> $~|$\> @Out@      \> $f$ \> $n$         \\
         \>     \> (Emit the value computed by $f$ to output channel $n$) \\

         \> $~|$\> @OutDone@  \>     \> $n$         \\
         \>     \> (Signal that output channel $n$ is complete) \\

         \> $~|$\> @If@       \> $f$ \> $n$         \\
         \>     \> (If based on current state of output channel $n$) \\

         \> $~|$\> @Update@   \> $f$ \> $n$         \\
         \>     \> (Update output channel $n$'s current state) \\

         \> $~|$\> @Skip@     \>                    \\
         \>     \> (Simple goto, useful for code generation) \\

         \> $~|$\> @Done@     \>                    \\
         \>     \> (The program is finished) \\
\end{tabbing}

Each of these state types requires a corresponding set of output transitions to be defined.
\begin{tabbing}
MMMMMMMM \= M \= \kill
$\gamma(@Pull @n)$
                            \> $=$ \> \{@Some@ n, @None@\} \\
$\gamma(@Release @n)$
                            \> $=$ \> \{@Unit@\} \\
$\gamma(@Out @   f~n)$
                            \> $=$ \> \{@Unit@\} \\
$\gamma(@OutDone @ n)$
                            \> $=$ \> \{@Unit@\} \\
$\gamma(@If @    f~n)$
                            \> $=$ \> \{@True@, @False@\} \\
$\gamma(@Update @f~n)$
                            \> $=$ \> \{@Unit@\} \\
$\gamma(@Skip@      )$
                            \> $=$ \> \{@Unit@\} \\
$\gamma(@Done@      )$
                            \> $=$ \> \{\} \\
\end{tabbing}


\subsection{Combinators}
Many interesting combinators can be described using these machines.
Below, the machines for some important combinators are given.
The machines are described in an almost BASIC-like syntax with numbered state labels before the colon, followed by the state, and then the transitions.
If the transitions are not shown, a @Unit@ transition to the next numbered state is implicit.
The combinator's output channel is assumed to be named @o@.

While writing combinators in this form is neither pleasant nor pretty, it only needs to be done once.
The implementation contains more combinators such as group by, append and indices of segment lengths.

\subsubsection{map f xs}
\begin{code}
10: Pull xs         (Some x => 20; None  => 90)
20: Out o (f x)
30: Release x       (Unit   => 10)

90: OutDone o
99: Done
\end{code}

\subsubsection{filter p xs}
\begin{code}
10: Pull xs         (Some x => 20; None  => 90)
20: If (p x)        (True   => 30; False => 40)
30: Out o x
40: Release x       (Unit   => 10)

90: OutDone o
99: Done
\end{code}

\subsubsection{zip xs ys}
\begin{code}
10: Pull xs         (Some x => 20; None  => 90)
20: Pull ys         (Some x => 30; None  => 80)
30: Out o (x, y)
40: Release x
50: Release y       (Unit   => 10)

80: Release x
90: OutDone o
99: Done
\end{code}

\subsubsection{merge xs ys}
\begin{code}
10: Pull xs         (Some x => 20; None  => 100)
20: Pull ys         (Some y => 30; None  => 201)
30: If (x <= y)     (True   => 40; False => 50)

40: Out o x
41: Release x
42: Pull x          (Some x => 30; None  => 101)

50: Out o y
51: Release y
52: Pull y          (Some y => 30; None  => 201)

-- xs is empty
100: Pull ys        (Some y => 101; None => 900)
101: Out o y
102: Release y      (Unit   => 100)

-- ys is empty
200: Pull xs        (Some x => 201; None => 900)
201: Out o x
202: Release x      (Unit   => 200)

900: OutDone o
901: Done
\end{code}






Figures 1-3 show automata for combinators @map@, @filter@ and @zip@.
To reduce clutter, these figures omit labels for @Unit@ transitions.



\input{figures/Combinators.tex}


\subsection{Code extraction}

Extracting imperative code from these machines is quite straightforward.
Variables are created for each 
Each state is converted to a basic block and given a unique identifier as its label.



\documentclass[acmlarge,review,anonymous]{acmart}\settopmatter{printfolios=true}

\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{mathptmx}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage{hyperref}
\usepackage{alltt}
\usepackage{url}
\usepackage{float}
\usepackage{style/utils}
\usepackage{style/code}
\usepackage{style/proof}
\usepackage{style/keywords}
\usepackage{style/layout}
\usepackage{style/judgements}

% for combinator pictures
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\usepackage[outputdir={out/}]{dot2texi}

\setcopyright{none}
\bibliographystyle{ACM-Reference-Format}

% -----------------------------------------------------------------------------
\begin{document}

\title{Merging merges, more or less}

\author{Amos Robinson}
\affiliation{
  \position{UNSW (Australia)}
}
\email{amosr@cse.unsw.edu.au}

\author{Ben Lippmeier}
\affiliation{
  \position{Vertigo Technology (Australia)}
}
\email{benl@vergo.co}

\makeatactive
\begin{abstract}
Fusion is an essential part of optimising high-level array computations.
Fusion systems for combinators tend to focus on combinators with data-independent access patterns such as @zip@, @filter@ and @map@ while ignoring data-dependent combinators such as the @merge@ used in merge sort.

When stream programs are encoded as labelled transition systems, some fusion can be done by computing the synchronised product of two transition systems, but this suffers deadlock when the two programs share multiple inputs and read them in different orders.
By annotating transition states with the status of each input channel, our fusion algorithm works for these cases where synchronised product does not.
\end{abstract}


\maketitle


\input{section/01-Introduction.tex}
\input{section/XX-Processes.tex}
\input{section/XX-Fusion.tex}

\input{section/scrub.tex}


\bibliography{Main}

\end{document}



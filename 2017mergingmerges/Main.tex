\documentclass[acmlarge,review,anonymous]{acmart}\settopmatter{printfolios=true}

\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{mathptmx}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage{hyperref}
\usepackage{alltt}
\usepackage{url}
\usepackage{float}
\usepackage{style/utils}
\usepackage{style/code}
\usepackage{style/proof}
\usepackage{style/keywords}
\usepackage{style/layout}
\usepackage{style/judgements}

% for combinator pictures
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\usepackage[outputdir={out/}]{dot2texi}

\setcopyright{none}
\bibliographystyle{ACM-Reference-Format}

% -----------------------------------------------------------------------------
\begin{document}

\title{Machine fusion}
\subtitle{Merging merges, more or less}

\author{Amos Robinson}
\affiliation{
  \position{UNSW (Australia)}
}
\email{amosr@cse.unsw.edu.au}

\author{Ben Lippmeier}
\affiliation{
  \position{Vertigo Technology (Australia)}
}
\email{benl@vergo.co}

\makeatactive
\begin{abstract}

Fusion is an essential part of optimising high-level array and streaming computations, as it reduces memory traffic and intermediate arrays.
The benefits of removing intermediate arrays are even more important as data sizes approach the size of memory.
When comparing fusion systems, three important criteria to consider are: whether the system supports splits, where a stream is used multiple times; whether it supports joins, where a combinator has multiple inputs; and whether arbitrary combinators such as @merge@ and segmented appends can be encoded.
Existing fusion systems support one or two of these, but not three.
We present a fusion system based on process calculus that supports all three: splits, joins and arbitrary combinators.

\amos{``Arbitrary combinators'' is not quite true. How can we distinguish combinators we support from 2013 data flow fusion paper?}

We encode each combinator as a separate process with any number of input and output channels.
Each process is sequential but multiple processes can be executed concurrently.
We give a concurrent execution semantics for multiple processes, but these are used only as a specification for how the fused program must behave.
The fused program itself is sequential and can easily be converted to simple imperative code.

Our fusion algorithm takes two concurrently executable processes and creates a sequential interleaving of the two such that they execute with no unbounded buffers.
If fusion would require unbounded buffers (or the fusion algorithm wrongly infers that it would) then fusion fails.
If fusion fails, the user can be presented with an error message telling them which combinators could not be fused.
For scenarios where fusion is required, this is a great advantage over fragile shortcut fusion systems.

Our system has been formalised in Coq where we have proved soundness of the fusion algorithm.
It is expressive enough to encode a wide range of combinators including operations on segmented arrays.
The version presented here deals with infinite streams, and we informally describe the extensions required to support finite streams.
\end{abstract}


\maketitle


\input{section/01-Introduction.tex}
\input{section/XX-Processes.tex}
\input{section/XX-Fusion.tex}

\input{section/XX-Proof.tex}
\input{section/XX-Related.tex}
\input{section/XX-FutureWork.tex}
\input{section/A1-Combinators.tex}


\bibliography{Main}

\end{document}



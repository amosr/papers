%!TEX root = ../Main.tex

% Settle on a syntax for this later.
% Might be too many nested pairs.
\newcommand\nextStep[5]{\big((#1,~#2),~(#3,~#4),~#5 \big)}

\begin{figure}

\begin{tabbing}
@MMMMMMMMMMMM@   \TABDEF \kill

$\InputState_1$ \> := \> $@pending@ ~|~ @have@ ~|~ @none@$
\\
$\Label_1$ \> := \> $\Label~\times~\MapType{\Chan}{\InputState_1}$ \\
$\Label$   \> := \> $\ldots ~|~\Label_1~\times~\Label_1 ~|~ \ldots$ \\
$\Var$     \> := \> $\ldots ~|~@chan@~\Chan ~|~ \ldots$ \\
\\

$\ChanType_2$   \> := \> $@in2@~|~@in1@~|~@in1out1@~|~@out1@$ \\
\end{tabbing}

\caption{Fusion types}
\label{fig:Fusion:Types}
\end{figure}

\begin{figure}

\begin{tabbing}
\ti{fuseNetwork}~@M M@   \TABDEF \kill

\TODO{deal with maybes} \\
\TODO{try permutations of process orders} \\
\\
\ti{fuseNetwork} \> $~:$ \> $\sgl{\Proc} \to  \Maybe~\Proc$ \\
\ti{fuseNetwork}~$\sgl{p}$ \> $=$ \> $p$ \\
\ti{fuseNetwork}~$\ti{ps}$
    \> $~|$      \> $p \in \ti{ps} ~\wedge~ q \in \ti{ps} ~\wedge~ p \not\eq q ~\wedge~ \ti{connected}~p~q$ \\
    \> $=$ \> $\ti{fuseNetwork}~(\sgl{\ti{fusePair}~p~q}~\cup~\ti{ps} \setminus \sgl{p,q})$ \\
\\
\ti{fusePair} \> $~:$ \> $\Proc \to \Proc \to  \Maybe~\Proc$ \\
$\ti{fusePair}~p~q$ \> $=$ \\
@    process@ \\
@        ins: @ $\sgl{c~|~c=t \in \cs,~t \in \sgl{@in1@,@in2@}} $ \\
@       outs: @ $\sgl{c~|~c=t \in \cs,~t \in \sgl{@in1out1@,@out1@}} $ \\
@       heap: @ $@heap@~p~\cup~@heap@~q$ \\
@      label: @ $l_0$ \\
@     blocks: @ $\ti{go}~\sgl{}~l_0$ \\
@ where@ \\
MM\=MM\=~=~\=\kill
 \> \cs \> $=$ \> $\ti{channels}~p~q$ \\
 \> $l_0$   \> $=$ \> $
      \big( 
      (@label@~p,~\sgl{c=none~|~c~\in~@ins@~p}),~
      (@label@~q,~\sgl{c=none~|~c~\in~@ins@~q})
      \big)$ \\
 \\
 \> $\ti{go}~\ti{bs}~l$ \\
 \> \> $~|$ \> $l~\in~\ti{bs}$ \\
 \> \> $=$  \> $\ti{bs}$ \\
 \> \> $~|$     \> $@label@'~l_p~l_q~\in~l$ \\
 \> \> $\wedge$ \>
        $b~\in~\ti{tryStepPair}~\cs~l_p~(@blocks@~p~l_p)~l_q~(@blocks@~q~l_q)$ \\ 
 \> \> $=$ \> $\ti{fold}~\ti{go}~(\ti{bs}~\cup~\sgl{l=b})~(\ti{outlabels}~b)$ \\
\end{tabbing}
\caption{Fusion top-level definitions}
\label{fig:Fusion:Def:Top}
\end{figure}


% I tried this colour in a colour blindness simulator and it seems to be OK.
% Should still be readable when converted to grayscale.
\definecolor{notec}{HTML}{C03020}
\newcommand\note[1]{\textcolor{notec}{(#1)}}

\begin{figure}

\TODO{Is this syntax too weird a mixture of haskell and ml?}
\begin{tabbing}
M \= M \= M \= M \kill
$\ti{tryStep} ~:~ \ChanTypeMap \to \Label_1 \to \Instr \to \Label_1 \to \Maybe~\Instr$ \\
$\ti{tryStep} ~\cs~(l_p,s_p)~i_p~(l_q,s_q)~=~@match@~i_p~@with@$ \\

\> $@pull@~c~x~(l',u')$ \\
\> \> \note{Single input}\\
\> \> $~|~c=@in1@\in\cs$ \\
\> \> $\to~@pull@~c~x~
      \nextStep
        {l'}{s_p}
        {l_q}{s_q}
        {u'}
    $ \\

\> \> \note{Shared input and in/out are both the same if we already have an injected value}\\
\> \> $~|~(c=@in2@\in\cs \vee c=@in1out1@\in\cs) ~\wedge~ c=@pending@ \in s_p$ \\
\> \> $\to~@jump@~
      \nextStep
        {l'}
          {\HeapUpdateOne{c}{@have@}{s_p}}
        {l_q}
          {s_q}
        {\HeapUpdateOne{x}{@chan@~c}{u'}}
        $ \\

\> \> \note{Shared input where neither have it, so inject into both. Note this machine does not jump to $l'$}\\
\> \> $~|~c=@in2@\in\cs ~\wedge~ c=@none@ \in s_p ~\wedge~ c=@none@ \in s_q$ \\
\> \> $\to~@pull@~c~(@chan@~c)~
      \nextStep
        {l_p}
          {\HeapUpdateOne{c}{@pending@}{s_p}}
        {l_q}
          {\HeapUpdateOne{c}{@pending@}{s_q}}
        {\sgl{}}
  $ \\
\\

\> $@drop@~c~(l',u')$ \\
\> \> \note{Single input, no coordination required} \\
\> \> $~|~c=@in1@\in\cs$ \\
\> \> $\to~@drop@~c~
      \nextStep
        {l'}
          {s_p}
        {l_q}
          {s_q}
        {u'}
      $ \\

\> \> \note{Pulled from other, so fake drop}\\
\> \> $~|~c=@in1out1@\in\cs$ \\
\> \> $\to~@jump@~
      \nextStep
        {l'}
          {\HeapUpdateOne{c}{@none@}{s_p}}
        {l_q}
          {s_q}
        {u'}
      $ \\

\> \> \note{Shared input, but other is still using it so only fake drop}\\
\> \> $~|~c=@in2@\in\cs ~\wedge~ (c=@have@ \in s_q \vee c=@pending@ \in s_q)$ \\
\> \> $\to~@jump@~
      \nextStep
        {l'}
          {\HeapUpdateOne{c}{@none@}{s_p}}
        {l_q}
          {s_q}
        {u'}
      $ \\


\> \> \note{Shared input, other has already fake dropped so we real drop}\\
\> \> $~|~c=@in2@\in\cs ~\wedge~ c=@none@ \in s_q$ \\
\> \> $\to~@drop@~c~
      \nextStep
        {l'}
          {\HeapUpdateOne{c}{@none@}{s_p}}
        {l_q}
          {s_q}
        {u'}
      $ \\
\\

\> $@push@~c~e~(l',u')$ \\
\> \> \note{Single output}\\
\> \> $~|~c=@out1@\in\cs$ \\
\> \> $\to~@push@~c~e~
      \nextStep
        {l'}
          {s_p}
        {l_q}
          {s_q}
        {u'}
      $ \\

\> \> \note{Shared output, other is ready to inject}\\
\> \> $~|~c=@in1out1@\in\cs ~\wedge~ c=@none@ \in s_q$ \\
\> \> $\to~@push@~c~e~
      \nextStep
        {l'}
          {s_p}
        {l_q}
          {\HeapUpdateOne{c}{@pending@}{s_q}}
        {\HeapUpdateOne{@chan@~c}{e}{u'}}
      $ \\

\\

\> $@case@~e~(l'_t,u'_t)~(l'_f,u'_f)$ \\
\> \> $\to~@case@~e~
      \nextStep
        {l'_t}{s_p}
        {l_q}{s_q}
        {u'_t}
      ~
      \nextStep
        {l'_f}{s_p}
        {l_q}{s_q}
        {u'_f}
      $ \\

\\

\> $@jump@~(l',u')$ \\
\> \> $\to~@jump@~
      \nextStep
        {l'_f}{s_p}
        {l_q}{s_q}
        {u'_f}
      $ \\
\end{tabbing}

\caption{Fusion step definition}
\label{fig:Fusion:Def:Step}
\end{figure}

\begin{figure}

\begin{tabbing}
M \= M \= M \= M \kill
$\ti{tryStepPair} ~:~ \ChanTypeMap \to \Label_1 \to \Instr \to \Label_1 \to \Instr \to \Maybe~\Instr$ \\
$\ti{tryStepPair} ~\cs~l_p~i_p~l_q~i_q$ \\
\\

\> \note{If both processes can run, prefer ``useful work now'' over pulls} \\
\> $~|~i_p'~\in~\ti{tryStep}~\cs~l_p~i_p~l_q ~\wedge~ i_q'~\in~\ti{tryStep}~\cs~l_q~i_q~l_p$ \\
\> $\wedge~@pull@~c~x~(l,u)~\not\in~i_p'$ \\
\> $\to~i_p'$ \\
\> $~|~i_p'~\in~\ti{tryStep}~\cs~l_p~i_p~l_q ~\wedge~i_q'~\in~\ti{tryStep}~\cs~l_q~i_q~l_p$ \\
\> $\wedge~@pull@~c~x~(l,u)~\not\in~i_q'$ \\
\> $\to~\ti{fliplabels}~i_q'$ \\
\\

\> \note{Otherwise only one process can run or both are pulls} \\
\> \note{If both are pulls, take the first, otherwise take whichever can run} \\
\> $~|~i_p'~\in~\ti{tryStep}~\cs~l_p~i_p~l_q$ \\
\> $\to~i_p'$ \\
\> $~|~i_q'~\in~\ti{tryStep}~\cs~l_q~i_q~l_p$ \\
\> $\to~\ti{fliplabels}~i_q'$ \\

\end{tabbing}

\caption{Fusion step coordination rules}
\label{fig:Fusion:Def:StepPair}
\end{figure}

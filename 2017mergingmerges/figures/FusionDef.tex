%!TEX root = ../Main.tex

\begin{figure}

\begin{tabbing}
@MMMMMMMMMMMM@   \TABDEF \kill

$\InputState_1$ \> := \> @pending@ $~|~$ @have@ $~|~$ @none@
\\
$\Label_1$ \> := \> $@label@_1~\Label~\MapType{\Chan}{\InputState_1}$ \\
$\Label$   \> := \> $\ldots ~|~@label@'~\Label_1~\Label_1 ~|~ \ldots$ \\
$\Var$     \> := \> $\ldots ~|~@chan@~\Chan ~|~ \ldots$ \\
\\

$\ChanType_2$   \> := \> $@in2@~|~@in1@~|~@in1out1@~|~@out1@$ \\
\end{tabbing}

\caption{Fusion types}
\label{fig:Fusion:Types}
\end{figure}

\begin{figure}

\begin{tabbing}
$\ChanType_2$   \TABDEF \kill

\TODO{deal with maybes} \\
\\
\ti{fuseNest} \> $~:$ \> $\sgl{\Proc} \to  \Maybe~\Proc$ \\
\ti{fuseNest}~$\sgl{p}$ \> $=$ \> $p$ \\
\ti{fuseNest}~$\ti{ps}$
    \> $~|$      \> $p \in \ti{ps} ~\wedge~ q \in \ti{ps} ~\wedge~ p \not\eq q ~\wedge~ \ti{connected}~p~q$ \\
    \> $=$ \> $\ti{fuseNest}~(\sgl{\ti{fusePair}~p~q}~\cup~\ti{ps} \setminus \sgl{p,q})$ \\
\\
\ti{fusePair} \> $~:$ \> $\Proc \to \Proc \to  \Maybe~\Proc$ \\
$\ti{fusePair}~p~q$ \> $=$ \\
@    process@ \\
@        ins: @ $\sgl{c~|~c=t \in \cs,~t \in \sgl{@in1@,@in2@}} $ \\
@       outs: @ $\sgl{c~|~c=t \in \cs,~t \in \sgl{@in1out1@,@out1@}} $ \\
@       heap: @ $@heap@~p~\cup~@heap@~q$ \\
@      label: @ $l_0$ \\
@     blocks: @ $\ti{go}~\sgl{}~l_0$ \\
@ where@ \\
MM\=MM\=~=~\=\kill
 \> \cs \> $=$ \> $\ti{channels}~p~q$ \\
 \> $l_0$   \> $=$ \> $@label@'~l_{0p}~l_{0q}$ \\
 \> $l_{0p}$   \> $=$ \> $@label@_1~(@label@~p)~\sgl{c=none~|~c~\in~cs}$ \\
 \> $l_{0q}$   \> $=$ \> $@label@_1~(@label@~q)~\sgl{c=none~|~c~\in~cs}$ \\
 \\
 \> $\ti{go}~\ti{bs}~l$ \\
 \> \> $~|$ \> $l~\in~\ti{bs}$ \\
 \> \> $=$  \> $\ti{bs}$ \\
 \> \> $~|$     \> $@label@'~l_p~l_q~\in~l$ \\
 \> \> $\wedge$ \>
        $b~\in~\ti{tryStepPair}~\cs~l_p~(@blocks@~p~l_p)~l_q~(@blocks@~q~l_q)$ \\ 
 \> \> $=$ \> $\ti{fold}~\ti{go}~(\ti{bs}~\cup~\sgl{l=b})~(\ti{outlabels}~b)$ \\
\end{tabbing}
\caption{Fusion top-level definitions}
\label{fig:Fusion:Def:Top}
\end{figure}


% I tried this colour in a colour blindness simulator and it seems to be OK.
% Should still be readable when converted to grayscale.
\definecolor{notec}{HTML}{C03020}
\newcommand\note[1]{\textcolor{notec}{(#1)}}

\begin{figure}

\newcommand\goto[3]{\ti{goto}~#1~#2~#3}

\TODO{Is this syntax too weird a mixture of haskell and ml?}
\begin{tabbing}
M \= M \= M \= M \kill
$\ti{tryStep} ~:~ \ChanTypeMap \to \Label_1 \to \Instr \to \Label_1 \to \Maybe~\Instr$ \\
$\ti{tryStep} ~\cs~(@label@_1~l_p~s_p)~i_p~(@label@_1~l_q~s_q)~=~@match@~i_p~@with@$ \\

\> $@pull@~c~x~l[u]$ \\
\> \> \note{Single input}\\
\> \> $~|~c=@in1@\in\cs$ \\
\> \> $\to~@pull@~c~x~(\goto{l[u]}{\sgl{}}{\sgl{}}) $ \\

\> \> \note{Shared input and in/out are both the same if we already have an injected value}\\
\> \> $~|~(c=@in2@\in\cs \vee c=@in1out1@\in\cs) ~\wedge~ c=@pending@ \in s_p$ \\
\> \> $\to~@jump@~(\goto{l[x=@chan@~c,u]}{\sgl{c=@have@}}{\sgl{}}) $ \\

\> \> \note{Shared input where neither have it, so inject into both. Note this machine does not jump to $l$}\\
\> \> $~|~c=@in2@\in\cs ~\wedge~ c=@none@ \in s_p ~\wedge~ c=@none@ \in s_q$ \\
\> \> $\to~@pull@~c~(@chan@~c)~(\goto{l_p[\sgl{}]}{\sgl{c=@pending@}}{\sgl{c=@pending@}}) $ \\
\\

\> $@drop@~c~l[u]$ \\
\> \> \note{Single input, no coordination required} \\
\> \> $~|~c=@in1@\in\cs$ \\
\> \> $\to~@drop@~c~(\goto{l[u]}{\sgl{}}{\sgl{}}) $ \\

\> \> \note{Pulled from other, so fake drop}\\
\> \> $~|~c=@in1out1@\in\cs$ \\
\> \> $\to~@jump@~(\goto{l[u]}{\sgl{c=@none@}}{\sgl{}}) $ \\

\> \> \note{Shared input, but other is still using it so only fake drop}\\
\> \> $~|~c=@in2@\in\cs ~\wedge~ (c=@have@ \in s_q \vee c=@pending@ \in s_q)$ \\
\> \> $\to~@jump@~(\goto{l[u]}{\sgl{c=@none@}}{\sgl{}}) $ \\

\> \> \note{Shared input, other has already fake dropped so we real drop}\\
\> \> $~|~c=@in2@\in\cs ~\wedge~ c=@none@ \in s_q$ \\
\> \> $\to~@drop@~c~(\goto{l[u]}{\sgl{c=@none@}}{\sgl{}}) $ \\
\\

\> $@push@~c~e~l[u]$ \\
\> \> \note{Single output}\\
\> \> $~|~c=@out1@\in\cs$ \\
\> \> $\to~@push@~c~e~(\goto{l[u]}{\sgl{}}{\sgl{}}) $ \\

\> \> \note{Shared output, other is ready to inject}\\
\> \> $~|~c=@in1out1@\in\cs ~\wedge~ c=@none@ \in s_q$ \\
\> \> $\to~@push@~c~e~(\goto{l[@chan@~c=e,u]}{\sgl{}}{\sgl{c=@pending@}}) $ \\
\\

\> $@case@~e~l[u]~l'[u']$ \\
\> \> $\to~@case@~e~(\goto{l[u]}{\sgl{}}{\sgl{}})~(\goto{l'[u']}{\sgl{}}{\sgl{}}) $ \\
\\

\> $@jump@~l[u]$ \\
\> \> $\to~@jump@~(\goto{l[u]}{\sgl{}}{\sgl{}}) $ \\
\\


@where@ \\
\> $\goto{l[u]}{s_p'}{s_q'} ~=~ @label@'~(@label@_1~l~s_p[s_p'])~(@label@_1~l_q~s_q[s_q'])[u]$ \\
\end{tabbing}

\caption{Fusion step definition}
\label{fig:Fusion:Def:Step}
\end{figure}

\begin{figure}

\begin{tabbing}
M \= M \= M \= M \kill
$\ti{tryStepPair} ~:~ \ChanTypeMap \to \Label_1 \to \Instr \to \Label_1 \to \Instr \to \Maybe~\Instr$ \\
$\ti{tryStepPair} ~\cs~l_p~i_p~l_q~i_q$ \\
\\

\> \note{If both processes can run, prefer ``useful work now'' over pulls} \\
\> $~|~i_p'~\in~\ti{tryStep}~\cs~l_p~i_p~l_q ~\wedge~ i_q'~\in~\ti{tryStep}~\cs~l_q~i_q~l_p$ \\
\> $\wedge~@pull@~c~x~l[u]~\not\in~i_p'$ \\
\> $\to~i_p'$ \\
\> $~|~i_p'~\in~\ti{tryStep}~\cs~l_p~i_p~l_q ~\wedge~i_q'~\in~\ti{tryStep}~\cs~l_q~i_q~l_p$ \\
\> $\wedge~@pull@~c~x~l[u]~\not\in~i_q'$ \\
\> $\to~\ti{fliplabels}~i_q'$ \\
\\

\> \note{Otherwise only one process can run or both are pulls} \\
\> \note{If both are pulls, take the first, otherwise take whichever can run} \\
\> $~|~i_p'~\in~\ti{tryStep}~\cs~l_p~i_p~l_q$ \\
\> $\to~i_p'$ \\
\> $~|~i_q'~\in~\ti{tryStep}~\cs~l_q~i_q~l_p$ \\
\> $\to~\ti{fliplabels}~i_q'$ \\

\end{tabbing}

\caption{Fusion step coordination rules}
\label{fig:Fusion:Def:StepPair}
\end{figure}

%!TEX root = ../Main.tex

% -----------------------------------------------------------------------------
\begin{figure}

$$
\arrLR{
  \boxed{\ProcInject{\Proc}{\Value}{\Chan}{\Proc}}
}{
  \boxed{\ProcsInject{\sgl{\Proc}}{\Value}{\Chan}{\sgl{\Proc}}}
}
$$

$$
\ruleIN{
  p[@ins@][c] = @none@
}{
  \ProcInject{p}{v}{c}{p~[@ins@ \mapsto (p[@ins@][c \mapsto @pending@~v]) ] }
}{InjectValue}
$$

$$
\ruleIN{
  c \not\in p[@ins@]
}{
  \ProcInject{p}{v}{c}{p}
}{InjectIgnore}
%
\quad
%
\ruleIN{
  \{~ \ProcInject{p_i}{v}{c}{p'_i} ~\}^i
}{
  \ProcsInject{\sgl{p_i}^i}{v}{c}{\sgl{p'_i}^i}
}{InjectMany}
$$

\caption{Injection of values into input channels}
\label{fig:Process:Eval:Inject}
\end{figure}


% -----------------------------------------------------------------------------
\begin{figure}
\begin{tabbing}
MM \= MMMMMMM \= MM \= MMMMMMMMM\kill
\end{tabbing}


% -----------------------------
$$
  \boxed{
    \ProcBlockShake
      {\Instr}
      {\ChannelStates}
      {\Heap}
      {\Action}
      {\Label}
      {\ChannelStates}
      {\Updates}
  }
$$

$$
\ruleIN{
  is[c] = @pending@~v
}{
  \ProcBlockShake
        {@pull@~c~x~(l,us)}
        {is}
        {\Sigma}
        {\cdot}
        {l}
        {is[c \mapsto @have@]}
        {(us \rhd x = v)}
}{Pull}
$$

$$
\ruleIN{
  \ExpEval{\Sigma}{e}{v}
}{
  \ProcBlockShake
        {@push@~c~e~(l,us)}
        {is}
        {\Sigma}
        {\Push~c~v}
        {l}
        {is}
        {us}
}{Push}
$$

$$
\ruleIN{
  is[c] = @have@
}{
  \ProcBlockShake
        {@drop@~c~(l,us)}
        {is}
        {\Sigma}
        {\cdot}
        {l}
        {is[c \mapsto @none@]}
        {us}
}{Drop}
\ruleIN{
}{
  \ProcBlockShake
        {@jump@~(l,us)}
        {is}
        {\Sigma}
        {\cdot}
        {l}
        {is}
        {us}
}{Jump}
$$

$$
\ruleIN{
  \ExpEval{\Sigma}{e}{@True@}
}{
  \ProcBlockShake
        {@case@~e~(l_t,us_t)~(l_f,us_f)}
        {is}
        {\Sigma}
        {\cdot}
        {l_t}
        {is}
        {us_t}
}{CaseT}
\ruleIN{
  \ExpEval{\Sigma}{e}{@False@}
}{
  \ProcBlockShake
        {@case@~e~(l_t,us_t)~(l_f,us_f)}
        {is}
        {\Sigma}
        {\cdot}
        {l_f}
        {is}
        {us_f}
}{CaseF}
$$

\vspace{2em}

% ----------------
$$
  \boxed{\ProcShake{\Proc}{\Action}{\Proc}}
$$
$$
\ruleIN{
  \ProcBlockShake
    {p[@instrs@][p[@label@]]} 
    {p[@ins@]}
    {p[@heap@]}
    {\alpha}
    {l}
    {is}
    {us}
  \quad
    \ExpEval{p[@heap@]}{us}{\Sigma}
}{
  \ProcShake
        {p}
        {\alpha}
        {p~[    @label@~ \mapsto ~l
           , ~~ @heap@~  \mapsto (p[@heap@] \rhd \Sigma)
           , ~~ @ins@~   \mapsto ~is]}
}{Shake}
$$


\caption{Shaking to advance processes}

% Evaluation: shaking allows proceses to take a step from one label to another as well as produce an output message. If the message is a push, the value is injected to all other processes in the network; otherwise it is an internal step.}
\label{fig:Process:Eval:Shake}
\end{figure}


%!TEX root = ../Main.tex

% -----------------------------------------------------------------------------
\begin{figure}

$$
\arrLR{
  \boxed{\ProcInject{\Proc}{\Value}{\Chan}{\Proc}}
}{
  \boxed{\ProcsInject{\sgl{\Proc}}{\Value}{\Chan}{\sgl{\Proc}}}
}
$$

$$
\ruleIN{
  p[@ins@][c] = @none@
}{
  \ProcInject{p}{v}{c}{p~[@ins@ \mapsto (p[@ins@][c \mapsto @pending@~v]) ] }
}{InjectValue}
%
\ruleIN{
  c \not\in p[@ins@]
}{
  \ProcInject{p}{v}{c}{p}
}{InjectIgnore}
$$

$$
\ruleIN{
  \{~ \ProcInject{p_i}{v}{c}{p'_i} ~\}^i
}{
  \ProcsInject{\sgl{p_i}^i}{v}{c}{\sgl{p'_i}^i}
}{InjectMany}
$$

\caption{Injection of values into input channels}
\label{fig:Process:Eval:Inject}
\end{figure}


% -----------------------------------------------------------------------------
\begin{figure}
$$
\alpha~@:=@~ \Push~\Chan~\Value ~|~ \tau
$$

$$
  \boxed{
    \ProcBlockShake
      {\Instr}{\MapType{\Chan}{\InputState}}{\Sigma}
      {\alpha}
      {\Label}{\MapType{\Chan}{\InputState}}{\MapType{\Var}{\Exp}}
  }
$$


$$
\ruleIN{
  c=@pending@~v \in i
}{
  \ProcBlockShake{@pull@~c~x~(l,u)}{i}{\Sigma}{\tau}{l}{\HeapUpdateOne{c}{@have@}{i}}{u,~x = v}
}{Pull}
\ruleIN{
  c=@have@ \in i
}{
  \ProcBlockShake{@drop@~c~(l,u)}{i}{\Sigma}{\tau}{l}{\HeapUpdateOne{c}{@none@}{i}}{u}
}{Drop}
$$

$$
\ruleIN{
  \ExpEval{\Sigma}{e}{v}
}{
  \ProcBlockShake{@push@~c~e~(l,u)}{i}{\Sigma}{\Push~c~v}{l}{i}{u}
}{Push}
\ruleIN{
}{
  \ProcBlockShake{@jump@~(l,u)}{i}{\Sigma}{\tau}{l}{i}{u}
}{Jump}
$$

$$
\ruleIN{
  \ExpEval{\Sigma}{e}{@true@}
}{
  \ProcBlockShake{@case@~e~(l_t,u_t)~(l_f,u_f)}{i}{\Sigma}{\tau}{l_t}{i}{u_t}
}{CaseT}
\ruleIN{
  \ExpEval{\Sigma}{e}{@false@}
}{
  \ProcBlockShake{@case@~e~(l_t,u_t)~(l_f,u_f)}{i}{\Sigma}{\tau}{l_f}{i}{u_f}
}{CaseF}
$$

$$
  \boxed{\ProcShake{\Proc}{\alpha}{\Proc}}
  \quad
  \boxed{\ProcsShake{\sgl{\Proc}}{\alpha}{\sgl{\Proc}}}
$$

$$
@let@~@instr@~p~=~@instrs@~p~(@label@~p)
$$
$$
\ruleIN{
  \ProcBlockShake
    {@instr@~p} {@ins@~p}{@heap@~p}
    {\alpha}
    {l}{i}{u}
  \quad
    \ExpEval{@heap@~p}{u}{\Sigma}
}{
  \ProcShake{p}{\alpha}{p~\sgl{@label@~=~l,~@heap@~=~(\HeapUpdates{\Sigma}{@heap@~p}),~@ins@~=~i}}
}{Shake}
$$




$$
\ruleIN{
  \ProcShake{p_i}{\tau}{p'_i}
}{
  \ProcsShake{
    \sgl{p_0 \ldots p_i \ldots p_n}
  }{\tau}{
    \sgl{p_0 \ldots p'_i \ldots p_n}
  }
}{ProcessesInternal}
$$

$$
\ruleIN{
  \ProcShake{p_i}{\Push~c~v}{p'_i}
  \quad
  \forall j~|~j \neq i.~
  \ProcInject{p_j}{c}{v}{p'_j}
}{
  \ProcsShake{
    \sgl{p_0 \ldots p_i \ldots p_n}
  }{\Push~c~v}{
    \sgl{p'_0 \ldots p'_i \ldots p'_n}
  }
}{ProcessesPush}
$$


\caption{Evaluation: shaking allows proceses to take a step from one label to another as well as produce an output message.
If the message is a push, the value is injected to all other processes in the network; otherwise it is an internal step.}
\label{fig:Process:Eval:Shake}
\end{figure}


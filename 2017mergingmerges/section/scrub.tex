%!TEX root = ../Main.tex

\section{Processes}
\label{s:ProcessZZZ}

What is interesting here?
Streams are named and infinite.
Output streams are owned by a particular process and can only be written to by it.
Pushes and pulls are blocking.
Pulls can be performed anywhere.
Drops are required for coordination.
This can be thought of as yielding control back to the producer after the value has been used.


\section{Proofs}
\label{s:Proofs}
Proof of soundness is formalised in Coq.

\section{Fully abstract case interpretation}

This cannot be fused because it requires an unbounded buffer.
\begin{code}
zipltgts :: [a] -> [a*a]
zipltgts as =
  let as1 = filter (<0) as
      as2 = filter (>0) as
      aas = zip as1 as2
  in  aas
\end{code}

You might think the following can be fused.
It cannot because we treat @case@ conditions as fully abstract and make no attempt to filter out impossible combinations.
So while it cannot be true that the first filter reaches @>0 = true@ case and the second filter reaches @>0 = false@, we try both combinations and treat it as unfusable.
\begin{code}
zipgts :: [a] -> [a*a]
zipgts as =
  let as1 = filter (>0) as
      as2 = filter (>0) as
      aas = zip as1 as2
  in  aas
\end{code}

\section{Finite streams}
So far we have only treated infinite streams.
Finite streams could easily be encoded as infinite streams padded with a sentinel ``end of file'' element.
However, this plays poorly with the fully abstract case statements, as we would require a case for each element read to check whether it is the end of stream.
Adding these cases, we would end up with similar problems as @zipgts@ above.

One solution is to embed this special case into @pull@ itself, by giving it two actions to perform; one after successful read, one after end of stream.
It may be simpler and more useful to instead perform more sophisticated tracing of the @case@ conditionals though, as this would also solve the @zipgts@ example above.



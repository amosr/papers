%!TEX root = ../Main.tex

% -----------------------------------------------------------------------------
\section{Fusion}
\label{s:Fusion}

The core fusion algorithm constructs a static execution schedule for a single pair of processes. To fuse a whole process group we fuse pairs until only one process remains.

Fig.~\ref{fig:Fusion:Types} shows the auxilliary grammar used during fusion. We use the labels in the result process to encode statically known information about the state of the source processes. A label in the result process consists of a pair of source labels, as well as the static part of the $\InputState$ of each input channel. If the static $\InputState_S$ is $@pending@_S$, there is a value waiting to be pulled, do not know the actual value. We use the (@chan@ c) variable form to represent the stream buffer variable associated with channel @c@ (we used a fresh variable @b1@ back in \S\ref{fig:Process:Fused})

$\ChanType_2$ classifies how channels are used, and possibly shared, between two processes. Type @in2@ indicates that two processes @pull@ from the same channel, which must then be coordinated. Type @in1@ indicates that only a single process pulls from a channel. Type @in1out1@ indicates that one processes pushes to a channel that the other pulls from. Type @out1@ indicates that the channel is pushed to by a single process. Recall that each output channel is uniquely owned and cannot be pushed to by more than one process.

\input{figures/Fusion-types.tex}
\input{figures/Fusion-fusePair.tex}

Fig.~\ref{fig:Fusion:Def:Top} defines the top-level function \ti{fusePair} that fuses a pair of processes together, constructing a new process that computes the outputs of both. We start with a joint label $l_0$ formed from the initial labels of the two source processes. The joint label encodes the source states which both processes will be in at that point. We then use \ti{tryStepPair} to statically choose which of the two processes to advance, and hence which instruction to execute next. The possible destination labels of that instruction (computed with $outlabels$) define new reachable states. As we discover new reachable states we add them to a map $bs$ of joint label to corresponding instruction, and repeat the process to a fixpoint where no more result states can be discovered.

\input{figures/Fusion-tryStepPair.tex}

Function \ti{tryStepPair} defined in Fig.~\ref{fig:Fusion:Def:StepPair} decides which of the two processes to advance.

Clauses (PreferJump1) and (PreferJump2) are heuristics which prioritize processes that can perform a @jump@. This heuristic helps to collect jump instructions together in the result process, which are then easier to optimize in post-fusion optimization (\S\ref{s:Optimisation}). As clause (PreferJump2) calls $\ti{tryStep}$ with the instructions in swapped order, if \ti{tryStep} succeeds we use $\ti{swaplabels}$ to re-swap the labels in the result.

\eject{}
Clauses (DeferPull1) and (DeferPull2) are similar heuristics, deferring @pull@ instructions if possible. We do this because @pull@ instructions may block, while other instructions are more likely to produce immediate results.

Clauses (Run1) and (Run2) apply when one process can advance using some other instruction. We try the first process first, and if it can advance then so be it. This fact means that fusion is left-biased, preferring advancement of the left (first) process over the second.

\input{figures/Fusion-tryStep.tex}

\smallskip
Fig.~\ref{fig:Fusion:Def:Step} defines the \ti{tryStep} function which schedules a single instruction. The \ti{tryStep} function takes the map channel types, along with the current label and associated instruction of the first (left) process, and the current label of the other (right) process.

% the label with static input states and instruction at that label, as well as the other process' label with static input states. 

% Function \ti{tryStep} statically performs shaking for the current process, as well as injection for both processes.

% If the process is pulling or pushing a non-shared channel categorised as @in1@ or @out1@, no coordination is required and injection is ignored. For shared and connected channels, the process can only pull or push if the other process would be willing to accept the injection at the same time. Simple instructions such as @case@ and @jump@ require no coordination and can be executed at any point.

%%% AR: I'm sure all these clauses can be cleaned up. I think the real point to make is that each of these correspond more or less to an injection and shake rule.
Clause (LocalJump) applies when the left process wants to jump.
In this case, the result instruction simply performs the corresponding jump, leaving the other process where it is. 

% When the fused instruction is evaluated, it corresponds to the same (Jump) shake rule on the input process.

Clause (LocalCase) is similar, except that there are two destination labels.

Clause (LocalPush) applies when the left process wants to push to a non-shared, local channel.
In this case the push can be performed directly, with no additional coordination required.

Clause (SharedPush) applies when the left process wants to push to a shared channel. Pushing to a shared channel requires the other process to be ready to accept a value on that channel at the same time. We encode the state constraint of the injection rules by requiring the static input state to be ``$@none@_S$''. When this is satisfied, the push stores the pushed value in a local variable ``$@chan@~c$'' and sets the static input state to ``$@pending@_S$'' which indicates that the value is available.

% In terms of evaluating the input processes, this corresponds to the (ProcessesPush) and (InjectValue) rules where push can only succeed if the other process' dynamic input state is ``@none@''.

\eject{}
Clause (LocalPull) applies when the left process wants to pull from a local channel, which requires no coordination.

Clause (SharedPull) applies when the left process wants to pull from a shared channel that the other process either pulls from or pushes to.
The static state of the process has a ``$@pending@_S$'' value for the channel, which corresponds to a dynamic state of ``$@pending@~(@chan@~c)$''.
When the shared channel has this state it means that one of the processes has already pulled the current value, or the other process has pushed a value. In either case there is a value ready to use. Once the result instruction is executed, successive instructions can use the pending value from ``$(@chan@~c)$'', similarly to the single process (Pull) execution rule.

Clause (SharedPullInject) applies when the left process wants to pull from a shared channel that both processes pull from, and neither process already has a value.

% The static state of both processes is ``$@none@_S$'', so the value can be injected into both.
% We encode the injection rules for the input processes inside the fused process, so that the fused process has explicit control over injection.
% To do this, we pull from the input channel, setting both static states to ``$@pending@_S$''.
% Now the dynamic state of the fused process is ``@have@'' as it has successfully pulled, but we set the static state of the input processes to ``$@pending@_S$'' as from their perspective the value has been injected but not yet pulled.
% This step leaves both processes at their current label, allowing the next step to be (SharedPull).

Clause (LocalDrop) applies when the left process wants to drop the current value from a local channel, which requires no coordination. 

Clause (ConnectedDrop) applies when dropping a value pushed by the other process.
Because the value was not pulled through a channel but instead sent by a local variable, the channel does not need to be dropped.

% We set the static input state to ``$@none@_S$'', essentially performing the (Drop) shake rule statically.

Clauses (SharedDropOne) and (SharedDropBoth) apply when dropping a value that both have pulled.
When both processes pull from the same input, the first drop is a fake drop as with (ConnectedDrop), but the second one is a real drop.
If the other process' static state is not ``$@none@_S$'', the other process has not dropped yet so we perform a fake drop.
Otherwise, we perform the real drop.
After the real drop is performed, both static states will be ``$@none@_S$'' and either process will be able to pull again.


\input{figures/FusionUtils.tex}

\smallskip
Fig.~\ref{fig:Fusion:Utils} contains definitions of some utility functions which are not specific to fusion.
Function \ti{channels} computes the $\ChanType_2$ map for a pair of processes.
Function \ti{outlabels} gets the set of output labels for an instruction - this is used when computing the fixpoint of the instructions map.
Function \ti{swaplabels} flips the order of the compound labels in an instruction.

%!TEX root = ../Main.tex

% -----------------------------------------------------------------------------
\section{Fusion}
\label{s:Fusion}

The core fusion algorithm constructs a static execution schedule for a single pair of processes. To fuse a whole process group we fuse successive pairs of processes until only one remains. 

Fig.~\ref{fig:Fusion:Types} defines some auxiliary grammar used during fusion. We extend the exiting $Label$ grammar with an additional alternative, $Label_S \times Label_S$ which we use for the labels in a fused result process. Each $Label_S$ consists of a $Label$ from one of the  source processes, paired with a map from $Channel$ to the statically known part of that channel's current $\InputState$. The definition of $Label$ is now recursive. While fusing a whole process group, as we fuse pairs of individual processes the labels in the result collect more and more information. Each label of the final, completely fused process encodes the joint state that all the original source processes would be in at that point.

% These new labels $Label_S$ consist of a pair of source labels, as well as the static part of the $\InputState$ of each input channel. 

% If the static $\InputState_S$ is $@pending@_S$, there is a value waiting to be pulled, do not know the actual value. 

We also extend the existing $Variable$ grammar with a (@chan@ c) form which represents the stream buffer variable associated with channel @c@. We only need one stream buffer variable for each channel, and naming them like this saves us from inventing fresh variable names in the definition of the fusion rules (we used a fresh name @b1@ back in \S\ref{s:Fusion:FusingPulls} to avoid introducing a new mechanism at that point in the discussion) 

Still in Fig.~\ref{fig:Fusion:Types}, $\ChanType_2$ classifies how channels are used, and possibly shared, between two processes. Type @in2@ indicates that the two processes @pull@ from the same channel, and these actions must then be coordinated. Type @in1@ indicates that only a single process pulls from the channel. Type @in1out1@ indicates that one process pushes to the channel and the other pulls from the same. Type @out1@ indicates that the channel is pushed to by a single process. Each output channel is uniquely owned and cannot be pushed to by more than one process.

\input{figures/Fusion-types.tex}
\input{figures/Fusion-fusePair.tex}


\smallskip
% -------------------------------------
Fig.~\ref{fig:Fusion:Def:Top} defines function \ti{fusePair} that fuses a pair of processes together, constructing a result process that does the job of both. We start with a joint label $l_0$ formed from the initial labels of the two source processes. We then use \ti{tryStepPair} to statically choose which of the two processes to advance, and hence which instruction to execute next. The possible destination labels of that instruction (computed with $outlabels$ from Fig.~\ref{fig:Fusion:Utils}) define new joint labels and reachable states. As we discover reachable states we add them to a map $bs$ of joint label to corresponding the instruction, and repeat the process to a fixpoint where no more states can be discovered.

\input{figures/Fusion-tryStepPair.tex}

\eject{}
% -------------------------------------
Fig Fig.~\ref{fig:Fusion:Def:StepPair} defines function \ti{tryStepPair} which decides which of two processes to advance.

Clauses (PreferJump1) and (PreferJump2) are heuristics which prioritize processes that can perform a @jump@. This heuristic helps to collect @jump@ instructions together in the result process, which are then easier for post-fusion optimization (\S\ref{s:Optimisation}) to handle. As clause (PreferJump2) calls $\ti{tryStep}$ with the instructions in swapped order, if \ti{tryStep} succeeds we use $\ti{swaplabels}$ (from Fig.~\ref{fig:Fusion:Utils}) to re-swap the labels in the result.

Clauses (DeferPull1) and (DeferPull2) are similar heuristics, which defer @pull@ instructions if possible. We do this because @pull@ instructions may block, while other instructions are more likely to produce immediate results.

Clauses (Run1) and (Run2) apply when one process can advance using some other instruction. We try the first process first, and if it can advance then so be it. This priority means that fusion is left-biased, preferring advancement of the left process over the second.

\input{figures/Fusion-tryStep.tex}


% -------------------------------------
\smallskip
Fig.~\ref{fig:Fusion:Def:Step} defines function \ti{tryStep} which schedules a single instruction. The \ti{tryStep} function takes the map channel types, along with the current label and associated instruction of the first (left) process, and the current label of the other (right) process.

% the label with static input states and instruction at that label, as well as the other process' label with static input states. 

% Function \ti{tryStep} statically performs shaking for the current process, as well as injection for both processes.

% If the process is pulling or pushing a non-shared channel categorised as @in1@ or @out1@, no coordination is required and injection is ignored. For shared and connected channels, the process can only pull or push if the other process would be willing to accept the injection at the same time. Simple instructions such as @case@ and @jump@ require no coordination and can be executed at any point.

%%% AR: I'm sure all these clauses can be cleaned up. I think the real point to make is that each of these correspond more or less to an injection and shake rule.
Clause (LocalJump) applies when the left process wants to jump.
In this case, the result instruction simply performs the corresponding jump, leaving the other process where it is. 

% When the fused instruction is evaluated, it corresponds to the same (Jump) shake rule on the input process.

Clause (LocalCase) is similar, except that there are two destination labels.

Clause (LocalPush) applies when the left process wants to push to a non-shared, local channel.
In this case the push can be performed directly, with no additional coordination required.

Clause (SharedPush) applies when the left process wants to push to a shared channel. Pushing to a shared channel requires the other process to be ready to accept a value on that channel at the same time. We encode the state constraint of the injection rules by requiring the static input state to be ``$@none@_S$''. When this is satisfied, the push stores the pushed value in a local variable ``$@chan@~c$'' and sets the static input state to ``$@pending@_S$'' which indicates that the value is available.

% In terms of evaluating the input processes, this corresponds to the (ProcessesPush) and (InjectValue) rules where push can only succeed if the other process' dynamic input state is ``@none@''.

\eject{}
Clause (LocalPull) applies when the left process wants to pull from a local channel, which requires no coordination.

Clause (SharedPull) applies when the left process wants to pull from a shared channel that the other process either pulls from or pushes to.
The static state of the process has a ``$@pending@_S$'' value for the channel, which corresponds to a dynamic state of ``$@pending@~(@chan@~c)$''.
When the shared channel has this state it means that one of the processes has already pulled the current value, or the other process has pushed a value. In either case there is a value ready to use. Once the result instruction is executed, successive instructions can use the pending value from ``$(@chan@~c)$'', similarly to the single process (Pull) execution rule.

Clause (SharedPullInject) applies when the left process wants to pull from a shared channel that both processes pull from, and neither process already has a value.

% The static state of both processes is ``$@none@_S$'', so the value can be injected into both.
% We encode the injection rules for the input processes inside the fused process, so that the fused process has explicit control over injection.
% To do this, we pull from the input channel, setting both static states to ``$@pending@_S$''.
% Now the dynamic state of the fused process is ``@have@'' as it has successfully pulled, but we set the static state of the input processes to ``$@pending@_S$'' as from their perspective the value has been injected but not yet pulled.
% This step leaves both processes at their current label, allowing the next step to be (SharedPull).

Clause (LocalDrop) applies when the left process wants to drop the current value from a local channel, which requires no coordination. 

Clause (ConnectedDrop) applies when dropping a value pushed by the other process.
Because the value was not pulled through a channel but instead sent by a local variable, the channel does not need to be dropped.

% We set the static input state to ``$@none@_S$'', essentially performing the (Drop) shake rule statically.

Clauses (SharedDropOne) and (SharedDropBoth) apply when dropping a value that both have pulled.
When both processes pull from the same input, the first drop is a fake drop as with (ConnectedDrop), but the second one is a real drop.
If the other process' static state is not ``$@none@_S$'', the other process has not dropped yet so we perform a fake drop.
Otherwise, we perform the real drop.
After the real drop is performed, both static states will be ``$@none@_S$'' and either process will be able to pull again.


% -------------------------------------
\input{figures/FusionUtils.tex}

\smallskip
Fig.~\ref{fig:Fusion:Utils} contains definitions of some utility functions which are not specific to fusion.
Function \ti{channels} computes the $\ChanType_2$ map for a pair of processes.
Function \ti{outlabels} gets the set of output labels for an instruction - this is used when computing the fixpoint of the instructions map.
Function \ti{swaplabels} flips the order of the compound labels in an instruction.

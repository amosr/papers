%!TEX root = ../Main.tex
\section{Processes, Combinators and Operators}
\label{s:Processes}

A \emph{process} in our system is a simple imperative program with a local heap. A process pulls data from an arbitrary number of input streams and pushes result values to at least one output stream. The process language is an intermediate representation we use when fusing the overall dataflow network. A \emph{combinator} is a template for a particular \emph{process} which parameterises it over the particular input and output streams, as well as values of configuration parameters such as the worker function used in a @map@ process. Each process implements a logical \emph{operator}, so we use ``operator'' when describing the values being computed, but ``process'' when referring to the implementation. 

% -----------------------------------------------------------------------------
\subsection{Grouping}

The definition of the @group@ combinator which removes consecutive elements from its input stream is given in Fig.~\ref{fig:Process:Group}. We include the concrete code representation and a diagram of the process viewed as a state machine.

The @group@ combinator has two parameters, @s1@ and @s2@, which bind the input and output streams respectively. The \emph{nu-binders} \mbox{$\nu$ @(f: Bool) (l: Nat)@...} indicate that each time the @group@ combinator is instantiated, fresh names must be given to @f@, @l@ and so on, that do not conflict with other instantiations. 

The body of the combinator is a record that defines the process. The @ins@ field of the record defines the set of input streams and the @outs@ field the set of output streams. The @heap@ field gives the initial values of each of the local variables. The @instrs@ field contains a set of labeled instructions that define the program, while the @label@ field gives the label of the initial instruction. 

The initial instruction @(pull s1 v A1 {})@ pulls the next element from the stream @s1@, writes it into the heap variable @v@ (value), then proceeds to the instruction at label @A1@. The empty set @{}@ after the target label @A1@ can be used to update values in the heap, but as we do not need to perform heap updates yet we leave it empty. 

Next, the instruction @(case (f || (l /= v)) A2 {} A3 {})@ checks whether the predicate @(f || (l /= v))@ is true; if so it proceeds to the instruction at label @A2@, otherwise it proceeds to the instruction at label @A3@.
We use the variable @l@ (last) to track the last value read from the stream, and the boolean @f@ (first) to track whether this is the first element.

When the predicate is true, the instruction @(push s2 v A3 { l = v, f = F })@ pushes the value @v@ to the output stream @s2@ and proceeds to the instruction at label @A3@, once the heap has been updated to set variable @l@ to @v@ and @f@ to @F@ (False). 

Finally, the instruction @(drop s1 A0 {})@ signals that the current element that was pulled from stream @s1@ is no longer required, and goes back to the first the instruction at @A0@. This @drop@ instruction is used to coordinate concurrent processes when performing fusion. The next element of a stream may only be pulled after all consuming processes have pulled and then and dropped the current element.

Overall, the @f@ variable tracks whether we are dealing with the first value from the stream, @l@ holds the last value pulled from the stream (or 0 if none have been read yet), and @v@ holds the current value pulled from the stream. The process emits the first value pulled from the stream and every value that is different from the last one that was pulled. For example, when executed on the input stream $[1, 2, 2, 3]$, the process will produce the output $[1, 2, 3]$.

\begin{figure}

\begin{center}
\begin{alltt}
           group 
             = \(\lambda\) (sG1: Stream Nat) (sG2: Stream Nat). 
               \(\nu\) (f: Bool) (l: Nat) (v: Nat) (A0..A3: Label).
\end{alltt}
\begin{code}
               process
               { ins:    { sG1 }
               , outs:   { sG2 }
               , heap:   { f = T, l = 0, v = 0 }
               , label:  A0
               , instrs: { A0 = pull sG1 v           A1 {}
                         , A1 = case (f || (l /= v)) A2 {}  A3 {}
                         , A2 = push sG2 v           A3 { l = v, f = F }
                         , A3 = drop sG1             A0 {} } }
\end{code}
\end{center}
\vspace{1em}
\includegraphics[scale=1.1]{figures/state-group.pdf}
\caption{The group combinator}
\label{fig:Process:Group}
\end{figure}


% -----------------------------------------------------------------------------
\subsection{Merging}
\begin{figure}
\begin{alltt}
               merge
                 = \(\lambda\) (sM1: Stream Nat) (sM2: Stream Nat) (sM3: Stream Nat). 
                   \(\nu\) (x1: Nat) (x2: Nat) (B0..E2: Label).
\end{alltt}
\begin{code}
                   process
                   { ins:    { s1, s2 }
                   , outs:   { s3 }
                   , heap:   { x1 = 0, x2 = 0 }
                   , label:  B0
                   , instrs: { B0 = pull s1 x1     B1 {}
                             , B1 = pull s2 x2     C0 {}
                             , C0 = case (x1 < x2) D0 {}  E0 {}
                             , D0 = push s3 x1     D1 {}
                             , D1 = drop s1        D2 {}
                             , D2 = pull s1 x1     C0 {}
                             , E0 = push s3 x2     E1 {}
                             , E1 = drop s2        E2 {}
                             , E2 = pull s2 x2     C0 {} } }
\end{code}

\medskip
\includegraphics[scale=1.1]{figures/state-merge.pdf}
\caption{The merge combinator}
\label{fig:Process:Merge}
\end{figure}

The definition of the @merge@ combinator, which merges two input streams, is given in Fig.~\ref{fig:Process:Merge}. The combinator binds the two input streams to @s1@ and @s2@, while the output stream is @s3@. The two heap variables @x1@ and @x2@ are used to store the last values read from each input stream. The process starts by pulling from each input streams. It then compares the two pulled values, and pushes the smaller of the values to the output stream. The process then drops the stream which yielded the the smaller value, then pulls from the same stream so that it can perform the comparison again.

As this process merges infinite streams, if we execute it with a finite input prefix, the result will be an intermediate state that may not yet have pushed all available output. For example, if we execute the process with the input streams $[1, 4]$ and $[2, 3, 100]$ then the values $[1, 2, 3, 4]$ will be pushed to the output.
After pushing the last $4$, the process will block at instruction @E2@, waiting for the next value to be pulled from @s2@. We discuss how to handle finite streams later in ~\S\ref{s:Finite}.


% -----------------------------------------------------------------------------
\subsection{Fusion}
Our fusion algorithm takes two process state machines and produces a new one that computes the outputs of both. For example, suppose we need a single machine that computes the outputs of the first two combinators of our @uniquesUnion@ example back in \S\ref{s:Introduction}. The result will be a machine that computes the result of both the @group@ and @merge@ if they were executed concurrently, where the first input stream of the @merge@ is the same as the input stream of the @group@. For ease of comparison we will assume the parameters in each combinator are instantiated with arguments of the same names.


% -----------------------------------------------------------------------------
\subsubsection{Fusing Pulls}

The algorithm proceeds by considering pairs of states: one in each of the machines to be fused.
Both the @group@ machine and the @merge@ machine pull from the same stream as their initial instruction, so we have the situation shown in Fig.~\ref{fig:Fusion:Pulls}.
The @group@ machine needs to transition from label @A0@ to label @A1@, and the @merge@ machine from @B0@ to @B1@.
In the result machine we produce three new instructions that transition between four result states, @F0@ to @F3@.
Each of the result states represents a combination of two original states, one from each of the input machines.
For example, the first result state @F0@ represents a combination of the @group@ machine being in its initial state @A0@ and the @merge@ machine being in its own initial state @B0@. 

We also associate each of the result states with information describing whether or not each machine has already pulled a value from each input stream, which is used to determine whether another value can be pulled. For the @F0@ case shown in Fig.~\ref{fig:Fusion:Pulls} we have ((A0, \{s1 = none\}), (B0, \{s1 = none, s2 = none\})). The result state @F0@ represents a combination of the two input states @A0@ and @B0@. As both @A0@ and @B0@ are the initial states of their respective machines, those machines have not yet pulled any values from their two input streams, so both @s1@ and @s2@ are set to `none'.

From the joint state @F0@, both of the input machines need to pull from stream @s1@, the @group@ machine storing the value in a variable @v@ and the @merge@ machine storing it in @x1@.
In the result machine this is managed by storing the pulled value in a fresh buffer variable @b1@, and then using later instructions to copy the value into the original variables @v@ and @x1@.
For this we use the @jump@ instruction which transitions between states without affecting any of the input or output streams.


Finally, note that in the result states @F0@ through @F3@ the state of the input streams transitions from `none', to `pending' then to `have'.
The `none' state means that we have not yet pulled a value from the associated stream.
The `pending' state means we have pulled a value into the stream buffer variable (@b1@ in this case).
The `have' state means that we have copied the pulled value from the stream buffer variable into the local variable used by each machine.
In Fig.~\ref{fig:Fusion:Pulls},  `s1' is set to `have' in @F2@ after we have set `v = b1', while `s1' is set to `have' in @F3@ after we have set `x1 = b1'. 


\begin{figure}
\includegraphics[scale=1.1]{figures/fuse-pull-pull.pdf}
\caption{Fusing pull instructions}
\label{fig:Fusion:Pulls}
\end{figure}


% -----------------------------------------------------------------------------
\subsubsection{Fusing Cases}
\begin{figure}
\includegraphics[scale=1.1]{figures/fuse-case-pull.pdf}
\caption{Fusing case instructions}
\label{fig:Fusion:Case}
\end{figure}

Once the result machine has arrived in the joint state @F3@, this is equivalent to the two input machines arriving in states @A1@ and @B1@ respectively.
Fig.~\ref{fig:Fusion:Case} shows the next few transitions of these machines.
From state @A1@, the @group@ machine needs to perform a @case@ branch to determine whether to push the current value it has from its input stream @s1@ to its output stream, which we name @s3@ --- or to just move on to the next value from its input.
From state @B1@, the @merge@ machine needs to pull a value from its second input stream @s2@. 

In the fused result, @F3@ performs the case analysis from @A1@, moving to either @A2@ or @A3@, corresponding to @F4@ and @F5@ respectively.
At @F4@, the push at @A2@ is executed and moves to @A3@, corresponding to @F5@.

Finally, at @F5@ the @merge@ machine pulls from @s2@, moving from @B1@ to @C0@.
Because the stream @s2@ is only pulled from by the @merge@ machine, no coordination is required between @merge@ and @group@ for this pull.
In this case, we simply perform a @pull@ instruction.

In terms of fusion, we could construct the result machine in multiple ways.
One option is to perform the case branch first and then pull from @s2@.
We could alternately pull from @s2@ first and then perform the case branch.
By construction, the predicate used in the branch only refers to variables local to the @group@ machine, and the pull instruction from @B1@ stores its result in a variable local to the @merge@ machine.
As the set of variables does not overlap, either ordering is correct.
For this example we choose to perform the branch first, though will discuss the ramifications of this choice further in \S\ref{s:FusionOrder}.

% -----------------------------------------------------------------------------
\subsection{Fused Result}

Fig.~\ref{fig:Process:Fused} shows the entire result of fusing @group@ and @merge@ together.
The process has two inputs, @s1@ and @s2@, which correspond to the original input streams.
Of the two outputs, @s3@ is the @group@'s output stream, while @s4@ is the @merge@'s output stream.
The heap contains the variables from both processes, as well as the new buffer variable @b1@, which is used to store the current element pulled from @s1@.

For the most part, the fused process simply alternates between performing the instructions of @group@ and those of @merge@.
For the shared input stream @s1@, the two processes must be coordinated so that values are only pulled or dropped when both agree.

The instructions of @merge@ can be split into four categories, which can be identified in the fused process: labels @B0@-@B2@ perform initialisation, and are mapped to @F0@-@F6@; label @C0@ performs case analysis to find the smaller value and is mapped to @F7@; labels @D0@-@D2@ push the value from the first stream, @s1@, and are mapped to @F8@-@F15@; and labels @E0@-@E2@ push the value from the second stream, @s2@, and are mapped to @F16@-@F18@.

The @group@ process can also be identified in the fused process: the fused labels @F0@-@F5@ perform the pulling, case analysis and pushing from instructions @A0@-@A2@.
These instructions are seen again in @F10@-@F14@, when the @merge@ process is pulling from the @s1@ stream.
Thus the @group@ instructions have been duplicated, and are performed once when @merge@ initialises, and again every time @merge@ pulls from the first stream.

Labels @F5@ and @F14@ correspond to the (@drop s1@) instruction at @A3@ in @group@, but note that they are fused as @jump@ instructions.
As @s1@ is shared between the two processes, the element from @s1@ can only be dropped once both processes agree to drop.
In the fused labels on the right hand column, the other process still has @s1@ as `pending' or `have', so the element cannot yet be dropped.
The actual @drop@ is only performed once both processes are `none', at label @F9@.
 

\begin{figure}
\begin{code}
process
{ ins:    { s1, s2 }
, outs:   { s3, s4 }
, heap:   { f = T, l = 0, v = 0, x1 = 0, x2 = 0, b1 = 0}
, label:  F0
, instrs:
\end{code}

\newcommand\annot[5]{
  \tiny ((#1, \> \tiny \{s1 =      #2\}), \> \tiny (#3, \> \tiny \{s1 =      #4, \> \tiny s2 =      #5\}))
}
\newcommand\icase[7]{
 \tt{#1} \> \tt{= #2} \> \tt{#3} \{\tt{#4}\} \> \tt{#5} \{\tt{#6}\} \> \tiny #1 \> \tiny = #7 \\
}
\newcommand\instr[5]{
 \tt{#1}\>\tt{= #2} \> \tt{#3} \{\tt{#4}\} \> \> \tiny #1 \> \tiny = #5 \\
}
\begin{tabbing}
@  @ \=
@, F17@ \= = @case (f || (l /= v)) @
      \= @F17{x1 = b1, f = F}@ \= @F17{ }@
@      @ \= \tiny F17 \= \tiny = ((A0, \= \tiny \{s1 = pending\}), \= \tiny (B0, \= \tiny \{s1 = pending, \= \tiny s2 = pending\})) \kill
\> @{@ \instr{F0}{pull s1 b1}{F1}{}{\annot{A0}{none}{B0}{none}{none}}

\> @,@
\instr{F1}{jump}{F2}{v  = b1}
      {\annot{A0}{pending}{B0}{pending}{none}}
\> @,@
\instr{F2}{jump}{F3}{x1 = b1}
      {\annot{A1}{have}{B0}{pending}{none}}
\> @,@
\icase{F3}{case (f || (l /= v))}{F4}{}{F5}{}
      {\annot{A1}{have}{B1}{have}{none}}

\> @,@
\instr{F4}{push s3 v}{F5}{l = v, f = F}
      {\annot{A2}{have}{B1}{have}{none}}

\> @,@
\instr{F5}{jump}{F6}{}
      {\annot{A3}{have}{B1}{have}{none}}

\> @,@
\instr{F6}{pull s2 x2}{F7}{}
      {\annot{A0}{none}{B1}{have}{none}}
\\

\> @,@
\icase{F7}{case (x1 < x2)}{F8}{}{F16}{}
      {\annot{A0}{none}{C0}{have}{have}}

\\
\> @,@
\instr{F8}{push s4 x1}{F9}{}
      {\annot{A0}{none}{D0}{have}{have}}
\> @,@
\instr{F9}{drop s1}{F10}{}
      {\annot{A0}{none}{D1}{none}{have}}
\> @,@
\instr{F10}{pull s1 b1}{F11}{}
      {\annot{A0}{none}{D2}{none}{have}}
\> @,@
\instr{F11}{jump}{F11}{v = b1}
      {\annot{A0}{pending}{D2}{pending}{have}}
\> @,@
\icase{F12}{case (f || (l /= v))}{F13}{}{F14}{}
      {\annot{A1}{have}{D2}{pending}{have}}
\> @,@
\instr{F13}{push s3 v}{F14}{l = v, f = F}
      {\annot{A2}{have}{D2}{pending}{have}}
\> @,@
\instr{F14}{jump}{F15}{}
      {\annot{A3}{have}{D2}{pending}{have}}
\> @,@
\instr{F15}{jump}{F7}{x1 = b1}
      {\annot{A0}{none}{D2}{pending}{have}}

\\
\> @,@
\instr{F16}{push s4 x2}{F17}{}
      {\annot{A0}{none}{E0}{have}{have}}
\> @,@
\instr{F17}{drop s2}{F18}{}
      {\annot{A0}{none}{E1}{have}{have}}
\> @,@
\instr{F18}{pull s2}{F7}{}
      {\annot{A0}{none}{E2}{have}{none}}

@} }@
\end{tabbing}

% With original label names and 'n', 'h' and 'p' for input state
%\begin{code}
%A0nB0n = pull s1 b1  A0pB0p{}
%A0pB0p = jump        A1hB0p{v  = b1}
%A1hB0p = jump        A1hB1h{x1 = b1}
%
%A1hB1h = case (f || (l /= v))
%                     A2hB1h{}
%                     A3hB1h{}
%
%A2hB1h = push s3 v   A3hB1h{l  = v, f  = F}
%A3hB1h = jump        A0nB1h{}
%A0nB1h = pull s2 x2  A0nC0h{}
%
%A0nC0h = case (x1 < x2)
%                     A0nD0h{}
%                     A0nE0h{}
%
%A0nD0h = push s4 x1  A0nD1h{}
%A0nD1h = drop s1     A0nD2n{}
%A0nD2n = pull s1 b1  A0pD2p{}
%A0pD2p = jump        A1hD2p{v  = b1}
%
%A1hD2p = case (f || (l /= v))
%                     A2hD2p{}
%                     A3hD2p{}
%
%A2hD2p = push s3 v   A3hD2p{l  = v, f  = F}
%A3hD2p = jump        A0nD2p{}
%A0nD2p = jump        A0nC0h{x1 = b1}
%
%A0nE0h = push s4 x2  A0nE1h{}
%A0nE1h = drop s2     A0nE2h{}
%A0nE2h = pull s2 x2  A0nC0h{}
%\end{code}

% Cleaned up, simplified, variables collated
% \begin{code}
%             process
%             { ins:    { s1, s2 }
%             , outs:   { s3, s4 }
%             , heap:   { f = T, l = 0, x1 = 0, x2 = 0}
%             , label:  F0
%             , instrs: { F0 = pull s1 x1              F3 {}
%                       , F3 = case (f || (l /= x1))   F4 {} F5 {}
%                       , F4 = push s3 x1              F5 { l = x1, f = F }
%                       , F5 = pull s2 x2              F6 {}
% 
%                       , F6 = case (x1 < x2)          A0 {} B0 {}
% 
%                       , A0 = push s4 x1              A1 {}
%                       , A1 = drop s1                 A2 {}
%                       , A2 = pull s1 x1              A3 {}
%                       , A3 = case (f || (l /= x1))   A4 {} F6 {}
%                       , A4 = push s3 x1              F6 { l = x1, f = F }
% 
%                       , B0 = push s4 x2              B1 {}
%                       , B1 = drop s2                 B2 {}
%                       , B2 = pull s2 x2              F6 {} } }
% \end{code}
\caption{Fusion of group and merge}
\label{fig:Process:Fused}
\end{figure}



\subsection{Optimisation}
After the algorithm has completed fusing both processes it may be possible to eliminate redundant @jump@, depending on how the affected variables are used by other instructions.

\TODO{Discuss combining jump instructions here. Use this to motivate the need for drop instructions.}






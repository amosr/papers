%!TEX root = ../Main.tex

\clearpage{}
% -----------------------------------------------------------------------------
\section{Process definitions}

\input{figures/ProcessDef.tex}

The grammar for process definitions is given in Fig.~\ref{fig:Process:Def}. Variables, Channels and Labels are specified by unique names. We refer to the \emph{endpoint} of a stream as a channel. A particular stream may flow into the input channels of several different processes, but can only be produced by a single output channel. For values and expressions we use an untyped lambda calculus with a few primitives chosen to facilitate the examples. The `$||$' operator is boolean-or, `+' addition, `/=' not-equal, and `$<$' less-then.

A $\Proc$ is a record with five fields: the @ins@ field specifies the input channels; the @outs@ field the output channels; the @heap@ field the process-local heap; the @label@ field the label of the currently being executed instruction, and the @instrs@ a map of labels to instructions. We use the same record when specifying both the definition of a particular process, as well as when giving the evaluation semantics. When specifying a process the @label@ field gives the entry-point to the process code, though during evaluation it is the label of the instruction currently being executed. Likewise, when specifying a process we usually only list channel names in the @ins@ field, though during evaluation they are also paired with their current $\InputState$. If an $\InputState$ is not specified we assume it is `none'.

In the grammar of Fig.~\ref{fig:Process:Def} the $\InputState$ has three options: @none@, which means no value is currently stored in the associated stream buffer variable, $(@pending@~\Value)$ which gives the current value in the stream buffer variable and indicates that it has not yet been copied into a process-local variable, and @have@ which means the pending value has been copied into a process-local variable. The $\Value$ attached to the @pending@ state is used when specifying the evaluation semantics of processes. During fusion, the $\Value$ itself will not be known, but we can still reason statically that a process must be in the @pending@ state. We will use a different version of $\InputState$ in \S\ref{s:Fusion} when we define the fusion algorithm.

The @instrs@ field of the $\Proc$ maps labels to instructions. The possible instructions are: @pull@, which pulls the next value from a channel into a given heap variable; @push@, which pushes the value of an expression to an output channel; @case@ which branches depending on the result of a boolean expression; @jump@ which causes control to move to a new instruction, and @drop@ which indicates that the current value pulled from a channel is no longer needed. 

All instructions include a $\Next$ field which is a pair of the label of the next instruction to execute, as well as a list of $\Var \times \Exp$ bindings used to update the heap. The list of update bindings is attached directly to instructions to make the fusion algorithm easier to specify, in contrast to a presentation with a separate @update@ instruction. 

As with Kahn processes~\cite{kahn1976coroutines}, pulling from a channel is blocking. Unlike Kahn processes, pushing to a channel can also block. Each consumer has a single element buffer, which is the stream buffer variable, and pushing can only succeed when that buffer is empty.

When lowering process code to a target language, such as C, LLVM, or some sort of assembly code, we can safely ignore the @drop@ instructions. The @drop@ instructions are used to help control how processes being fused should be synchronized, but do not affect the execution of a single process. We will discuss @drop@s further in \S\ref{s:Optimisation}.


% -----------------------------------------------------------------------------
\subsection{Execution}
\label{s:Process:Eval}

\input{figures/ProcessEval.tex}
\input{figures/ProcessFeed.tex}

Execution of process networks consists of three aspects:

\begin{enumerate}
\item \emph{Injection}, which attempts to provide a single value gained from a stream to a process, or a set of processes. Each individual process only needs to accept the value when it is ready for it, and injection of a value into a set of processes succeeds only when they \emph{all} accept it.

\item \emph{Shaking}, which advances a single process from one instruction to another. Shaking a set of processes succeeds when \emph{any} of the processes in the set can advance.

\item \emph{Feeding}, which manages communication between separate processes in the network. Feeding alternates between Injecting and Shaking. When a process pushes a value to an output channel we attempt to inject this value into all processes that have that same channel as an input. If they all accept it then we then advance their programs as far as they will go, which may cause more values to be pushed to output channels, and so on.

\end{enumerate}

Evaluation of a process network is non-deterministic. At any moment several processes may be able to take a step, while others are blocked trying to pull or push to their channels. However, because each process itself is deterministic, and uses blocking reads, the sequence of values pushed to each stream is deterministic, as per Kahn process networks. 

Importantly, it is the order in which values are \emph{pushed to each particular output channel} which is deterministic, whereas the order in which different processes execute their instructions, is not. When we fuse two processes together we exploit this fact by choosing one particular instruction ordering that enables the process network to advance without requiring unbounded buffering.

Each output channel may be pushed to by a single process only, so in a sense each output channel is ``owned'' by a single process. The only intra-process communication is via channels and streams. Our model is ``pure data flow'' (or perhaps ``functional data flow'') as there are no side-channels between the processes. This is in contrast to systems such as StreamIt~\cite{thies2002streamit}, where the processes are also able to send asynchronous messages to each other, in addition to the formal input and output streams.


% -----------------------------------------------------------------------------
\eject{}
\subsubsection{Injection}
Fig.~\ref{fig:Process:Eval:Inject} gives the rules for injecting values into processes. The judgment form $\ProcInject{p}{v}{c}{p'}$ reads ``given process $p$, injecting value $v$ into channel $c$ yields a new process $p'$''. The @injects@ form is similar, but for sets of processes rather than a single one.


Rule (InjectValue) handles the injection of a single value into a single process. 

% Injection is used by the other parts of evaluation to \emph{inject} stream values into a process' input buffer.

A process has a single element buffer for each input, stored in its input state.
This can be either @none@, in which case the buffer is empty and a value may be injected; @pending@, where a single value has been injected to the buffer but has not been pulled yet; or @have@, where a value has already been injected and is currently being used.

% Injection is only possible when the process' input buffer is empty, or the process ignores that stream. Injection for a process network proceeds by injecting the same value into all processes in the network.


Rule (InjectValue) allows a value to be injected only when the input state is @none@, meaning the buffer is empty.
An attempt to inject a value while the buffer is @pending@ or @have@ would require an unbounded, or at least multiple element, buffer.
We use the syntax ($\HeapUpdateOne{@ins@~p}{c}{@pending@~v}$) to perform a map update, in this case removing the ($c=@none@$) from ($@ins@~p$) and then inserting ($c=@pending@~v$).
This sets the input buffer as pending, meaning that any future attempts to inject to this channel will fail, until the process pulls and then drops the value.

Rule (InjectIgnore) allows processes that do not use a particular input stream to ignore an injected input.

Rule (ProcessesInject) performs injection over a process network.
Every process in the network must have the value injected into it.
This means if multiple processes read from that stream, all input buffers for that stream must be empty.

% Injecting requires the input buffer to be empty or the process to ignore that channel.
For networks, all processes must successfully inject the value.


% -----------------------------------------------------------------------------
\subsubsection{Shaking}
Fig.~\ref{fig:Process:Eval:Shake} defines the judgment forms and rules for shaking a process, allowing it to take a step, and produce an output message.
% I don't like them, but alpha and tau are standard names in process calculi. 
The type of messages is denoted by $\alpha$, which can either be ($\Push~\Chan~\Value$) for pushing a value to a particular channel, or $\tau$ for an `internal' message which only performs local state updates.


The judgment form for shaking a single instruction $\ProcBlockShake{x}{i}{\Sigma}{\alpha}{l'}{i'}{u'}$
executes an instruction $x$ with the input states $i$ and the heap $\Sigma$.
The result contains an output message $\alpha$, as well as the new label $l'$, the new input state $i'$, and the update substitution to apply to the heap $u'$.

Rule (Pull) takes an already injected value from the input buffer, which changes its state from @pending@ to @have@.
The result substitution sets the variable to the pulled value, as well as any substitutions in the \Next~ of the instruction.

Rule (Drop) changes the input buffer state from @have@ to @none@. A drop can only be executed after pull has set the input buffer to @have@.

Rule (Push) evaluates the push expression $e$ under the heap, and sends that value as output the message.

Rule (Jump) simply returns the new label and substitution.

Rules (CaseT) and (CaseF) evaluate the case expression $e$ and jump to the true or false label depending on the value.

The judgment forms for shaking processes and process networks are $\ProcShake{p}{\alpha}{p'}$ and $\ProcsShake{\sgl{p}}{\alpha}{\sgl{p'}}$.
The process shaking shakes a single instruction and updates the process.
Shaking a process network chooses a single process to shake and updates it in the network.
If shaking the process resulted in an output value, that value is injected into all the other processes in the network.

Rule (Shake) takes a single process and shakes its instruction.
The judgment ($\ExpEval{@heap@~p}{u}{\Sigma}$) evaluates all the expressions in the update substitution $u$, under the process heap ($@heap@~p$).
The process steps to the new label with the new input state, and the values are updated in the heap.

Rule (ProcessesInternal) allows the process network to shake, when one of the processes inside it produces an internal message ($\tau$).

Rule (ProcessesInternal) allows the process network to shake, when one of the processes inside it produces a push message.
The emitted push message is then injected into all other processes in the network, meaning they must either ignore the channel or be ready to receive it in their buffer.
If the process tries to emit a push message but it cannot be injected into all other processes, the push fails and another process will be tried.
The entire network then emits the same message.


% -----------------------------------------------------------------------------
\subsubsection{Feeding}
Fig.~\ref{fig:Process:Eval:Feed} defines the judgment forms and rules for feeding, where external input values are fed into a process network and output values are accumulated.
The judgment form for feeding is $\ProcsFeed{\ti{inputs}}{\ti{network}}{\ti{streams}}{\ti{network}'}$.
The input map $\ti{inputs}$ contains values for the network inputs: network outputs are not allowed, but ignored channels can have values.
The result $\ti{streams}$ contains the original inputs as well as accumulated output values.
Feeding evaluates the process network until all input values have been injected.

% Note that the result stream and network are not canonical, as an infinite @push@ loop has an infinite number of evaluations.
% The feed form does not ensure that the processes themselves have finished evaluating, only that all input values have been injected.

Rule (FeedStart) applies when all input values have been injected and there are no input values left.
In this case, the output values are the same as the input values.

Rule (FeedInternal) allows the process network to take an internal step.
It first feeds its input accumulator and process network, then allows the resulting network to take an internal step.

Rule (FeedPush) allows the process network to emit a push message.
As with (FeedInternal), it first feeds its input accumulator, then allows the resulting network to emit a push message.
The pushed value is collected in the accumulator list for that stream.

Rule (FeedExternal) allows inputs to be injected into the process network.
For any channel $c$ which is not an output of one of the processes, we take the last value off its list.
The recursive feed is evaluated with the last value removed from the accumulators.
The last value is then injected into the network, and added back to the result accumulators.



% -- cuts ---------------------------------------------------------------------
% BL: Discuss this during def of evaluation.

% These input states are used for evaluation to ensure that communication between processes does not require unbounded buffers.

% Claim "functional dataflow" or some such. Each process only updates values in its local heap, the only intra-process communication is via streams. This is unlike StreamIt which can send out-of-band messages between its processes.

% The output streams are in some sense ``owned'' by the process that produces them: while a stream may be consumed by any number of processes, each stream can only appear as the output for one process. This ensures a sort of determinism in the scheduling of multiple processes; if different processes could push to the same stream, the order of values would depend on the scheduled order. A process may, however, produce multiple output streams.

% Each process has its own private heap, therefore the only communication between processes occurs by streams.

% The instructions (@instrs@) are a mapping from label to instruction, and label points to the current instruction. Instructions can pull from a channel, drop an already pulled value, push a value, perform an if/case analysis on a boolean, or perform an internal jump.


% After values have been pulled, they must be disposed of with @drop@: this empties the value from the buffer and allows the producer to push to the channel.

% A process network is a set of multiple processes that can be evaluated concurrently. Any inputs that are not produced as outputs of processes are assumed to be external inputs --- their values will be provided by the environment. Processes form the essence of stream computation, and a single process can be given a straightforward sequential semantics by mapping to an imperative language. By fusing multiple processes into a single one, we are effectively giving a sequential interpretation for concurrent processes.


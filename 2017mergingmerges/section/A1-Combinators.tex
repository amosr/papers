%!TEX root = ../Main.tex
\appendix
\section{Combinators}
\label{s:Combinators}

Here we show the definitions of some combinators.
We start with simple combinators supported by most streaming systems, and progress to more interesting combinators.
Some combinators such as @fold@, @take@ and @append@ are missing due to the infinite nature of our streams, but can be implemented in our finite stream extension described in~\S\ref{s:Finite}.
The fact that segmented versions of these combinators can be implemented is compelling evidence of this.

\subsection{Standard combinators}

\paragraph{Map} is one of the simplest combinators, and is supported almost everywhere.

\begin{code}
map f = process
     ins: as
    outs: bs
    heap: {a}
   label: p0
  blocks: p0 = pull as    a  p1
          p1 = push bs (f a) p2
          p2 = drop as       p0
\end{code}

\paragraph{Filter} is another ubiquitous combinator.

\begin{code}
filter f = process
     ins: as
    outs: bs
    heap: {a}
   label: p0
  blocks: p0 = pull as    a  p1
          p1 = case    (f a) p2 p3
          p2 = push bs    a  p2
          p3 = drop as       p0
\end{code}

\paragraph{Partition} is an interesting combinator since it produces two output streams at once.
The two output streams have different rates.
This sort of splitting is unsupported in pull fusion systems.

\begin{code}
partition f = process
     ins: as
    outs: ts fs
    heap: {a}
   label: p0
  blocks: p0 = pull as    a  p1
          p1 = case    (f a) pT pF
          pT = push ts    a  p3
          pF = push fs    a  p3
          p3 = drop as       p0
\end{code}

\paragraph{Zip} takes two streams and combines them into one.
It is fairly ubiquitous in pull fusion systems, but cannot be supported by push systems.

\begin{code}
zip = process
     ins: as bs
    outs: abs
    heap: {a, b}
   label: p0
  blocks: p0 = pull as    a   p1
          p1 = pull bs    b   p2
          p2 = push abs (a,b) p3
          p3 = drop as        p4
          p4 = drop bs        p0
\end{code}

\paragraph{Scan} performs a prefix sum over an input stream, much like a fold that returns every intermediate value.
For simplicity we are performing just prefix sums, rather than arbitrary scans, but this is easy to generalise.
Here we use two values in the heap; @a@ stores the last seen input and @s@ stores the current sum.
We initialise @s@ to 0 at the start.
Note that this prefix scan includes the seed value 0 in the output; updating the current sum to include the last pulled value happens after the push.

\begin{code}
scan = process
     ins: as
    outs: bs
    heap: {a, s = 0}
   label: p0
  blocks: p0 = pull as a  p1
          p1 = push bs s  p2[s = s + a]
          p2 = drop as    p0
\end{code}


\paragraph{Unfold} creates a new stream from a seed and an iteration function.
The seed has type @s@, the iteration has type @s -> (a,s)@ and the output stream contains @a@s.
This process has only one state which pushes the output, calls the iteration function, and updates the state.
The state/heap is initialised to the first result of the iteration function.

\begin{code}
unfold z f = process
     ins: 
    outs: as
    heap: {s = f z}
   label: p0
  blocks: p0 = push as (fst s) p0[s = f (snd s)]
\end{code}

\paragraph{Group} removes filters out consecutive duplicates from a stream.
If the stream is sorted, the output will contain only the unique entries in the stream.

\begin{code}
group = process
     ins: as
    outs: bs
    heap: {last, val}
   label: I0
  blocks: I0 = pull as val I1
          I1 = push bs val I2[last = val]
          I2 = drop as     R0

          R0 = pull as val R1
          R1 = case (last /= val) R2 R3
          R2 = push bs val R3[last = val]
          R3 = drop as     R0
\end{code}

\paragraph{Merge} takes two sorted inputs and produces a sorted input containing both inputs.
It is the main worker in merge sort.
Merge is a particularly interesting combinator since the access patterns are data dependent; that is, which order it pulls from inputs depends on the values of the inputs.
This is the infinite version of merge; the finite version would have a separate `fixup' stage where after one input has finished, it copies the rest of the other input.

\begin{code}
merge = process
     ins: as bs
    outs: abs
    heap: {a, b}
   label: I0
  blocks: I0 = pull as a  I1
          I1 = pull bs b  C0
          C0 = case (a < b) A0 B0

          A0 = push abs a A1
          A1 = drop as    A2
          A2 = pull as  a C0

          B0 = push abs b B1
          B1 = drop bs    B2
          B2 = pull bs  b C0
\end{code}

\subsection{Segmented combinators}

\paragraph{Segmented fold}
takes two input streams; one for the segment lengths, one for the values.
The output stream has the same rate as the segment lengths.

\begin{code}
folds k z = process
     ins: lens vals
    outs: outs
    heap: {count, state, val}
   label: init0
  blocks: init0 = pull lens count go0[state = z]
          go0   = case (count > 0) go1 done0
          go1   = pull vals val    go2
          go2   = jump go0[count = count - 1, state = k state val]
          done0 = push outs state init0
\end{code}


\paragraph{Segmented take}
takes two input streams; the segment descriptor lengths, as well as the underlying values.
It outputs another two streams for the output segment descriptor and values.
The number of elements to take is constant across all segments.

\begin{code}
takes n = process
     ins: lens vals
    outs: olens ovals
    heap: {count, takecount, ix, val}
   label: init0
  blocks: init0 = pull lens count lens0
          lens0 = jump lens1
                [ ix = 0
                , takecount = min count n ]
          lens1 = push olens takecount take0
          take0 = case (ix < takecount) take1 drop0
          take1 = pull vals val take2
          take2 = push ovals val take0[ix = ix + 1]
          drop0 = case (ix < count) drop1 init0
          drop1 = pull vals val drop0[ix = ix + 1]
\end{code}

\paragraph{Segmented append} is very similar to merge.

\begin{code}
apps = process
     ins: Alens Avals Blens Bvals
    outs: olens ovals
    heap: {Alen, Blen, val}
   label: init0
  blocks: init0 = pull Alens Alen init1
          init1 = pull Blens Blen init2
          init2 = push olens  (Alen + Blen) copyA0
          copyA0 = case (Alen > 0) copyA1 copyB0
          copyA1 = pull Avals val copyA2
          copyA2 = push ovals val copyA0[Alen = Alen - 1]
          copyB0 = case (Blen > 0) copyB1 init0
          copyB1 = pull Bvals val copyB2
          copyB2 = push ovals val copyB0[Blen = Blen - 1]
\end{code}


\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}
% To anonymise:
% \documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate,anonymous]{lipics-v2021}

% \pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

\bibliographystyle{plainurl}

% is this package necessary?
\usepackage{mathtools}

\usepackage{style/utils}
\usepackage{style/code}
\usepackage{style/proof}
\usepackage{style/keywords}
\usepackage{style/judgements}


\title{Pipit on the Post: Proving Pre- and Post-conditions of Reactive Systems}


\author{Amos Robinson}{Australian National University, Canberra, Australia}{amos.robinson@anu.edu.au}{https://orcid.org/0009-0004-4837-4981}{}

\author{Alex Potanin}{Australian National University, Canberra, Australia}{alex.potanin@anu.edu.au}{https://orcid.org/0000-0002-4242-2725}{}

\authorrunning{A. Robinson and A. Potanin}
\Copyright{Amos Robinson and Alex Potanin}
% \ccsdesc[300]{Computer systems organization~Embedded software}
\ccsdesc[500]{Computer systems organization~Real-time languages}
\ccsdesc[500]{Theory of computation~Program verification}
% \ccsdesc[100]{Theory of computation~Modal and temporal logics}
\ccsdesc[500]{Software and its engineering~Specialized application languages}
\keywords{Lustre, streaming, reactive, verification}

% \category{}

\begin{document}

\maketitle

\begin{abstract}
  Reactive languages such as Lustre and Scade are used to implement safety-critical control systems; proving such programs correct and having the proved properties apply to the compiled code is therefore equally critical.
  We introduce Pipit, a small reactive language embedded in \fstar{}, designed for verifying control systems and executing them in real-time.
  Pipit includes a verified translation to transition systems; by reusing \fstar{}'s existing proof automation, certain safety properties can be automatically proved by k-induction on the transition system.
  Pipit can also generate imperative code in a subset of \fstar{} which is suitable for compilation and real-time execution on embedded devices.
  This translation to imperative code preserves types by construction; the proof that the imperative code preserves semantics is ongoing.
\end{abstract}


% enable @verbatim@ syntax
\makeatactive

\input{section/01-Introduction.tex}


% \section{Pipit in flight}
% \pagebreak
\section{Programming and verifying in Pipit}
\label{s:tut}

A common requirement in controllers is to filter an input signal, perhaps using a \emph{finite impulse response} (FIR) filter, which is equivalent to a weighted moving average.
An FIR filter takes a vector of coefficients and an input signal; at every point in time, it computes the dot product of the coefficients and the most recent values of the signal.
We can implement an FIR filter in Pipit as follows:

\newcommand\signal{\textit{signal}}
\begin{tabbing}
  @MM@\= @MMMMMM@ \= \kill
  @let@ fir ($\textit{coefficients}$: list $\RR$) ($\signal$: stream $\RR$): stream $\RR$ = \\
    \> @match@ $\textit{coefficients}$ @with@ \\
    \> @|@ $[]$ \> $\to 0$ \\
    \> @|@ $c :: \cs $ \> $\to (\signal \cdot c) + (\xfby{0}{(\mbox{fir~} \cs~\signal)})$
\end{tabbing}

% Our FIR filter takes two arguments, one describing the coefficients and one describing the signal to filter.
The coefficient vector is represented by a list of reals, while the signal is a \emph{stream} of reals, and the result is the filtered stream.
% \footnote{The actual implementation uses integers with fixed-point arithmetic, but we use reals here to reduce clutter.}
The implementation starts by looking at the list of coefficients and returns zero if the list is empty.
If the list is not empty, then we multiply the most recent value of the stream by the coefficient ($\signal \cdot c$); we also take the result of applying the remaining coefficients to the signal stream ($\mbox{fir~} \cs ~ \signal$) and delay it ($\xfby{0}{\ldots}$) before summing the two parts.
At the start of execution the delay is initially zero.

Pipit is an \emph{embedded} language, like Bedrock~\cite{chlipala2013bedrock}: in this example, the stream type denotes an actual Pipit expression, while the list type and its associated pattern match are part of the \fstar{} meta-language.
To get the real Pipit program, we need to apply the filter to a concrete list of coefficients:

\newcommand\bibo{\mbox{bibo}}
\newcommand\fir{\mbox{fir}}
\newcommand\ii{\textit{input}}
\newcommand\oo{\textit{output}}
\newcommand\ok{\textit{ok}}
\begin{tabbing}
  @MM@\= @MMMMMM@ \= \kill
  @let@ $\mbox{fir}_2$ ($\ii$: stream $\RR$): stream $\RR$ = \\
    \> $\mbox{fir}~[0.7; 0.3] \ii$
\end{tabbing}

Normalising this definition evaluates away all of the lists.
The result fits in the core language defined in \autoref{s:core}, for which we can generate real-time imperative code:

\begin{tabbing}
    @MM@\= @MMMMMM@ \= \kill
      @let@ $\mbox{fir}_2$ ($\ii$: stream $\RR$): stream $\RR$ = \\
    \> $(0.7 \cdot \ii) + (\xfby{0}{((0.3 \cdot \ii) + (\xfby{0}{0}))})$
\end{tabbing}

The properties that we want to state about reactive programs usually involve some temporal aspect.
Rather than defining a separate specification language, we implement computable variants of temporal operators from \emph{past-time} linear temporal logic \cite{halbwachs1993executable,lichtenstein1985glory}.
We name the past-globally operator \emph{sofar}, as in \emph{the predicate has been true so far}:

\begin{tabbing}
  @MM@\= @MMMMMM@ \= \kill
  @let@ sofar ($p$: stream $\BB$): stream $\BB$ = \\
    \> $\xrec{p'}{p \wedge (\xfby{@true@}{p'})}$
\end{tabbing}

This definition takes a stream of predicates $p$ and introduces a recursive stream $p'$.
At each step, the recursive stream $p'$ checks that the current predicate is true ($p$), and also checks that \emph{sofar} was previously true ($\xfby{@true@}{p'}$).
If there is no previous value, it defaults to true.

\subsection{Bounded input, bounded output}
\label{ss:tut:bibo}
We can now state a \emph{bounded-input-bounded-output} (BIBO) property, which says that if the inputs have always been within some particular range, then the outputs are also within the range:
% Properties like this can occur as an internal invariant in a larger system:

\begin{tabbing}
  @MM@\= @LET OUTPUT@\= @EXAMPLE1 INPUT@ \= \kill
  @let@ $\mbox{bibo}_2$ (n: $\RRgez$) ($\ii$: stream $\RR$): stream $\BB$ = \\
  \> @check@ $(\mbox{sofar}(|\ii| \le n) \implies |\mbox{fir}_2~\ii| \le n)$
\end{tabbing}

This property states that if the input has always been in the range $[-n, n]$, then the output is also within the range $[-n, n]$.
Note that the upper bound $n$ is a nonnegative real rather than a stream of reals, which means that $n$ stays constant across the whole stream.
To prove that this property holds, we translate to a transition system and show that the stream is always true.
In this case, induction over the transition relation is sufficient to prove the property.
There is some boilerplate required to perform the induction, but both base and step cases are automatically proved by \fstar{}:

\begin{tabbing}
  @MM@\= @MMMMMMMMMMMMMMMMMMMMMMM@ \= \kill
  @let@ $\mbox{proof}_2$ (n: $\RRgez$): Lemma (induct ($\bibo_2$ n)) = \\
  \> @assert@ (base\_case ($\bibo_2 ~n$)) \> @by@ (pipit\_simplify ()); \\
  \> @assert@ (step\_case ($\bibo_2 ~n$)) \> @by@ (pipit\_simplify ())
\end{tabbing}

This definition uses \fstar{}'s \emph{lemma} syntax to state that the BIBO property holds inductively for any $n$.
The two assertions prove the inductive cases separately, using our \emph{simplify} tactic to ensure that the translation to transition system is normalised away, and any translation artefacts are removed.

If we wish to prove a similar BIBO property for a filter with more coefficients, standard induction over the transition system is not sufficient: the relationship between the stacked delays in the filter and sofar is not clear from a single step of the transition system.
One simple automated way to strengthen invariants is via \emph{k-induction}~\cite{hagen2008scaling}, which adds more context by assuming that the property holds for $k$ previous steps of the transition relation.
We can define analogous functions $\fir_3$ and $\bibo_3$ which operate on the coefficients $[0.7; 0.2; 0.1]$, and use k-induction for $k = 2$ as follows:

\begin{tabbing}
  @MM@\= @MMMMMMMMMMMMMMMMMMMMMMMMMMM@ \= \kill
  @let@ $\mbox{proof}_3$ (n: $\RRgez$): Lemma (induct\_k 2 ($\bibo_3$ n)) = \\
  \> @assert@ (base\_case\_k 2 ($\bibo_3 ~n$)) \> @by@ (pipit\_simplify ()); \\
  \> @assert@ (step\_case\_k 2 ($\bibo_3 ~n$)) \> @by@ (pipit\_simplify ())
\end{tabbing}

Although the properties here boil down to simple properties about linear arithmetic, we believe that this example demonstrates a promising way to use \fstar{}'s existing proof automation to verify reactive systems.

% \pagebreak
\section{Core language}
\label{s:core}

\input{figures/core-grammar.tex}
\input{figures/core-typing.tex}
\input{figures/core-bigstep.tex}

The grammar of Pipit is defined in \autoref{f:core-grammar}.
The expression form $e$ includes standard syntax for values ($v$), variables ($x$) and applications ($e~e'$); however, it does not include any form for defining functions except reusing closed functions from the \fstar{} meta-language $(\mlamX{})$.
Most of the expression forms were introduced informally in \autoref{s:tut} and correspond to the clock-free primitives in Lustre \cite{caspi1995functional}.
% The expression syntax for delayed streams ($\xfby{v}{e}$) denotes the previous value of the stream $e$, with an initial value of $v$ when there is no previous value.
Streams can also be composed together using the \emph{then} notation ($\xthen{e}{e'}$) which denotes that the value of stream $e$ is used for the first step, followed by the values from stream $e'$ for subsequent steps.

Recursive streams, which can refer to previous values of the stream itself, are defined using the fixpoint operator ($\xrec{x}{e[x]}$); the syntax $e[x]$ means that the variable $x$ can occur in $e$.
% To ensure that streams are productive,
As in Lustre, recursive streams can only refer to their previous values and must be \emph{guarded} by a delay: the stream $(\xrec{x}{\xfby{0}{(x + 1)}})$ is well-defined, but stream $(\xrec{x}{x + 1})$ is invalid and has no computational interpretation.
This form of recursion differs slightly from standard Lustre, which uses a set of mutually-recursive bindings.
We use this form to define a substitution-based operational semantics that is syntax-directed, as opposed to the mutually-recursive form in \cite{caspi1995functional} which is not syntax-directed.
Our semantics has a simpler proof of determinism; we believe it has simplified other necessary proofs too and will perform further evaluation.
Although we cannot express mutually-recursive bindings in the core syntax here, we can express them as a notation on the surface syntax at the expense of potentially duplicating expressions.


\section{Extraction}
\label{s:extraction}

Pipit can generate executable code which is suitable for real-time execution on embedded devices.
The code extraction is implemented in a currently-unverified transform that takes a deeply embedded representation of a Pipit expression and generates a shallow imperative representation of the program.
\fstar{} can generate C code from a subset of the language called \lowstar{}~\cite{protzenko2017verified}; the result of our translation to imperative code fits in this subset.
During code extraction, we use \fstar{}'s tactic support~\cite{martinez2019meta} to fully normalise the translation to imperative code, conceptually similar to staged compilation.

% For the simple examples in \autoref{ss:tut:bibo}, we probably could have proved the properties directly on the generated code.
% In the future, however, we intend to support the abstraction of streams through \emph{contracts}, which require a relational semantics rather than a functional one.

% noextract
% let expr = Sugar.run2 Pump.controller'

% noextract
% let system: Pipit.Exec.Exp.xexec expr =
%   XX.exec_of_exp expr

% [@@(Tac.postprocess_with XL.tac_extract)]
% let reset = XL.mk_reset system

% [@@(Tac.postprocess_with XL.tac_extract)]
% let step (inp: input) = XL.mk_step system (inp.estop, (inp.level_low, ()))
% This allows us to generate C code which executes in bounded space on embedded devices.

\section{Evaluation}
\label{s:coffee-machine}

To demonstrate the feasibility of Pipit, we have implemented and verified a simple controller.
This system controls a water-flow solenoid to fill the reservoir of a coffee machine and includes multiple safeguards to reduce the risk of flooding.
The controller has two boolean inputs: the \emph{stop} switch and the \emph{low level} indicator; it returns a boolean indicating whether to engage the solenoid.
The stop switch indicates whether the reservoir's lid is open or closed; the system should never operate while the lid is open as water could spill out.
The controller should not allow water to flow for more than a minute as this may indicate a leak; if so, the controller enters a terminal error state.
Finally, to avoid switching the solenoid too often, the controller waits for ten seconds of low water level before trying to engage:

\newcommand\estop{\textit{stop}}
\newcommand\low{\textit{low}}
\newcommand\soltry{\textit{try}}
\newcommand\error{\textit{error}}
\newcommand\solen{\textit{engage}}
\begin{tabbing}
  @MM@\= @let@ engage \= @MMMM@ \= \kill
  @let@ $\mbox{reservoir}$ (\estop{} \low{}: stream $\BB$): stream $\BB$ = \\
  \> @let@ \soltry{} \> = true\_for \textit{TEN\_SECONDS} (not \estop{} $\wedge$ \low{}) @in@ \\
  \> @let@ \error{} \> = any (true\_for \textit{ONE\_MINUTE} \soltry{}) @in@ \\
  \> @let@ \solen{} \> = \soltry{} $\wedge$ not \error{} @in@ \\
  \> @check@ (\solen{} $\implies$ not \estop{}); \\
  \> @check@ (\solen{} $\implies$ \low{}); \\
  \> \solen{}
\end{tabbing}
\pagebreak

Predicate \emph{true\_for t} is true if a signal has been true for time $t$; \emph{any} is true if a signal has ever been true.
% The \emph{true\_for t} is time-bounded past-globally and \emph{any} is past-finally.
As with the previous examples, the two properties can be automatically verified.
% by \fstar{}'s proof automation.
Pipit generates real-time C code for this example\footnote{For a video of the controller in action, see \url{https://youtu.be/6IybbQFPOl8}}.

\section{Related work}
\label{s:related-work}
% TODO arrays

Although the FIR filter from \autoref{s:tut} is quite simple, verifying it \emph{and} executing it with existing Lustre tools is nontrivial.
Lustre itself does not support lists, as dynamically-allocated data structures are not well-suited to real-time execution.
To write this filter in Lustre we would either need to unroll the lists ourselves or reformulate the program to use arrays.
However, Vélus does not support arrays~\cite{bourke2017formally}; Kind2 uses a custom syntax for arrays with no compiler support~\cite{champion2016kind2}; and the Lustre V6 compiler does support arrays~\cite{jahier2016lustre}, but its model-checker Lesar cannot reason about integers or reals~\cite{raymond2008synchronous}.

In terms of model-checking reactive systems,
% earlier model-checkers used explicit state-space exploration~\cite{raymond2008synchronous};
recent work uses SMT solvers to check inductive proofs~\cite{hagen2008scaling,champion2016kind2} or to check refinement types~\cite{chen2022synchronous}.
These model-checkers have definite advantages over the general-purpose-prover approach offered here: they can often generate concrete counterexamples and implement counterexample-based invariant-generation techniques such as ICE~\cite{garg2014ice} and PDR~\cite{bradley2011sat,een2011efficient}.
However, these model-checkers do not provide much assurance that the semantics they use for proofs matches the compiled code.
We believe that once Pipit's imperative code generation is verified, Pipit will have a stronger assurance case.

The embedded language Copilot generates real-time C code for runtime monitoring and supports model-checking properties \cite{laurent2015assuring}, but suffers from the same semantic gap.

Early work embedding a denotational semantics of Lucid Synchrone in an interactive theorem prover focussed on the semantics itself, rather than proving programs~\cite{boulme2001clocked}.
There is ongoing work to construct a denotational semantics of Vélus for program verification~\cite{bourke2022towards}.
We believe that the hybrid SMT approach of \fstar{} will allow for a better mixture of automated proofs with manual proofs;
however, the trusted computing base of Pipit is much larger than Vélus, as we depend on all of \fstar{}, \lowstar{}'s C code extraction, the SMT solver, as well as our currently-unverified imperative code generator.

% Refinement types have also been used to verify reactive systems~\cite{chen2022synchronous}, but this work does not address the issue of correct compilation.

% cite also:
% hardware language in Agda \cite{harrison2021mechanized}
% Refinement types for Zélus \cite{chen2022synchronous}
% Invariant generation: ICE \cite{garg2014ice}; template-based \cite{kahsai2011instantiation}; PDR explanation \cite{een2011efficient}; IC3 first introduced \cite{bradley2011sat}

% Other compilers for Lustre-style languages, such as Vélus \cite{bourke2017formally} and Heptagon \cite{gerard2012modular} ensure that the generated code can be executed in bounded memory and that each step takes a bounded time.
% With a carefully chosen set of primitives, the core streaming operations shown here would ensure bounded memory and time.
% For practicality, however, we currently allow embedding arbitrary total functions from the \fstar{} meta-language, which are not necessarily bounded in time.
% (Is this the same as Lucid Synchrone and Zélus? \CITE)

\section{Conclusion}

Our preliminary results show that \fstar{}'s proof automation and code extraction are suitable for verifying reactive systems and executing them in real-time; these results still require further work.
Next, we intend to verify the imperative code generation.
To verify large programs, we also need some way to separately prove smaller pieces which can then be composed together, such as contracts~\cite{champion2016kind2}.
Finally, we need to evaluate Pipit on larger control systems before extending the language to support more features, such as Lustre's clocks for describing partially-defined streams~\cite{caspi1995functional}.

% TODO
% Future work: verify imperative code generation; verify CSE; case studies: antilock braking; clocks \cite{caspi1995functional}; contracts \cite{champion2016kind2}.

\bibliography{Main}


% \appendix

\end{document}
\endinput

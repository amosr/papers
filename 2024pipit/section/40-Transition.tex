%!TEX root = ../Main.tex

\section{Abstract transition systems}
\label{s:transition}
\input{figures/system-types.tex}

To prove properties about Pipit programs, we translate to an \emph{abstract} transition system, so-called because it abstracts away the implementation details of contract instantiations.
For extraction we also translate to \emph{executable} transition systems, which we discuss in \autoref{s:extraction}.

\autoref{f:system-types} shows the types of transition systems.
A transition system is parameterised by its input context and the result type.
It also contains two internal contexts: firstly, the state context describes the private state required to execute the machine; secondly, the free context contains any extra input values that the transition system would like to quantify over.
The free context is used to allow the system to ask for arbitrary values from the environment, when it would not otherwise be able to return a concrete value.

For contract instantiations, which abstract over the implementation, the natural translation to a transition system would involve an existential quantifier: there exists some value that satisfies the specification.
Unfortunately, such an existential quantifier requires a step \emph{relation} rather than a step \emph{function}.
Using a step relation complicates the resulting transition system, as other operations such as primitive application must also introduce existential quantifiers; such quantifiers block normalisation and result in a more complex transition system.
Instead, the free context provides the step function with a fresh unconstrained value of the desired type, which the step function can then constrain.

As usual, the step-result contains the updated state for the transition system, as well as the result value.
The step-result additionally contains two propositions for the `rely', or assumptions about the execution environment, and `guarantee', or obligations that the transition system must show.
For the transition system corresponding to an expression $e$, these propositions are analogous to the known checked semantics $\semcheck{\Sigma}{\PSValid}{e}$ and unknown checks $\semcheck{\Sigma}{\PSUnknown}{e}$ respectively.

Our implementation includes a mechanised proof that, for causal expressions, the transition system is an abstraction of the original expression's dynamic semantics.
The proof that the rely and guarantee propositions correspond to the checked semantics is future work.

% There is a slight difference with how followed-by delays are handled --- the checked semantics checks the delayed expression in the delayed context, while the transition system checks one step ahead --- 

% The free context is used to generate similar systems to the transition systems generated by existing systems such as Kind2 \cite{champion2016kind2}, which can generate fresh variables at will.
% The main distinction is that embedding such a translation inside a theorem prover and proving it correct requires some ingenuity.

\input{figures/system-translation.tex}

\autoref{f:system-translation-contexts} defines the internal state and free contexts required for an expression.
For most expression forms, the state and free contexts are defined by taking the union of the contexts of subexpressions.
Followed-by delays introduce a local state variable $x_{@fby@}$ in which to store the most recent stream value.
We generate a fresh variable here, though the implementation uses de Bruijn indices.
Recursive streams and contracts both introduce new bindings into the free context, assuming that their binders $x$ are unique.

\autoref{f:system-translation} defines the translation for expressions.
Values and expressions have no internal state.
For variables, we look for the variable binding in either of the input or free heaps; bindings are unique and cannot occur in both.
We omit the rely and guarantee definitions here; both are trivially true.

To translate primitives, we union together the initial states of the subexpressions; updating the state is similar.
For the rely and guarantee definitions, we take the conjunction: we can assume that all subexpressions rely clauses hold, and must show that all guarantees hold.

To translate a followed-by $\xfby{v}{e}$, we initialise the follow-by's unique binder $x_{@fby@}$ to $v$.
At each step, we return the value in the local state, before updating the local state to the subexpression's new value.
The rely and guarantee differ from the checked semantics here: in the checked semantics, we check the subexpression on the previous inputs, but here we check the current subexpression.
This means that a single step of the rely and guarantee do not exactly correspond to the checked semantics; however, we posit that they are equivalent for a rely and guarantee that has been proven to hold for any sequence of inputs.

To translate a recursive expression $\xrec{x}{e}$ of type $\tau$, we require an arbitrary value $x: \tau$ in the free heap.
The rely proposition constrains the free variable $x$ to be the result of evaluating $e$ with the binding for $x$ passed along, thus closing the recursive loop.

To translate let-expressions $\xlet{x}{e}{e'}$, we extend the input heap with the value of $e$ before evaluating $e'$.
The presentation here duplicates the computation of the value of $e$, but this is not an issue in practice.

To translate a check property, we inspect the property status.
If the property is known to be valid, then we can assume the property is true in the rely clause.
Otherwise, we include the property as an obligation in the guarantee clause.
In either case, we also include the subexpression's rely and guarantee clauses.

Finally, to translate contract instantiations, we use the contract's rely and guarantee and ignore the body.
As with recursive expressions, we require an arbitrary value $x: \tau$ in the free heap.
The translation's rely allows us to assume that the contract definition holds: that is, the contract's rely implies the contract's guarantee.
If the contract instantiation is known to be valid, we can also assume that the contract's rely holds.
Otherwise, we include the contract's rely as an obligation by putting it in the translation's guarantee.

In the contract instantiation, we assume that if the contract rely is true \emph{at the current step}, then the contract guarantee also holds at the current step.
The true semantics of the contract, however, only holds if the contract rely is true \emph{at every step so far}.
This simplification is justified as our definition of validity for a transition system also requires the translation rely to be true at every step.
This simplification is essentially an application of the $\Box \Box p \implies \Box p$ axiom of modal logic.
The mechanised proof of this simplification is future work.

\subsection{Translation correctness proofs}
\label{s:transition:proof}

We prove that the transition system is an abstraction of the dynamic semantics: that is, if the expression evaluates to $v$ under some context, then there exists some execution of the transition system that also results in $v$.
The transition system itself is deterministic, but the free context provides the non-determinism; our theorem  statement existentially quantifies the free heap.

\input{figures/system-invariant.tex}

The results presented here rely heavily on the totality and substitution metaproperties described in \autoref{s:core:causality}.
\autoref{f:system-invariant} defines the invariant for the abstraction proof; the judgment form $\sysinv{\Sigma}{e}{s}$ checks that $s$ is a valid state heap.
We use the invariant to state that, if executing the transition system for $e$ on the entire streaming history $\Sigma$ results in state heap $s$, then $s$ is a valid state.

As most expressions do not modify the state heap, the invariant for most expressions simply descends into the subexpressions.
Where new bindings are added, we use the dynamic semantics to extend the context with the new values.
The invariant for follow-by expressions asserts that the initial state of the follow-by is the default value; on subsequent steps, the state corresponds to the dynamic semantics.

\begin{theorem}[translation-abstraction]
  For a well-typed causal expression $e$ and streaming history $\Sigma$, if $e$ evaluates to $v$ $(\bigstep{\Sigma}{e}{v})$, then there exists a sequence of free heaps $\Sigma_{F}$ such that repeated application of the transition system's step results in $v$.
\end{theorem}


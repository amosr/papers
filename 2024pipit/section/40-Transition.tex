%!TEX root = ../Main.tex

\section{Abstract transition systems}
\label{s:transition}
\input{figures/system-types.tex}

To prove properties about Pipit programs, we translate to an \emph{abstract} transition system, so-called because it abstracts away the implementation details of contract instantiations.
For extraction we also translate to \emph{executable} transition systems, which we discuss in \autoref{s:extraction}.

\autoref{f:system-types} shows the types of transition systems.
A transition system is parameterised by its input context and the result type.
It also contains two internal contexts: firstly, the state context describes the private state required to execute the machine; secondly, the free context contains any extra input values that the transition system would like to quantify over.
The free context is used to allow the system to ask for arbitrary values from the environment, when it would not otherwise be able to return a concrete value.

For contract instantiations, which abstract over the implementation, the natural translation to a transition system would involve an existential quantifier: there exists some value that satisfies the specification.
Unfortunately, such an existential quantifier requires a step \emph{relation} rather than a step \emph{function}.
Using a step relation complicates the resulting transition system, as other operations such as primitive application must also introduce existential quantifiers; such quantifiers block normalisation and result in a more complex transition system.
Instead, the free context provides the step function with a fresh unconstrained value of the desired type, which the step function can then constrain.

As usual, the step-result contains the updated state for the transition system, as well as the result value.
The step-result additionally contains two propositions for the `rely', or assumptions about the execution environment, and `guarantee', or obligations that the transition system must show.
For the transition system corresponding to an expression $e$, these propositions are analogous to the known checked semantics $\semcheck{\Sigma}{\PSValid}{e}$ and unknown checks $\semcheck{\Sigma}{\PSUnknown}{e}$ respectively.

% There is a slight difference with how followed-by delays are handled --- the checked semantics checks the delayed expression in the delayed context, while the transition system checks one step ahead --- 

% The free context is used to generate similar systems to the transition systems generated by existing systems such as Kind2 \cite{champion2016kind2}, which can generate fresh variables at will.
% The main distinction is that embedding such a translation inside a theorem prover and proving it correct requires some ingenuity.

\input{figures/system-translation.tex}

\autoref{f:system-translation-contexts} defines the internal state and free contexts required for an expression.
For most expression forms, the state and free contexts are defined by taking the union of the contexts of sub-expressions.
Followed-by delays introduce a local state variable $x$, in which to store the most recent stream value.
We generate a fresh variable here, though the implementation uses de Bruijn indices.
Recursive streams and contracts both introduce new bindings into the free context, assuming that their binders $x$ are fresh.

\TODO{describe translation}
The substitution-based semantics is better for equational reasoning, and (subjectively perhaps) simpler.
The transition system is better for certain automated proofs: a surprising number of interesting properties can be proven with k-induction alone.

\subsection{Translation correctness proofs}
\label{s:transition:proof}

\TODO{describe the proofs of translation correctness}
The translation to a transition system above is an abstraction.
We prove it.
Interesting lemmas etc.


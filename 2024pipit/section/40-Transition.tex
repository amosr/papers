%!TEX root = ../Main.tex

\section{Abstract transition systems}
\label{s:transition}
\input{figures/system-types.tex}

To prove properties about Pipit programs, we translate to an \emph{abstract} transition system, so-called because it abstracts away the implementation details of contract instantiations.
For extraction we also translate to \emph{executable} transition systems, which we discuss in \autoref{s:extraction}.

\autoref{f:system-types} shows the types of transition systems.
A transition system is parameterised by its input context and the result type.
It also contains two internal contexts: firstly, the state context describes the private state required to execute the machine; secondly, the free context contains any extra input values that the transition system would like to existentially quantify over.
The free context is used to allow the system to ask for arbitrary values from the environment, when it would not otherwise be able to return a concrete value.

For contract instantiations, which abstract over the implementation, the natural translation to a transition system would involve an existential quantifier: ``there exists some value that satisfies the specification''.
Unfortunately, such an existential quantifier requires a step \emph{relation} rather than a step \emph{function}.
Using a step relation complicates the resulting transition system, as other operations such as primitive application must also introduce existential quantifiers; such quantifiers block simplifications such as partial-evaluation and result in a more complex transition system.
Instead, the free context provides the step function with a fresh unconstrained value of the desired type, which the step function can then constrain.

Back to \autoref{f:system-types}, the step-result contains the updated state for the transition system, as well as the result value.
The step-result additionally contains two propositions for the `rely', or assumptions about the execution environment, and `guarantee', or obligations that the transition system must show.
For the transition system corresponding to an expression $e$, these propositions are analogous to the known checked semantics $\semcheck{\Sigma}{\PSValid}{e}$ and unknown checks $\semcheck{\Sigma}{\PSUnknown}{e}$ respectively.

For example, recall again the sum contract:
$$
\sumcontractX{\PSUnknown}{\textit{ints}}
$$

To verify the contract definition, we first translate it to an abstract transition system whose input environment contains an integer \emph{ints}, and whose result type is also an integer.
The followed-by delay results in a local state variable called sum_fby, and the recursive stream results in a free variable called sum.
We get the following transition system:

  \begin{tabbing}
  MM \= update: \= = \= update \= \kill
  @let@ sum_def: system (ints: $\ZZ$) $\ZZ$ = \{ \\
  \> state   \> = (sum_fby: $\ZZ$); \\
  \> free  \> = (sum: $\ZZ$); \\
  \> init  \> = \{ sum_fby = 0 \}; \\
  \> step  \> = $\lambda{} i~f~s.$ \{ \\
  \> \> \> update \> = \{ sum_fby = f.sum \}; \\
  \> \> \> value  \> = f.sum; \\
  \> \> \> rely   \> = f.sum = (s.sum_fby + i.ints) $\wedge$ i.ints > 0; \\
  \> \> \> guar   \> = f.sum > 0; \} \\
  \} \\
  \end{tabbing}

The initial state of 0 corresponds to the initial value of the followed-by.
In the step function, argument $i$ refers to the input heap containing i.ints, $f$ refers to the free heap containins f.sum, and $s$ refers to the state heap containing s.sum_fby.
The result of the recursive stream is referred to as f.sum; in the rely / assumption of the step result, f.sum is restricted to have the correct sum.
The step result's rely also includes the contract's rely, which allows proofs of system validity to assume that the input integer is positive.
Finally, the step result's guarantee includes the contract's guarantee, which ensures that the proof of system validity actually proves that the contract holds.

The translation for contract instantiations proceeds similarly, except that the contract itself is replaced by an arbitrary value in the free context.
For example, recall the Fibonacci sequence:
$
  @rec@~\fibvar.\, \text{sum}~(\xfby{1}{\fibvar})
$.

This program does not require any input values, so we leave the input context empty.
The state context includes an entry for the $\xfby{1}{\fibvar}$ followed-by expression, but does not include the followed-by expressions inside the contract definition.
Similarly, the free context includes an entry for the recursive stream, and an entry for the contract itself:

  \begin{tabbing}
  MM \= update: \= = \= update \= \kill
  @let@ fib_def: system () $\ZZ$ = \{ \\
  \> state   \> = (fib_fby: $\ZZ$); \\
  \> free  \> = (fib: $\ZZ$; sum_contract: $\ZZ$); \\
  \> init  \> = \{ fib_fby = 1 \}; \\
  \> step  \> = $\lambda{} i~f~s.$ \{ \\
  \> \> \> update \> = \{ fib_fby = f.fib \}; \\
  \> \> \> value  \> = f.fib; \\
  \> \> \> rely   \> = f.fib = f.sum_contract $\wedge$ (s.fib_fby > 0 $\implies$ f.sum_contract > 0); \\
  \> \> \> guar   \> = s.fib_fby > 0; \} \\
  \} \\
  \end{tabbing}

As before, the step result's rely includes the assumption that the recursive stream's value (f.fib) agrees with its result (f.sum_contract).
Additionally, the rely includes the assumption that the contract's rely implies the guarantee: if sum's input (s.fib_fby) is positive, then its output (f.sum_contract) is positive too.
Finally, the step result's guarantee encodes the obligation that the contract's \emph{rely} must hold -- that is, the followed-by's state variable must be positive.

\subsection{Translation}

We now describe the details of the translation before discussing the (k-)inductive proofs of system validity in \autoref{s:transition:ind}.
Our implementation includes a mechanised proof that, for causal expressions, the transition system is an abstraction of the original expression's dynamic semantics, and that the transition system's proof obligations correspond to the checked semantics.

% The free context is used to generate similar systems to the transition systems generated by existing systems such as Kind2 \cite{champion2016kind2}, which can generate fresh variables at will.
% The main distinction is that embedding such a translation inside a theorem prover and proving it correct requires some ingenuity.

\input{figures/system-translation.tex}

\autoref{f:system-translation-contexts} defines the internal state and free contexts required for an expression.
For most expression forms, the state and free contexts are defined by taking the union of the contexts of subexpressions.
Followed-by delays introduce a local state variable $x_{@fby@(e)}$ in which to store the most recent stream value.
We generate a fresh variable here, though the implementation uses de Bruijn indices.
Recursive streams and contracts both introduce new bindings into the free context; we assume that their binders $x$ are unique.

\autoref{f:system-translation} defines the translation for expressions.
Values and expressions have no internal state.
For variables, we look for the variable binding in either of the input or free heaps; bindings are unique and cannot occur in both.
We omit the rely and guarantee definitions here; both are trivially true.

To translate primitives, we union together the initial states of the subexpressions; updating the state is similar.
For the rely and guarantee definitions, we take the conjunction: we can assume that all subexpressions rely clauses hold, and must show that all guarantees hold.

To translate a followed-by $\xfby{v}{e}$, we initialise the follow-by's unique binder $x_{@fby@(e)}$ to $v$.
At each step, we return the value in the local state, before updating the local state to the subexpression's new value.

To translate a recursive expression $\xrec{x}{e}$ of type $\tau$, we require an arbitrary value $x: \tau$ in the free heap.
The rely proposition constrains the free variable $x$ to be the result of evaluating $e$ with the binding for $x$ passed along, thus closing the recursive loop.

To translate let-expressions $\xlet{x}{e}{e'}$, we extend the input heap with the value of $e$ before evaluating $e'$.
The presentation here duplicates the computation of the value of $e$, but the actual implementation introduces a single binding.

To translate a check property, we inspect the property status.
If the property is known to be valid, then we can assume the property is true in the rely clause.
Otherwise, we include the property as an obligation in the guarantee clause.
In either case, we also include the subexpression's rely and guarantee clauses.

Finally, to translate contract instantiations, we use the contract's rely and guarantee and ignore the body.
As with recursive expressions, we require an arbitrary value $x: \tau$ in the free heap.
The translation's rely allows us to assume that the contract definition holds: that is, the contract's rely implies the contract's guarantee.
If the contract instantiation is known to be valid, we can also assume that the contract's rely holds.
Otherwise, we include the contract's rely as an obligation by putting it in the translation's guarantee.

In the contract instantiation, we assume that if the contract rely is true \emph{at the current step}, then the contract guarantee also holds at the current step.
The real semantics of the contract, however, requires the contract rely to be true \emph{at every step so far}.
This difference is benign, as the inductive case of the proof of transition system validity assumes that both the rely and guarantee held at previous steps; if the rely also holds now, then it has held at every step so far.
% to prove that a transition system satisfies its guarantee, we show that if the rely is true \emph{at every step so far}, then the guarantee is also true.
% This simplification is essentially an application of the $\Box \Box p \iff \Box p$ equivalence of modal logic.
% The mechanised proof of this simplification is future work.

\subsection{Proof obligations and induction}
\label{s:transition:ind}
\TODO{add subsection describing induction and k-induction}

\TODO{describe entailment proof briefly}

\subsection{Translation correctness proofs}
\label{s:transition:proof}

We prove that the transition system is an abstraction of the dynamic semantics: that is, if the expression evaluates to $v$ under some context, then there exists some execution of the transition system that also results in $v$.
The transition system itself is deterministic, but the free context provides the non-determinism; our theorem  statement existentially quantifies the free heap.

\input{figures/system-invariant.tex}

The results presented here rely heavily on the totality and substitution metaproperties described in \autoref{s:core:causality}.
\autoref{f:system-invariant} defines the invariant for the abstraction proof; the judgment form $\sysinv{\Sigma}{e}{s}$ checks that $s$ is a valid state heap.
We use the invariant to state that, if executing the transition system for $e$ on the entire streaming history $\Sigma$ results in state heap $s$, then $s$ is a valid state.

As most expressions do not modify the state heap, the invariant for most expressions simply descends into the subexpressions.
Where new bindings are added, we use the dynamic semantics to extend the context with the new values.
The invariant for follow-by expressions asserts that the initial state of the follow-by is the default value; on subsequent steps, the state corresponds to the dynamic semantics.

\begin{theorem}[translation-abstraction]
  For a well-typed causal expression $e$ and streaming history $\Sigma$, if $e$ evaluates to stream $V$ $(\bigsteps{\Sigma}{e}{V})$, then there exists a sequence of free heaps $\Sigma_{F}$ such that repeated application of the transition system's step results in $V$.
\end{theorem}


%!TEX root = ../Main.tex

\section{Related work}
\label{s:related-work}

Using existing Lustre tools to verify \emph{and} execute the time-triggered CAN driver from \autoref{s:motivation} is nontrivial.
Compiling the triggers array with an unverified compiler such as Lustre V6~\cite{jahier2016lustre} or Heptagon~\cite{gerard2012modular} is straightforward; however, the verified Lustre compiler Vélus~\cite{bourke2023verified} does not support arrays or a foreign-function interface.

Verifying the time-triggered CAN driver is trickier, as the restrictions placed on the triggers array --- that triggers are sorted by time-mark, there must be an adequate time-gap between a trigger and its next-enabled, and a trigger's time-mark must be greater-than-or-equal-to its index --- naturally require quantifiers.
The Kind2 model-checker does include experimental array and quantifier support~\cite{kind2userdoc}, but uses a custom syntax for arrays with no compiler support.
This experimental support has some limitations: the use of arrays and quantifiers disables IC3-based invariant generation, quantified variables cannot be used in function calls, and top-level arrays are not supported~\cite{kind2024toparray}.

Other model-checkers for Lustre such as Lesar~\cite{raymond2008synchronous} and JKind~\cite{gacek2018jkind} do not support quantifiers.
It may be possible to encode the quantifiers as fixed-size loops, but ensuring that these loops do not affect the execution or runtime complexity of the generated code does not appear to be straightforward.

\TODO{Verified compilation via Frama-C} \cite{brun2023equation}

In terms of model-checking reactive systems,
% earlier model-checkers used explicit state-space exploration~\cite{raymond2008synchronous};
recent work uses SMT solvers to check inductive proofs~\cite{hagen2008scaling,champion2016kind2} or to check refinement types~\cite{chen2022synchronous}.
These model-checkers have definite advantages over the general-purpose-prover approach offered here: they can often generate concrete counterexamples and implement counterexample-based invariant-generation techniques such as ICE~\cite{garg2014ice} and PDR~\cite{bradley2011sat,een2011efficient}.
However, these model-checkers do not provide much assurance that the semantics they use for proofs matches the compiled code.
We believe that once Pipit's imperative code generation is verified, Pipit will have a stronger assurance case.

The embedded language Copilot generates real-time C code for runtime monitoring and supports model-checking properties \cite{laurent2015assuring}.
Recent work has used translation validation to show that the generated C code matches the high-level semantics~\cite{scott2023trustworthy}.
However, the model-checking suffers from the same semantic gap.

Early work embedding a denotational semantics of Lucid Synchrone in an interactive theorem prover focussed on the semantics itself, rather than proving programs~\cite{boulme2001clocked}.
There is ongoing work to construct a denotational semantics of Vélus for program verification~\cite{bourke2022towards}.
We believe that the hybrid SMT approach of \fstar{} will allow for a better mixture of automated proofs with manual proofs;
however, the trusted computing base of Pipit is much larger than Vélus, as we depend on all of \fstar{}, \lowstar{}'s C code extraction, the SMT solver, as well as our currently-unverified imperative code generator.

% Refinement types have also been used to verify reactive systems~\cite{chen2022synchronous}, but this work does not address the issue of correct compilation.

% cite also:
% hardware language in Agda \cite{harrison2021mechanized}
% template-based invariant generation \cite{kahsai2011instantiation}

% Other compilers for Lustre-style languages, such as Vélus \cite{bourke2017formally} and Heptagon \cite{gerard2012modular} ensure that the generated code can be executed in bounded memory and that each step takes a bounded time.
% With a carefully chosen set of primitives, the core streaming operations shown here would ensure bounded memory and time.
% For practicality, however, we currently allow embedding arbitrary total functions from the \fstar{} meta-language, which are not necessarily bounded in time.
% (Is this the same as Lucid Synchrone and Zélus? \CITE)

The deferred aspect of our proofs is similar to the deferred proofs of verification conditions for imperative programs, such as \cite{oconnor2019deferring}.
However, such verification conditions are \emph{syntactically} deferred so that the verification condition can be proved later; in our case, the verification conditions are \emph{semantically} deferred, so that more knowledge of the enclosing program can be exploited in the proof.
In imperative programs, this sort of extra knowledge is generally provided explicitly as loop invariants, and non-looping statements have their weakest precondition computed automatically.
In Lustre-style reactive languages such as ours, programs tend to be composed of many nested recursive streams, which perform a similar function to loops.
Explicitly specifying an invariant for each recursive stream would be cumbersome; deferring the proof allows such invariants to be implicit.

\subsection{Model-checking, counterexamples and invariant generation}
\TODO{integration with model-checker}
Model-checkers do have distinct advantages over interactive theorem-provers: they are more usable, can find strengthening invariants automatically, and provide counterexamples.
However, they are limited to comparatively simple properties.
The time-triggered example from \autoref{s:motivation} would be difficult to encode in a model-checker with a limited specification language, as the trigger invariant uses an auxiliary recursive function to find the next active trigger.

In future work, we would like to explore integrating Pipit with an existing model-checker.
For simple first-order nonrecursive programs and specifications that fit within the bounds of another model-checker, we could generate an encoding to use for counterexample generation.
We would also like to investigate automatically lifting the strengthened invariants and suggesting the corresponding Pipit invariant.
Such a translation and lifting would not form part of the trusted computing base, as generated invariants would still be proved separately in \fstar{}.
In this way, we hope that it may be possible to obtain some of the usability benefits of model-checkers, with the added power of manual proofs when necessary, while retaining trust that the compiled code satisfies the original specification.

% \subsection{Model-checking, counterexamples and invariant generation}
\subsection{Comparison to a combinator-based verification approach}
\TODO{compare to refinement types, verification conditions, etc here}

% Although Pipit is embedded in \fstar{}, which itself supports full dependent types and refinement types, we have opted to for a comparatively weakly-typed language.
% Our stream type \emph{stream $\tau$} denotes a (finite prefix of a) stream of elements of simple type $\tau$, but says nothing about how the stream evolves over time.

% We could consider an alternative approach that was closer to an imperative program logic with preconditions and postconditions.
% For example, we could consider a richer type $\stream \tau~ \{ \rawbind{x}{\phi} \}$ which then the result, of type $\tau$, always satisfies stream postcondition $\phi$.
% We could imagine specifying count_when with such a type:

% \begin{tabbing}
%   @val@ count_when ($\textit{max}$: $\NN$) ($\textit{inc}$: stream $\BB$): stream $\{ \top \} ~\NN~ \{ \rawbind{c}{0 \le c \le max} \}$\\
% \end{tabbing}

% An alternative would be to use refinement types \cite{chen2022synchronous} or some kind of program logic with pre- and post-conditions.

% We believe that such type-based approaches are useful for composing programs together, but 
%  the nested-recursive nature of Lustre programs makes such approaches cumbersome.
% In our system, the recursive combinator has type $@rec@: (\stream \alpha \to \stream \alpha) \to \stream \alpha$.
% Consider instead, if we had a refined stream $\stream \alpha \{ \psi \}$


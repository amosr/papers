%!TEX root = ../Main.tex

\section{Time-triggered}
\label{s:motivation}

Pure streaming languages like Lustre lie in an uneasy space somewhere between pure functions and imperative programs.
Like pure functions, pure streaming languages are equational and support reasoning by unfolding and rewriting.
Like imperative programs, they describe how state evolves over time.
Reasoning about them is somewhat tricky, then, as one must reason about finite prefixes of streams.

As a concrete example to introduce Pipit, we consider a program with a static schedule of \emph{triggers}, or actions to be performed at a particular time.
These triggers are stored in a constant array.
The program maintains an index that refers to the current active trigger; at each instant in time, the program checks if the active trigger has expired, and if so, it increments the index.
This trigger logic is a simplification of the time-triggered CAN bus specification \cite{fuehrer2001time}; we will discuss further in \autoref{s:evaluation}.

We first implement a streaming function \emph{count_when} to maintain the index; the function takes a constant natural number \emph{max} and a stream of booleans \emph{inc}.
At each time step, $\mbox{count_when}~\textit{max}~\textit{inc}$ checks whether the current increment flag is true; if so, it increments the previous counter, saturating at the maximum; otherwise, it leaves the previous counter as-is.

% \newcommand\signal{\textit{signal}}
\begin{tabbing}
  @MM@\= @MM@ \= \kill
  @let@ count_when ($\textit{max}$: $\NN$) ($\textit{inc}$: stream $\BB$): stream $\NN$ = \\
    \> $@rec@~\rawbind{\textit{count}}{}$ \\
    \> \> @let@ $\textit{count'}$ @=@ $(0~@fby@~\textit{count}) + (@if@~\textit{inc}~@then@~1~@else@~0)$ @in@ \\
    \> \> $\xcheckP{\PSUnknown}{(0 \le \textit{count} \le \textit{max})}$; \\
    \> \> @if @ $\textit{count'} \ge \textit{max}$ @then@ $\textit{max}$  @else@ $\textit{count'}$ \\
    % \> $\textit{count}$ \\
\end{tabbing}

The implementation of \emph{count_when} first defines a recursive stream, \emph{count}, which in turn defines a local incremented stream \emph{count'}.
The syntax $0~@fby@~\textit{count}$ can be read as zero \emph{followed by} the previous count.

The syntax $\xcheckP{\PSUnknown}{(0 \le \textit{count} \le \textit{max})}$ asserts that the count is within the range $[0, \textit{max}]$.
The subscript $\PSUnknown$ on the check is the \emph{property status}, which in this case denotes that the assertion has been stated, but it is not yet known whether it holds.
A property status of $\PSValid$, on the other hand, denotes that a property has been proved to hold.
These property statuses are used to defer checking properties until enough is known about the environment, and to avoid rechecking properties that have already been proven.

Pipit is an embedded domain-specific language. % we usually present Pipit programs using \fstar{} syntactic sugar rather than showing the desugared core program.
The program above is really syntactic sugar for a \fstar{} program that takes a natural number and constructs a Pipit core expression with a free boolean variable; we will discuss the details of the core language in \autoref{s:core}.

To actually prove the property above, we translate the program into a transition system and prove the property inductively on the system.
Finally, we \emph{bless} the expression, which marks the properties as valid.
Blessing is an intensional operation: it modifies the internal structure of the expression, but does not affect the operational semantics.

\begin{tabbing}
  @MM@\= @MM@ \= \kill
  @let@ $\mbox{count_when}_{\PSValid}$ ($\textit{max}$: $\NN$): stream $\BB$ $\to$ stream $\NN$ = \\
    \> @let@ $\textit{system} = \mbox{System.translate}_1 (\mbox{count_when}~\textit{max})$ @in@ \\
    \> @assert@ (System.inductive_check $\textit{system}$) @by@ (pipit\_simplify ()); \\
    \> $@bless@_1$ $(\mbox{count_when}~\textit{max})$
\end{tabbing}

The subscript 1 in the translation to transition system and blessing operations refers to the fact that the stream function has one parameter.
This proof does require some boilerplate; in the future we plan to minimise this with metaprogramming.

Callers of count_when can now use the valid variant without needing to re-prove the count-range property.


\begin{tabbing}
  @MM@\= @MM@ \= \kill
  @let@ trigger_fetch ($\textit{index}$: stream $\NN$): stream trigger = \\
    \> $@contract@_{\PSUnknown}$ \\
    \> \> \{ $0 \le \textit{index} \le \textit{maximum}$ \} \\
    \> \> Array.index_const \textit{triggers_array} \textit{index} \\
    \> \> \{ trigger.~$\true$ \} \\
\end{tabbing}

% \section{Pipit in flight}
% \pagebreak
\section{Programming and verifying in Pipit}
\label{s:tut}

\TODO{KILLMERGE}

A common requirement in controllers is to filter an input signal, perhaps using a \emph{finite impulse response} (FIR) filter, which is equivalent to a weighted moving average.
An FIR filter takes a vector of coefficients and an input signal; at every point in time, it computes the dot product of the coefficients and the most recent values of the signal.
We can implement an FIR filter in Pipit as follows:

\newcommand\signal{\textit{signal}}
\begin{tabbing}
  @MM@\= @MMMMMM@ \= \kill
  @let@ fir ($\textit{coefficients}$: list $\RR$) ($\signal$: stream $\RR$): stream $\RR$ = \\
    \> @match@ $\textit{coefficients}$ @with@ \\
    \> @|@ $[]$ \> $\to 0$ \\
    \> @|@ $c :: \cs $ \> $\to (\signal \cdot c) + (\xfby{0}{(\mbox{fir~} \cs~\signal)})$
\end{tabbing}

% Our FIR filter takes two arguments, one describing the coefficients and one describing the signal to filter.
The coefficient vector is represented by a list of reals, while the signal is a \emph{stream} of reals, and the result is the filtered stream.
% \footnote{The actual implementation uses integers with fixed-point arithmetic, but we use reals here to reduce clutter.}
The implementation starts by looking at the list of coefficients and returns zero if the list is empty.
If the list is not empty, then we multiply the most recent value of the stream by the coefficient ($\signal \cdot c$); we also take the result of applying the remaining coefficients to the signal stream ($\mbox{fir~} \cs ~ \signal$) and delay it ($\xfby{0}{\ldots}$) before summing the two parts.
At the start of execution the delay is initially zero.

Pipit is an \emph{embedded} language, like Bedrock~\cite{chlipala2013bedrock}: in this example, the stream type denotes an actual Pipit expression, while the list type and its associated pattern match are part of the \fstar{} meta-language.
To get the real Pipit program, we need to apply the filter to a concrete list of coefficients:

\newcommand\bibo{\mbox{bibo}}
\newcommand\fir{\mbox{fir}}
\newcommand\ii{\textit{input}}
\newcommand\oo{\textit{output}}
\newcommand\ok{\textit{ok}}
\begin{tabbing}
  @MM@\= @MMMMMM@ \= \kill
  @let@ $\mbox{fir}_2$ ($\ii$: stream $\RR$): stream $\RR$ = \\
    \> $\mbox{fir}~[0.7; 0.3] \ii$
\end{tabbing}

Normalising this definition evaluates away all of the lists.
The result fits in the core language defined in \autoref{s:core}, for which we can generate real-time imperative code:

\begin{tabbing}
    @MM@\= @MMMMMM@ \= \kill
      @let@ $\mbox{fir}_2$ ($\ii$: stream $\RR$): stream $\RR$ = \\
    \> $(0.7 \cdot \ii) + (\xfby{0}{((0.3 \cdot \ii) + (\xfby{0}{0}))})$
\end{tabbing}

The properties that we want to state about reactive programs usually involve some temporal aspect.
Rather than defining a separate specification language, we implement computable variants of temporal operators from \emph{past-time} linear temporal logic \cite{halbwachs1993executable,lichtenstein1985glory}.
We name the past-globally operator \emph{sofar}, as in \emph{the predicate has been true so far}:

\begin{tabbing}
  @MM@\= @MMMMMM@ \= \kill
  @let@ sofar ($p$: stream $\BB$): stream $\BB$ = \\
    \> $\xrec{p'}{p \wedge (\xfby{@true@}{p'})}$
\end{tabbing}

This definition takes a stream of predicates $p$ and introduces a recursive stream $p'$.
At each step, the recursive stream $p'$ checks that the current predicate is true ($p$), and also checks that \emph{sofar} was previously true ($\xfby{@true@}{p'}$).
If there is no previous value, it defaults to true.

\subsection{Bounded input, bounded output}
\label{ss:tut:bibo}
We can now state a \emph{bounded-input-bounded-output} (BIBO) property, which says that if the inputs have always been within some particular range, then the outputs are also within the range:
% Properties like this can occur as an internal invariant in a larger system:

\begin{tabbing}
  @MM@\= @LET OUTPUT@\= @EXAMPLE1 INPUT@ \= \kill
  @let@ $\mbox{bibo}_2$ (n: $\RRgez$) ($\ii$: stream $\RR$): stream $\BB$ = \\
  \> @check@ $(\mbox{sofar}(|\ii| \le n) \implies |\mbox{fir}_2~\ii| \le n)$
\end{tabbing}

This property states that if the input has always been in the range $[-n, n]$, then the output is also within the range $[-n, n]$.
Note that the upper bound $n$ is a nonnegative real rather than a stream of reals, which means that $n$ stays constant across the whole stream.
To prove that this property holds, we translate to a transition system and show that the stream is always true.
In this case, induction over the transition relation is sufficient to prove the property.
There is some boilerplate required to perform the induction, but both base and step cases are automatically proved by \fstar{}:

\begin{tabbing}
  @MM@\= @MMMMMMMMMMMMMMMMMMMMMMM@ \= \kill
  @let@ $\mbox{proof}_2$ (n: $\RRgez$): Lemma (induct ($\bibo_2$ n)) = \\
  \> @assert@ (base\_case ($\bibo_2 ~n$)) \> @by@ (pipit\_simplify ()); \\
  \> @assert@ (step\_case ($\bibo_2 ~n$)) \> @by@ (pipit\_simplify ())
\end{tabbing}

This definition uses \fstar{}'s \emph{lemma} syntax to state that the BIBO property holds inductively for any $n$.
The two assertions prove the inductive cases separately, using our \emph{simplify} tactic to ensure that the translation to transition system is normalised away, and any translation artefacts are removed.

If we wish to prove a similar BIBO property for a filter with more coefficients, standard induction over the transition system is not sufficient: the relationship between the stacked delays in the filter and sofar is not clear from a single step of the transition system.
One simple automated way to strengthen invariants is via \emph{k-induction}~\cite{hagen2008scaling}, which adds more context by assuming that the property holds for $k$ previous steps of the transition relation.
We can define analogous functions $\fir_3$ and $\bibo_3$ which operate on the coefficients $[0.7; 0.2; 0.1]$, and use k-induction for $k = 2$ as follows:

\begin{tabbing}
  @MM@\= @MMMMMMMMMMMMMMMMMMMMMMMMMMM@ \= \kill
  @let@ $\mbox{proof}_3$ (n: $\RRgez$): Lemma (induct\_k 2 ($\bibo_3$ n)) = \\
  \> @assert@ (base\_case\_k 2 ($\bibo_3 ~n$)) \> @by@ (pipit\_simplify ()); \\
  \> @assert@ (step\_case\_k 2 ($\bibo_3 ~n$)) \> @by@ (pipit\_simplify ())
\end{tabbing}

Although the properties here boil down to simple properties about linear arithmetic, we believe that this example demonstrates a promising way to use \fstar{}'s existing proof automation to verify reactive systems.

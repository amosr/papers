%!TEX root = ../Main.tex

\section{Time-triggered}
\label{s:motivation}

Pure streaming languages like Lustre lie in an uneasy space somewhere between pure functions and imperative programs.
Like pure functions, pure streaming languages are equational and support reasoning by unfolding and rewriting.
Like imperative programs, they describe how state evolves over time.
Additionally, Lustre programs tend to be composed of many nested recursive loops.
When verifying both pure and imperative programs, recursion or loops generally require explicit loop invariants.
Requiring an explicit invariant for each recursive stream quickly becomes unwieldy for Lustre programs.

To introduce Pipit, we consider a driver with a static schedule of \emph{triggers}, or actions to be performed at a particular time; this driver is a simplification of the time-triggered CAN bus specification \cite{fuehrer2001time} which we will discuss further in \autoref{s:evaluation}.
In this system, time is partitioned into a sequence of \emph{cycles}; at the start of each new cycle, the time is reset to zero.
The triggers are stored in a constant array, sorted by their associated time-mark.
Triggers also have a cycle offset and a repeat factor, which together determine the cycles in which the trigger is active.

The time-marks are strict deadlines on the order of microseconds, which prohibits the driver from looping through the whole array at each time step to find the next active trigger.
Instead, the driver maintains an index that refers to the current trigger; at each instant in time, the driver checks if the current trigger has expired or is inactive, and if so, it increments the index.
Multiple triggers can have the same time-mark, as long as they are active in different cycles; triggers that are active on the same cycle must have a sufficiently wide gap in their time-marks to allow the driver time to iterate through the inactive triggers between them and reach the next active trigger before it starts.
The implementation itself is simple, but formalising exactly what constitutes a ``sufficiently wide gap'' and proving that the schedule is never late requires care.

We first implement a streaming function \emph{count_when} to maintain the index; the function takes a constant natural number \emph{max} and a stream of booleans \emph{inc}.
At each time step, count_when checks whether the current increment flag is true; if so, it increments the previous counter, saturating at the maximum; otherwise, it leaves the previous counter as-is.

\begin{tabbing}
  @MM@\= @MM@ \= \kill
  @let@ count_when ($\textit{max}$: $\NN$) ($\textit{inc}$: stream $\BB$): stream $\NN$ = \\
    \> $@rec@~\rawbind{\textit{count}}{}$ \\
    \> \> @let@ $\textit{count'}$ @=@ $(0~@fby@~\textit{count}) + (@if@~\textit{inc}~@then@~1~@else@~0)$ @in@ \\
    \> \> $\xcheckP{\PSUnknown}{(0 \le \textit{count} \le \textit{max})}$; \\
    \> \> @if @ $\textit{count'} \ge \textit{max}$ @then@ $\textit{max}$  @else@ $\textit{count'}$ \\
\end{tabbing}

The implementation of \emph{count_when} first defines a recursive stream, \emph{count}, which in turn defines a local incremented stream \emph{count'}.
The syntax $0~@fby@~\textit{count}$ can be read as ``the initial value of zero \emph{followed by} the previous count''.

The syntax $\xcheckP{\PSUnknown}{(0 \le \textit{count} \le \textit{max})}$ asserts that the count is within the range $[0, \textit{max}]$.
The subscript $\PSUnknown$ on the check is the \emph{property status}, which in this case denotes that the assertion has been stated, but it is not yet known whether it holds.
A property status of $\PSValid$, on the other hand, denotes that a property has been proved to hold.
These property statuses are used to defer checking properties until enough is known about the environment, and to avoid rechecking properties that have already been proven.
In practice, the user does not explicitly specify property statuses in the source language.
The stated property $(0 \le \textit{count} \le \textit{max})$ is a stream of booleans which must always be true\footnote{We limit our scope to safety properties: in real-time systems, liveness properties tend to be easily restated as bounded liveness properties, which are a form of safety property \cite{manna2012temporal}}.
Non-streaming operations such as $\le$ are implicitly lifted to streaming operations, and non-streaming values such as $0$ and $\textit{max}$ are implicitly lifted to constant streams.

We defer the proof of the property here because, at the point of stating the property inside the @rec@ combinator, we don't yet have a concrete definition for the count variable.
In this case, we could have instead deferred the \emph{statement} of the property by introducing a let-binding for the count and putting the @check@ outside of the @rec@ combinator.
However, it is not always possible to defer property statements: for example, when calling other streaming functions that have their own preconditions, it may not be possible to move the function call outside of its enclosing @rec@.
In such cases, it is necessary to defer the proof of the precondition.



Pipit is an embedded domain-specific language.
The program above is really syntactic sugar for an \fstar{} program that takes a natural number and constructs a Pipit core expression with a free boolean variable.
We will discuss the details of the core language in \autoref{s:core}, but for now we will show the source program with some minor embedding details omitted.

To actually prove the property above, we
% use \fstar{}'s tactics and proof automation to
translate the program into a transition system and prove the property inductively on the system.
Finally, we \emph{bless} the expression, which marks the properties as valid ($[\PSUnknown := \PSValid]$).
Blessing is an intensional operation: it traverses the expression and updates the internal metadata, but it does not affect the runtime semantics.

\begin{tabbing}
  @MM@\= @MM@ \= \kill
  @let@ $\mbox{count_when}_{\PSValid}$ ($\textit{max}$: $\NN$): stream $\BB$ $\to$ stream $\NN$ = \\
    \> @let@ $\textit{system} = \mbox{System.translate}_1 (\mbox{count_when}~\textit{max})$ @in@ \\
    \> @assert@ (System.inductive_check $\textit{system}$) @by@ (pipit_simplify ()); \\
    \> $@bless@_1$ $(\mbox{count_when}~\textit{max})$
\end{tabbing}

The subscript 1 in the translation to transition system and blessing operations refers to the fact that the stream function has one stream parameter.
The pipit_simplify tactic in the assertion performs normalisation-by-evaluation to simplify away the translation to a first-order transition system; \fstar{}'s proof-by-SMT can then solve the inductive check directly.
% This proof does require some boilerplate; in the future we hope to minimise this.

Callers of count_when can now use the validated variant without needing to re-prove the count-range property.
In a dedicated model-checker such as Kind2 \cite{champion2016kind2} or Lesar \cite{raymond2008synchronous}, this kind of bookkeeping would all be performed under-the-hood.
By embedding Pipit in a general-purpose theorem prover, we move some of the bookkeeping burden onto the user; however, we also reduce the semantic gap between compilation and proofs, as well as allowing manual proof steps when the automated proofs get stuck.
As an embedded language, we also benefit from writing our programs in a rich metalanguage.

The trigger-fetch logic requires such a combination of automatic and manual proofs.
The trigger-fetch logic uses the count_when streaming function to define the index; the increment flag given to count_when will increment the index if the previous index has expired or is inactive in the current cycle.
We simplify our presentation here and only consider a single cycle in isolation: the real system presented in \autoref{s:evaluation} has some extra complexity, such as resetting the index, incrementing the cycle index at the start of a new cycle, and using machine integers.

\begin{tabbing}
  @MM@\= @MM@ \= @let index@ \= \kill
  @let@ trigger_fetch ($\textit{cfg}$: triggers) ($\textit{cycle}$: $\NN$) ($\textit{time}$: stream $\NN$): stream $\NN$ = \\
    \> $@rec @ \textit{index}.$ \\
    \> \> $@let @ \textit{inc} = \text{false} @ fby @ ((\text{time_mark}~\textit{cfg}~\textit{index} \le \textit{time}) \vee \neg (\text{enabled}~\textit{cfg}~\textit{index}~\textit{cycle})) @ in@$\\
    \> \> $@let @ \textit{index} = \mbox{count_when}_{\PSValid}~(\text{trigger_count}~\textit{cfg})~\textit{inc} @ in@$ \\
    \> \> $\xcheckP{\PSUnknown}{(\text{can_reach_next_active}~\textit{cfg}~\textit{cycle}~\textit{time}~\textit{index})}$; \\
    % \> \> $\xcheckP{\PSUnknown}{(\text{time_no_skips}~\textit{time} \implies \text{can_reach_next_active}~\textit{cfg}~\textit{cycle}~\textit{time}~\textit{index})}$; \\
    \> \> $\text{pose_forall}_{\PSValid}~(\forall \rawbind{i} \text{can_reach_next}~\textit{cfg}~\textit{cycle}~i)~\textit{index}$; \\
    \> \> $\textit{index}$\\
\end{tabbing}

The implementation of trigger_fetch defines a streaming function which takes a static trigger configuration, the cycle index (static for now), and the stream denoting the current time.
The static trigger configuration contains the constant triggers array, as well as proofs that the configuration describes a valid schedule: for example, that the triggers are sorted by time-mark and have adequate gaps between their times.

The increment flag and the index are mutually dependent --- the increment flag depends on the previous value of the index, while the index depends on the current value of the increment flag --- so we introduce a recursive stream for the index.

We state, with a checked property of unknown status, that an invariant holds for the current time and index.
Informally, this invariant states that the next active trigger at or after the current index is now or in the future, and we can reach it in time if we increment the index at every time-step.

We then use the pose_forall combinator to instantiate a non-streaming proof with a streaming argument: given a proof of $(\forall \rawbind{(x: \tau)} p~x)$ and a stream $(s: \stream{\tau})$, we can infer that $p$ holds for all elements of the stream $s$.
We annotate the call with $\PSValid$ here to emphasise that the proof is not deferred, but we do not include this in practice.
The pose_forall function is in fact just a helper function implemented using the check, transition-system and bless functions already seen.
The property we state here is that if the trigger at the current index is active, then there is a sufficient time gap to be able to reach the next active trigger after the current index.

After explicitly instantiating this lemma, we prove the streaming invariant by induction on the transition system.
To help make proofs of the rest of the system more compositional, we also abstract over the details of the trigger-fetch mechanism by introducing a rely-guarantee contract for trigger_fetch.
The contract we state is that if the environment always ensures that the time doesn't skip --- that is, we are called once per microsecond --- then we guarantee that whenever the index points to a valid, active trigger, then the trigger has not yet expired.
Note that this contract is not a full functional specification.

\begin{tabbing}
  @MM@\= @MM@ \= @MMMMMM@ \= \kill
  @let@ $\text{trigger_fetch}_{\PSValid}$ ($\textit{cfg}$: triggers) ($\textit{cycle}$: $\NN$): $\stream \NN \to \stream \NN$ = \\
  \> @let@ $\textit{contract} = \text{Contract.contract_of_stream}_1$ \{ \\
  \> \> @rely@ = $(\lambda \textit{time}.~ \text{time_no_skips}~\textit{time} )$ \\
  \> \> @guar@ = $(\lambda \textit{time index}.~ \text{index_valid}~\textit{cfg}~\textit{index} \wedge \text{enabled}~\textit{cfg}~\textit{index}~\textit{cycle})$ \\
  % \> \> @guar@ = $(\lambda \textit{time index}.~ (\textit{index} < (\text{trigger_count}~\textit{cfg}) \wedge \text{enabled}~\textit{cfg}~\textit{index}~\textit{cycle})$ \\
  \> \> \> $\implies \text{time_mark}~\textit{cfg}~\textit{index} \ge \textit{now})$ \\
  \> \> @body@ = $(\lambda \textit{time}.~ \text{trigger_fetch}~\textit{cfg}~\textit{cycle}~\textit{time} )$ \\
  \> \} @in@ \\
  \> @assert@ $(\text{Contract.inductive_check}~\textit{contract})$ @by@ (pipit_simplify ()); \\
  \> $\text{Contract.stream_of_contract}_1~\textit{contract}$
\end{tabbing}

In the implementation of the validated variant of trigger_fetch, we first construct the contract from streaming functions.
The $\text{Contract.contract_of_stream}_1$ combinator describes a contract with one input (the time stream), and takes stream transformers for each of the rely, guarantee and body.
The combinator transforms the surface syntax into core expressions.
The assertion $(\text{Contract.inductive_check}~\textit{contract})$ then translates the expressions into a transition system, and checks that if the rely always holds then the guarantee always holds, and that the as-yet-unchecked subproperties hold.
Finally, $\text{Contract.stream_of_contract}_1$ blesses the core expression and converts it back to a stream transformer, so it can be easily used by other parts of the program.

When this function is used in other parts of the program, the caller must ensure that the environment satisfies the rely.
In the core language, this is tracked by another deferred property status attached to the contract; we will discuss this further in \autoref{s:core}.
Deferring the proof of the rely clause is crucial for function calls where satisfying the precondition at a particular point in time somehow depends on the value of the output at a previous step.
These kinds of self-dependencies and mutual-dependencies are fairly common in Lustre-style programs: for example, the trigger_fetch's invocation of count_when, whose input $\textit{inc}$ depends on the previous output $\textit{index}$.



\subsection{Program logics and dependent types}
\TODO{compare to refinement types, verification conditions, etc here, or wait to \autoref{s:related-work}?}

% Although Pipit is embedded in \fstar{}, which itself supports full dependent types and refinement types, we have opted to for a comparatively weakly-typed language.
% Our stream type \emph{stream $\tau$} denotes a (finite prefix of a) stream of elements of simple type $\tau$, but says nothing about how the stream evolves over time.

% We could consider an alternative approach that was closer to an imperative program logic with preconditions and postconditions.
% For example, we could consider a richer type $\stream \tau~ \{ \rawbind{x}{\phi} \}$ which then the result, of type $\tau$, always satisfies stream postcondition $\phi$.
% We could imagine specifying count_when with such a type:

% \begin{tabbing}
%   @val@ count_when ($\textit{max}$: $\NN$) ($\textit{inc}$: stream $\BB$): stream $\{ \top \} ~\NN~ \{ \rawbind{c}{0 \le c \le max} \}$\\
% \end{tabbing}

% An alternative would be to use refinement types \cite{chen2022synchronous} or some kind of program logic with pre- and post-conditions.

% We believe that such type-based approaches are useful for composing programs together, but 
%  the nested-recursive nature of Lustre programs makes such approaches cumbersome.
% In our system, the recursive combinator has type $@rec@: (\stream \alpha \to \stream \alpha) \to \stream \alpha$.
% Consider instead, if we had a refined stream $\stream \alpha \{ \psi \}$


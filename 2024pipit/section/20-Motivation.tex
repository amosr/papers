%!TEX root = ../Main.tex

\section{Time-triggered}
\label{s:motivation}

Pure streaming languages like Lustre lie in an uneasy space somewhere between pure functions and imperative programs.
Like pure functions, pure streaming languages are equational and support reasoning by unfolding and rewriting.
Like imperative programs, they describe how state evolves over time.
Additionally, Lustre programs tend to be composed of many nested recursive loops.
When verifying both pure and imperative programs, recursion or loops generally require explicit loop invariants.
Requiring an explicit invariant for each recursive stream quickly becomes unwieldy for Lustre programs.

To introduce Pipit, we consider a driver with a static schedule of \emph{triggers}, or actions to be performed at a particular time; this driver is a simplification of the time-triggered CAN bus specification \cite{fuehrer2001time} which we will discuss further in \autoref{s:evaluation}.
In this system, time is partitioned into a sequence of \emph{cycles}; at the start of each new cycle, the time is reset to zero.
The triggers are stored in a constant array, sorted by their associated time-mark.
Triggers also have a cycle offset and a repeat factor, which together determine the cycles in which the trigger is active.

The time-marks are strict deadlines on the order of microseconds, which prohibits the driver from looping through the whole array at each time step to find the next active trigger.
Instead, the driver maintains an index that refers to the current trigger; at each instant in time, the driver checks if the current trigger has expired or is inactive, and if so, it increments the index.
Multiple triggers can have the same time-mark, as long as they are active in different cycles; triggers that are active on the same cycle must have a sufficiently wide gap in their time-marks to allow the driver time to iterate through the inactive triggers between them and reach the next active trigger before it starts.
The implementation itself is simple, but formalising exactly what constitutes a ``sufficiently wide gap'' and proving that the schedule is never late requires care.

We first implement a streaming function \emph{count_when} to maintain the index; the function takes a constant natural number \emph{max} and a stream of booleans \emph{inc}.
At each time step, count_when checks whether the current increment flag is true; if so, it increments the previous counter, saturating at the maximum; otherwise, it leaves the previous counter as-is.

\begin{tabbing}
  @MM@\= @MM@ \= \kill
  @let@ count_when ($\textit{max}$: $\NN$) ($\textit{inc}$: stream $\BB$): stream $\NN$ = \\
    \> $@rec@~\rawbind{\textit{count}}{}$ \\
    \> \> @let@ $\textit{count'}$ @=@ $(0~@fby@~\textit{count}) + (@if@~\textit{inc}~@then@~1~@else@~0)$ @in@ \\
    \> \> $\xcheckP{\PSUnknown}{(0 \le \textit{count} \le \textit{max})}$; \\
    \> \> @if @ $\textit{count'} \ge \textit{max}$ @then@ $\textit{max}$  @else@ $\textit{count'}$ \\
\end{tabbing}

The implementation of \emph{count_when} first defines a recursive stream, \emph{count}, which in turn defines a local incremented stream \emph{count'}.
The syntax $0~@fby@~\textit{count}$ can be read as ``the initial value of zero \emph{followed by} the previous count''.

The syntax $\xcheckP{\PSUnknown}{(0 \le \textit{count} \le \textit{max})}$ asserts that the count is within the range $[0, \textit{max}]$.
The subscript $\PSUnknown$ on the check is the \emph{property status}, which in this case denotes that the assertion has been stated, but it is not yet known whether it holds.
A property status of $\PSValid$, on the other hand, denotes that a property has been proved to hold.
These property statuses are used to defer checking properties until enough is known about the environment, and to avoid rechecking properties that have already been proven.
In practice, the user does not explicitly specify property statuses in the source language.
The stated property $(0 \le \textit{count} \le \textit{max})$ is a stream of booleans which must always be true\footnote{We limit our scope to safety properties: in real-time systems, liveness properties tend to be easily restated as bounded liveness properties, which are a form of safety property \cite{manna2012temporal}}.
Non-streaming operations such as $\le$ are implicitly lifted to streaming operations, and non-streaming values such as $0$ and $\textit{max}$ are implicitly lifted to constant streams.

We defer the proof of the property here because, at the point of stating the property inside the @rec@ combinator, we don't yet have a concrete definition for the count variable.
In this case, we could have instead deferred the \emph{statement} of the property by introducing a let-binding for the count and putting the @check@ outside of the @rec@ combinator.
However, it is not always possible to defer property statements: for example, when calling other streaming functions that have their own preconditions, it may not be possible to move the function call outside of its enclosing @rec@.
In such cases, it is necessary to defer the proof of the precondition.



Pipit is an embedded domain-specific language.
The program above is really syntactic sugar for an \fstar{} program that takes a natural number and constructs a Pipit core expression with a free boolean variable.
We will discuss the details of the core language in \autoref{s:core}, but for now we will show the source program with some minor embedding details omitted.

To actually prove the property above, we
% use \fstar{}'s tactics and proof automation to
translate the program into a transition system and prove the property inductively on the system.
Finally, we \emph{bless} the expression, which marks the properties as valid ($[\PSUnknown := \PSValid]$).
Blessing is an intensional operation: it traverses the expression and updates the internal metadata, but it does not affect the runtime semantics.

\begin{tabbing}
  @MM@\= @MM@ \= \kill
  @let@ $\mbox{count_when}_{\PSValid}$ ($\textit{max}$: $\NN$): stream $\BB$ $\to$ stream $\NN$ = \\
    \> @let@ $\textit{system} = \mbox{System.translate}_1 (\mbox{count_when}~\textit{max})$ @in@ \\
    \> @assert@ (System.inductive_check $\textit{system}$) @by@ (pipit\_simplify ()); \\
    \> $@bless@_1$ $(\mbox{count_when}~\textit{max})$
\end{tabbing}

The subscript 1 in the translation to transition system and blessing operations refers to the fact that the stream function has one stream parameter.
The pipit_simplify tactic in the assertion performs normalisation-by-evaluation to simplify away the translation to a first-order transition system; \fstar{}'s proof-by-SMT can then solve the inductive check directly.
% This proof does require some boilerplate; in the future we hope to minimise this.

Callers of count_when can now use the validated variant without needing to re-prove the count-range property.
In a dedicated model-checker such as Kind2 \cite{champion2016kind2} or Lesar \cite{raymond2008synchronous}, this kind of bookkeeping would all be performed under-the-hood.
By embedding Pipit in a general-purpose theorem prover, we move some of the bookkeeping burden onto the user; however, we also reduce the semantic gap between compilation and proofs, as well as allowing manual proof steps when the automated proofs get stuck.
As an embedded language, we also benefit from writing our programs in a rich metalanguage.

The trigger-fetch logic requires such a combination of automatic and manual proofs.
The trigger-fetch logic uses the count_when streaming function to define the index; the increment flag given to count_when will increment the index if the previous index has expired or is inactive in the current cycle.
We simplify our presentation here and only consider a single cycle in isolation: the real system presented in \autoref{s:evaluation} has some extra complexity, such as resetting the index, incrementing the cycle index at the start of a new cycle, and using machine integers.

\begin{tabbing}
  @MM@\= @MM@ \= @let index@ \= \kill
  @let@ trigger_fetch ($\textit{cfg}$: triggers) ($\textit{cycle}$: $\NN$) ($\textit{time}$: stream $\NN$): stream $\NN$ = \\
    \> $@rec @ \textit{index}.$ \\
    \> \> $@let @ \textit{inc} = \text{false} @ fby @ ((\text{time_mark}~\textit{cfg}~\textit{index} \le \textit{time}) \vee \neg (\text{enabled}~\textit{cfg}~\textit{index}~\textit{cycle})) @ in@$\\
    \> \> $@let @ \textit{index} = \mbox{count_when}_{\PSValid}~(\text{trigger_count}~\textit{cfg})~\textit{inc} @ in@$ \\
    \> \> $\xcheckP{\PSUnknown}{(\text{time_no_skips}~\textit{time} \implies \text{can_reach_next_active}~\textit{cfg}~\textit{cycle}~\textit{time}~\textit{index})}$; \\
    \> \> $\text{pose_forall}_{\PSValid}~(\forall \rawbind{i} \text{can_reach_next}~\textit{cfg}~\textit{cycle}~i)~\textit{index}$; \\
    \> \> $\textit{index}$\\
\end{tabbing}

The implementation of trigger_fetch defines a streaming function which takes a static trigger configuration, the cycle index (static for now), and the stream denoting the current time.
The static trigger configuration contains the constant triggers array, as well as proofs that the configuration is schedulable: for example, that the triggers are sorted by time-mark and have adequate gaps between their times.

The increment flag and the index are mutually dependent --- the increment flag depends on the previous value of the index, while the index depends on the current value of the increment flag --- so we introduce a recursive stream for the index.

We state, with a checked property of unknown status, that an invariant holds for the current time and index.
Informally, this invariant states that, if the time stream never misses any steps, then the next active trigger is in the future, and we can reach it in time if we increment the index at every time-step.

Finally, we use the pose_forall combinator to instantiate a non-streaming proof with a streaming argument: given a proof of $\forall \rawbind{(x: \tau)} p~x$ and a stream $s: \stream{\tau}$, we can infer that $p$ holds for all elements of the stream $s$.
We annotate the call with $\PSValid$ here to emphasise that the proof is not deferred, but we do not include this in practice.
The pose_forall function is in fact just a helper function implemented using the check, transition-system and bless functions already seen.


\begin{tabbing}
  @MM@\= @MM@ \= \kill
  @let@ array_index ($\textit{array}: \mbox{const_array}~\alpha$) ($\textit{index}$: stream $\NN$): stream $\alpha$ = \\
  \> $@contract@_{\PSUnknown}$ \\
  \> \> \{ $0 \le \textit{index} < \mbox{Array.length}~\textit{array}$ \} \\
  \> \> Array.index_unsafe \textit{array} \textit{index} \\
  \> \> \{ $v.~v~=~\mbox{Array.index_unsafe}~\textit{array}~\textit{index}$ \} \\
\end{tabbing}

Contracts consist of a property status, a rely clause, a body, and a guarantee clause.
The rely clause states that the calling context must ensure that every element of the index stream is a valid index.
In turn, the contract guarantees that every element of the result will be the element of the array at the corresponding index.
The contract status of unknown ($\PSUnknown$) denotes that, although the body satisfies the contract, we have not yet shown that the calling context satisfies the rely clause -- such a proof must wait until the contract is instantiated.


% \subsection{Program logics and dependent types}

% Although Pipit is embedded in \fstar{}, which itself supports full dependent types and refinement types, we have opted to for a comparatively weakly-typed language.
% Our stream type \emph{stream $\tau$} denotes a (finite prefix of a) stream of elements of simple type $\tau$, but says nothing about how the stream evolves over time.

% We could consider an alternative approach that was closer to an imperative program logic with preconditions and postconditions.
% For example, we could consider a richer type $\stream \tau~ \{ \rawbind{x}{\phi} \}$ which then the result, of type $\tau$, always satisfies stream postcondition $\phi$.
% We could imagine specifying count_when with such a type:

% \begin{tabbing}
%   @val@ count_when ($\textit{max}$: $\NN$) ($\textit{inc}$: stream $\BB$): stream $\{ \top \} ~\NN~ \{ \rawbind{c}{0 \le c \le max} \}$\\
% \end{tabbing}

% An alternative would be to use refinement types \cite{chen2022synchronous} or some kind of program logic with pre- and post-conditions.

% We believe that such type-based approaches are useful for composing programs together, but 
%  the nested-recursive nature of Lustre programs makes such approaches cumbersome.
% In our system, the recursive combinator has type $@rec@: (\stream \alpha \to \stream \alpha) \to \stream \alpha$.
% Consider instead, if we had a refined stream $\stream \alpha \{ \psi \}$


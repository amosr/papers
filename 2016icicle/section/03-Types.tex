%!TEX root = ../Main.tex
\section{Types}
\label{s:Types}

We will now formally describe the typesystem of Icicle, and show how modality types are used to enforce the single-pass restriction.

\input{figures/Source-Type.tex}

\subsection{Types}
In figure~\ref{fig:source:type:defs} we define the types.
We use $T$ for base types, of which we only have natural numbers and booleans.

Modalities are $M$, with @Aggregate@ meaning the result of some fold, @Element@ being an element of the input stream, and @Pure@ being a pure computation.
The modalities are defined so that @Aggregate@ and @Element@ computations cannot be mixed.
There is no way to turn an aggregate computation into an element computation, as aggregate computations are only available once the entire stream has been read.
Element computations must be explicitly folded over or aggregated in some way, in order to produce an aggregate computation based off it.
\TODO{Staged computation similarities}

The @Pure@ modality is actually the absence of a mode; this is simply made explicit for clarity.

Finally we define function types as $T_\to$, which can be a simple return type with a modality, or a function taking a modality argument and returning a function.
For simplicity of compilation, we have strictly disallowed higher order functions by requiring the argument to be a base type rather than a function type.

At various points in the following rules we will implicitly convert function types $T_\to$ to modal base types $M~T$; at these points function arrows are not allowed.



\subsection{Function application with unboxing}
In figure~\ref{fig:source:type:wrap} there are two judgments defined, which are both used for the type of function application.
In contrast to traditional modality type systems, we infer the boxing and unboxing of various modalities.
\TODO{Citation and find something similar.}
\TODO{Probably talk about comonads or something}

Informally, if a function expects an @Element@ and is passed a @Pure@ argument, we should box the argument into @Element@.
If a function expects a @Pure@ computation and is passed an @Element@, we must unbox the argument, apply the function, then rebox the result.
However, this reboxing can only occur if the result is @Pure@ or @Element@ - an @Aggregate@ result cannot be boxed into an @Element@.

These function application judgments only deal with the unboxing case; boxing is dealt with later as the single rule (TcBox).

The judgment $\WrapMode{\tau}{m}{\tau'}$, corresponds to unboxing the a function argument of type $m$ and reboxing the function return type $\tau$ into modality $m$, with $\tau'$ as the boxed return type.
The rule (WrapModeArrow) simply recurses down through the function arguments, applying the judgment to the result.
The rule (WrapElement) applies when reboxing an @Element@ result as an @Element@, and similarly for (WrapAggregate).
For (WrapPure) the result type is a @Pure@, so it can be boxed to any mode.
If these rules do not apply, for example when an @Aggregate@ result is attempted to be reboxed as an @Element@, the function application is an error.

The judgment $\WrapApp{\tau}{\phi\ldots}{\tau'}$ attempts to apply the function type $\tau$ to the argument list $\phi\ldots$, performing unboxing as necessary.
When the argument list is empty and the function type is a nullary function or simple value type, (WrapAppFinished) simply returns the result type.

In the next rules, we use the syntax $a;~b$ for a list with $a$ as its head and $b$ as its tail.

When the actual argument and expected function argument modalities and types are equal, (WrapAppEqual) applies the function as normal, and continues along with any remaining arguments.

When the function expects a @Pure@ argument and is passed an @Element@ or an @Aggregate@, we perform reboxing as in (WrapAppPure).
This attempts to rebox the function result to the argument modality, and then continues by wrapping the remaining arguments.



\subsection{Expression}
With function application already defined, typechecking expressions in figure~\ref{fig:source:type:ctx} becomes quite standard.
The judgment $\Typecheck{\Gamma}{x}{\tau}$ means that under a context $\Gamma$, the expression $x$ has type and modality $\tau$.
Being a first-order language, the typing rule returns a first-order type rather than a function type.

Rules (TcVar) and (TcPrim) simply look up the variable or primitive in the environment.
While the environment contains function types $T_\to$, these rules only apply if the result is a nullary function with no arguments.

The rule (TcBox) allows any @Pure@ computation to be implicitly cast to another mode, such as @Element@ or @Aggregate@.
This is equivalent to boxing the expression.

There are two different application rules (TcAppVar) and (TcAppPrim), which simply look up the function type in different environments before using the boxed function application judgement from figure~\ref{fig:source:type:wrap}.
In these ruler we use ``$\ldots$'' as shorthand for finding the types of all arguments.

The rule (TcLet) typechecks its definition and adds it to the environment when typechecking the body.

For (TcFilter), the predicate must be an @Element@, as it is executed for each element of the input.
The rest of the computation must return an @Aggregate@ over the filtered input.

For (TcFold), the form of fold is $@fold@~v~@=@~x~@then@~x'$ where $v$ is the name of the fold binding, $x$ is its initial value, and $x'$ computes the successor value, based on the previous value of $v$.
The initial expression $x$ must be @Pure@ of some type $\tau$, and the successor expression $x'$ is typechecked with the fold binding set to $@Element@~\tau$ in the environment.
The result of the successor expression must also have type $@Element@~\tau$.
This is because the current value of the fold is available to the successor expression, as well as the current elements, but the results of other folds are not available.
In the remaining context, the fold value is only available as an @Aggregate@.

Finally, (TcGroup) requires its key or group ``by'' to be an @Element@, and the value to be an @Aggregate@.
It builds up a map from key to value, repeatedly applying the aggregate as new values are found.

\subsection{Single-pass restriction}

We now describe how this typesystem encodes the single-pass restriction: that is, that if a given query type-checks, it only needs to look at each element in the stream once.

First, look at an example that would require two passes over the data: maybe @filter open > mean open in count@.
In this case, $\mit{open}$ has type $\Elm{\NN}$ while $\mit{mean~open}$ has type $\Agg{\NN}$.
The primitive $>$ has type $\NN \to \NN \to \NN$ and can be boxed to either @Element@ or @Pure@, but not both.
This means that $\mit{open} > \mit{mean open}$ is a type error.

In Icicle, folding and boxing pure values are the only ways to produce @Aggregate@ types.
The other typing rules that refer to @Aggregate@s require an existing @Aggregate@ and do not produce an aggregate on their own.
This means that all @Aggregate@s must either be the result of folds, which in general require all their input before they can be computed, or pure computations.

There is also no way to take an @Aggregate@ and convert it to a @Pure@ or an @Element@.

The only way to require multiple passes over the data, therefore, is to have a @Pure@ or @Element@ computation that depends on the result of an @Aggregate@ computation.
And so on.



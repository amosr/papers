%!TEX root = ../Main.tex
\section{Types}
\label{s:Types}

\input{figures/Source-Type.tex}

%%% Types
In figure~\ref{fig:source:type:defs} we define the types.
We use $T$ for base types, of which we only have natural numbers and booleans.

Modalities are $M$, with @Aggregate@ meaning the result of some fold, @Element@ being an element of the input stream, and @Pure@ being a pure computation.
The modalities are defined so that @Aggregate@ and @Element@ computations cannot be mixed.
There is no way to turn an aggregate computation into an element computation, as aggregate computations are only available once the entire stream has been read.
Element computations must be explicitly folded over or aggregated in some way, in order to produce an aggregate computation based off it.
\TODO{Staged computation similarities}

The @Pure@ modality is actually the absence of a mode; this is simply made explicit for clarity.

Finally we define function types as $T_\to$, which can be a simple return type with a modality, or a function taking a modality argument and returning a function.
For simplicity of compilation, we have strictly disallowed higher order functions by requiring the argument to be a base type rather than a function type.

At various points in the following rules we will implicitly convert function types $T_\to$ to modal base types $M~T$; at these points function arrows are not allowed.



%%% Function application
In figure~\ref{fig:source:type:wrap} there are two judgments defined, which are both used for the type of function application.
In contrast to traditional modality type systems, we infer the boxing and unboxing of various modalities.

Informally, if a function expects an @Element@ and is passed a @Pure@ argument, we should box the argument into @Element@.
If a function expects a @Pure@ computation and is passed an @Element@, we must unbox the argument, apply the function, then rebox the result.
However, this reboxing can only occur if the result is @Pure@ or @Element@ - an @Aggregate@ result cannot be boxed into an @Element@.

The judgment $\WrapMode{\tau}{m}{\tau'}$, corresponds to reboxing the function return type $\tau$ into modality $m$, returning $\tau'$ as the boxed return type.
The rule (WrapModeArrow) simply recurses down through the function arguments, applying the judgment to the result.
The rule (WrapElement) applies when reboxing an @Element@ result as an @Element@, and similarly for (WrapAggregate).
For (WrapPure) the result type is a @Pure@, so it can be boxed to any mode.

The judgment $\WrapApp{\tau}{\phi}{\tau'}$ attempts to apply the function type $\tau$ to argument $\phi$, performing boxing and unboxing if necessary.
If both modalities and types are equal, (WrapApp) applies the function as normal.
When the function expects a @Pure@ argument and is passed an @Element@ or an @Aggregate@, we perform reboxing as in (WrapAppElement) and (WrapAppAggregate).
Finally, no matter what the function expects, if it is passed a @Pure@ it is simply boxed and applied as in (WrapAppPure), with no need to rebox the result.

\TODO{Or should we just use an explicitly box/unbox version?}



%%% Expressions
With function application already defined, typechecking expressions in figure~\ref{fig:source:type:exp} is quite simple.
The judgment $\Typecheck{\Gamma}{x}{\tau}$ means that under a context $\Gamma$, the expression $x$ has type $\tau$.
Rules (TcVar) and (TcPrim) simply look up the variable or primitive in the environment.
For (TcApp) we simply use the boxed function application judgment from figure~\ref{fig:source:type:wrap}.

\TODO{I think we need a box/cast rule for going from @Pure@ to @Element@ etc}


%%% Contexts
Figure~\ref{fig:source:type:ctx} shows the typing rules for contexts.
The judgment $\Typecheck{\Gamma}{c}{\tau}$ means that under a context $\Gamma$, the context $c$ has type $\tau$.
For simplicity, we reuse the same judgment for expressions and contexts.

The rule (TcLet) typechecks its definition and adds it to the environment when typechecking the body.

For (TcFilter), the predicate must be an @Element@, as it is executed for each element of the input.
The rest of the computation must return an @Aggregate@ over the filtered input.

For (TcFold), the form of fold is $@fold@~v~@=@~x~@then@~x'$ where $v$ is the name of the fold binding, $x$ is its initial value, and $x'$ computes the successor value, based on the previous value of $v$.
The initial expression $x$ must be @Pure@ of some type $\tau$, and the successor expression $x'$ is typechecked with the fold binding set to $@Element@~\tau$ in the environment.
The result of the successor expression must also have type $@Element@~\tau$.
This is because the current value of the fold is available to the successor expression, as well as the current elements, but the results of other folds are not available.
In the remaining context, the fold value is only available as an @Aggregate@.

Finally, (TcGroup) requires its key or group ``by'' to be an @Element@, and the value to be an @Aggregate@.
It builds up a map from key to value, repeatedly applying the aggregate as new values are found.



\input{figures/Source-Compile.tex}


\documentclass[preprint]{sigplanconf}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{mathptmx}
\usepackage{stmaryrd}
\usepackage{hyperref}
\usepackage{alltt}
\usepackage{url}
\usepackage{float}
\usepackage{style/utils}
\usepackage{style/code}
\usepackage{style/proof}
\usepackage{style/judgements}

% TODO: Fix up writing to use the words combinator and operator consistently
% We seem to be using "combinator" for the functions in the original program, 
% but "operator" for to name the abstract operation that combinator performs.

% \TODO{Cite work on clock inference for data flow languages. Eg http://www.irisa.fr/prive/talpin/papers/hldvt05.pdf}

% \TODO{Put this somewhere: Fusion-preventing dependencies are akin to barrier synchronisations in the Bulk Synchronous model of parallel computation. }

% -----------------------------------------------------------------------------
\begin{document}

\title{Fusing Filters with Integer Linear Programming}
% Better title?
% \title{Better fusion for filters}

\authorinfo{ 
  Amos Robinson$^\dagger$ 
  \and Ben Lippmeier$^\dagger$
  \and Gabriele Keller$^\dagger$ 
}{
  \vspace{5pt}
  \shortstack{
    $^\dagger$Computer Science and Engineering \\
    University of New South Wales, Australia \\[2pt]
    \textsf{\{amosr,benl,keller\}@cse.unsw.edu.au}
  }
}

\maketitle
\makeatactive

\begin{abstract}
The key to compiling functional, collection oriented array programs into efficient code is to minimise memory traffic.
Simply fusing subsequent array operations into a single computation is not sufficient; we also need to cluster \emph{separate} traversals of the same array into a single traversal.
Previous work demonstrated how Integer Linear Programming (ILP) can be used to cluster the operators in a general data-flow graph into subgraphs, which can be individually fused.
However, these approaches can only handle operations which preserve the size of the array, thereby missing out on some optimisation opportunities.
This paper addresses this shortcoming by extending the ILP approach with support for size-changing operations, using an external ILP solver to find good clusterings.
\end{abstract}


\category
	{D.3.4}
	{Programming Languages}
	{Processors---Compilers; Optimization}

\terms
	Languages, Performance

\keywords
	Arrays, Fusion, Haskell

\input{section/01-Introduction.tex}
\input{section/02-CNF.tex}
\input{section/03-SizeInference.tex}
\input{section/04-ILP.tex}
\input{section/05-Benchmarks.tex}
\input{section/06-Related.tex}
\input{section/07-Conclusion.tex}


\section*{Acknowledgements}
Many thanks are due to
Manuel Chakravarty,
Robert Clifton-Everest,
Erik de Castro Lopo,
Kai Engelhardt,
Bill Kroon,
Frederik M.\ Madsen,
Abdallah Saffidine,
Carter Schonwald,
and Jingling Xue
for enlightening discussions relating to this work.

\bibliographystyle{plain}
\bibliography{Main}

\end{document}



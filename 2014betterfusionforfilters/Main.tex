\documentclass[preprint]{sigplanconf}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{mathptmx}
\usepackage{hyperref}
\usepackage{alltt}
\usepackage{url}
\usepackage{float}
\usepackage{style/utils}
\usepackage{style/code}
\usepackage{style/proof}

% -----------------------------------------------------------------------------
\begin{document}
\title{Better fusion for filters}

\authorinfo{ 
  Amos Robinson$^\dagger$ 
  \and Ben Lippmeier$^\dagger$
  \and Manuel M. T. Chakravarty$^\dagger$
  \and Gabriele Keller$^\dagger$ 
}{
  \vspace{5pt}
  \shortstack{
    $^\dagger$Computer Science and Engineering \\
    University of New South Wales, Australia \\[2pt]
    \textsf{\{amosr,benl,chak,keller\}@cse.unsw.edu.au}
  }
}

\maketitle
\makeatactive

\begin{abstract}
Recent work on array fusion shows how to compile a specific class of data flow programs into single imperative loops. However, until now there has been no automated way to take the operator graph expressing a complete program and split it into subgraphs that can be individually fused. Finding a satisfactory clustering of operators is non-trivial, as we must find some balance between minimizing memory traffic and loop overhead, while maximizing cache locality. As real programs contain tens or hundreds of individual operators, performing an exhaustive search for an optimal clustering is not feasible, and greedy algorithms tend to produce poor solutions. Instead, we show how to formulate operator clustering as an \emph{integer linear programming} problem, and use an external library to find an good solution. 

% BL: I've removed uses of the word "optimal" here because we don't have a proper
% language cost model, and our solution is ultimately based on heuristics. ILP can find 
% an "optimal" solution for a heuristic cost metric, but this isn't the thing we're
% really trying to optimize.


\end{abstract}


\category
	{D.3.3}
	{Programming Languages}
	{Language Constructs and Features---Concurrent programming structures; Control structures; Abstract data types}

\terms
	Languages, Performance

\keywords
	Arrays, Fusion, Haskell


\input{section/01-Introduction.tex}
\input{section/XX-Programs.tex}
\input{section/02-CNF.tex}
\input{section/03-SizeInference.tex}
\input{section/04-ILP.tex}
\input{section/05-Related.tex}
\section{Conclusion}

\bibliographystyle{plain}
\bibliography{Main}

\end{document}

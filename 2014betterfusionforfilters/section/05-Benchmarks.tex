%!TEX root = ../Main.tex
\section{Benchmarks}
\label{s:Benchmarks}
\ben{Use the larger programs as benchmarks, or as running examples. We only need small, simple programs to demonstrate how the algorithm works.}

\begin{figure*}
$$\begin{array}{c}

\begin{tabular}{lrrrrrrrr}
                &   \multicolumn{2}{c}{Unfused}         & \multicolumn{2}{c}{Stream}
                & \multicolumn{2}{c}{Megiddo} &\multicolumn{2}{c}{\textbf{Ours}} \\
                & Time & Loops   & Time & Loops      & Time & Loops & Time & Loops   \\
\hline
Normalize2      & 1.88s & 5      & 1.64s & 4          & 1.82s & 3  & \textbf{1.59s} & \textbf{2}\\
Closest pair    & 3.83s & 6      & 3.33s & 5          & 2.92s & 3  & \textbf{2.92s} & \textbf{3}\\
QuadTree        & 5.22s & 8      & 5.22s & 8          & 4.72s & 2  & \textbf{4.72s} & \textbf{2}\\
\end{tabular}

\end{array}$$
\caption{Benchmark results}
\label{f:BenchResults}
\end{figure*}

Notes:
\begin{itemize}
% \item
% Normalize2 tested with around 1gb input data. This should be small enough that all intermediates fit in memory, but large enough not to fit in cache.
% \item
% ClosestPoints only tested with 80mb data.
\item
In some cases, the clusterings generated by the different methods were the same. In this case, the results are also the same. 
\item
The stream fusion benchmarks use the clustering that stream fusion \emph{would} use, but hand-fused and written in C.
\item
Programs were run five times with the same input data, and the fastest run was used.
\item
ILP solutions were created by hand-fusing based on the clustering of the implementation. In the future, this will be integrated to use data flow fusion.
\item
Benchmark programs are available at \url{https://github.com/amosr/papers/tree/master/2014betterfusionforfilters/benches}
\end{itemize}

\subsection{Example}
The normalize2 example is already in combinator normal form.
\begin{code}
 normalize2 :: Array Int -> Array Int
 normalize2 xs
  = let sum1 = fold   (+)  0   xs
        gts  = filter (> 0)    xs
        sum2 = fold   (+)  0   gts
        ys1  = map    (/ sum1) xs
        ys2  = map    (/ sum2) xs
    in (ys1, ys2)
\end{code}

First, we must calculate $split$ -- that is, those nodes which have no fusion-preventing path between them.
\begin{code}
split(sum1, gts)    = T
split(sum1, sum2)   = T
split(sum1, ys2)    = T
split(gts,  sum2)   = T
split(gts,  ys1)    = T
split(sum2, ys1)    = T
split(ys1,  ys2)    = T
\end{code}
We only need to create cluster variables for these.

Note that, in the objective function, the weights for $x_{sum1, sum2}$ and $x_{sum2, ys1}$ are both only 1, because they do not share any input arrays.

\begin{tabbing}
MMMMM   \= MMMMMMM \= M \= MMMMMMM \= M \= MMMMMMM \= \kill
Minimise   \> $25 \cdot x_{sum1, gts} + 1 \cdot x_{sum1,sum2} + 25 \cdot x_{sum1, ys2} +$ \\
           \> $25 \cdot x_{gts, sum2} + 25 \cdot x_{gts, ys1} + 1 \cdot x_{sum2, ys1} +$ \\
           \> $ 25 \cdot x_{ys1, ys2} + 5 \cdot c_{gts} + 5 \cdot c_{ys1} + 5 \cdot c_{ys2} $\\
Subject to \\
    \> $-5 \cdot x_{sum1, gts}$  \> $\le$ \> $\pi_{gts} - \pi_{sum1}$  \> $\le$ \> $5 \cdot x_{sum1, gts}$  \\
    \> $-5 \cdot x_{sum1, sum2}$ \> $\le$ \> $\pi_{sum2} - \pi_{sum1}$ \> $\le$ \> $5 \cdot x_{sum1, sum2}$ \\
    \> $-5 \cdot x_{sum1, ys2 }$ \> $\le$ \> $\pi_{ys2 } - \pi_{sum1}$ \> $\le$ \> $5 \cdot x_{sum1, ys2 }$ \\
    \> $-5 \cdot x_{gts,  ys1 }$ \> $\le$ \> $\pi_{ys1 } - \pi_{gts }$ \> $\le$ \> $5 \cdot x_{gts, ys1  }$ \\
    \> $-5 \cdot x_{sum2, ys1 }$ \> $\le$ \> $\pi_{ys1 } - \pi_{sum2}$ \> $\le$ \> $5 \cdot x_{sum2, ys1 }$ \\
    \> $-5 \cdot x_{ys1, ys2  }$ \> $\le$ \> $\pi_{ys2 } - \pi_{ys1 }$ \> $\le$ \> $5 \cdot x_{ys1, ys2  }$ \\
\\
    \> $   x_{gts, sum2 }$ \> $\le$ \> $\pi_{sum2} - \pi_{gts }$ \> $\le$ \> $5 \cdot x_{gts, sum2 }$ \\
\\
    \>                     \>       \> $\pi_{sum1} < \pi_{ys1}$ \\
    \>                     \>       \> $\pi_{sum2} < \pi_{ys2}$ \\
\\
    \> $ x_{gts,sum2} $    \> $\le$ \> $c_{gts}$ \\
\\
    \> $x_{sum1,sum2}$     \> $\le$ \> $x_{sum1, sum2}$ \\
    \> $x_{sum1, gts}$     \> $\le$ \> $x_{sum1, sum2}$ \\
    \> $x_{sum1, gts}$     \> $\le$ \> $x_{sum1, sum2}$ \\
\end{tabbing}
$parents(sum1,sum2)  = \{(sum1, gts)\}$

A minimal solution to this is
\begin{tabbing}
MMMMMMMMMMMMMMMMMMMMMMMMMM \= M \= \kill
$x_{sum1, gts}, x_{sum1, sum2}, x_{gts, sum2}, x_{ys1,  ys2}$
    \> $=$ \> $0$ \\
$x_{sum1, ys2}, x_{gts, ys1 }, x_{sum2, ys1}$
    \> $=$ \> $1$ \\
\\
$\pi_{sum1}, \pi_{gts }, \pi_{sum2}$
    \> $=$ \> $0$ \\
$\pi_{ys1 }, \pi_{ys2 }$
    \> $=$ \> $1$ \\
\\
$c_{gts}, c_{ys1}, c_{ys2}$           
    \> $=$ \> $0$ \\
\end{tabbing}
Looking at just the non-zero variables in the objective function, the value is
$25 \cdot x_{sum1,ys2} + 25 \cdot x_{gts,ys1} + 1 \cdot x_{sum2, ys1} = 51$.
It is worth noting that, for example, the objective could be reduced by fusing $x_{sum1,ys2}$ together.
However, this conflicts with other constraints. Since $x_{sum1, sum2} = 0$, the constraint requires that $\pi_{sum1} = \pi_{sum2}$, and another constraint requires $\pi_{sum2} < \pi_{ys2}$.
These constraints may not all hold, so a clustering that fused sum1 and ys2 together would not allow sum1 and sum2 to be fused together.

We can also calculate the objective function for the clustering used by stream fusion, to contrast and show that the constraints are valid.
To do this, the values of $x_{ij}$ variables are:
\begin{tabbing}
MMMMMMMMMMMMMMMMMMMMMMMMMM \= M \= \kill
$x_{gts, sum2}$
    \> $=$ \> $0$ \\
$x_{sum1, gts}, x_{sum1, sum2}, x_{ys1,  ys2}, x_{sum1, ys2}, x_{gts, ys1 }, x_{sum2, ys1}$
    \> $=$ \> $1$ \\
\end{tabbing}
If we add these extra equality constraints to the integer linear program and solve it, one possible solution is:
\begin{tabbing}
MMMMMMMMMMMMMMMMMMMMMMMMMM \= M \= \kill
$\pi_{sum1}, \pi_{gts }, \pi_{sum2}$
    \> $=$ \> $0$ \\
$\pi_{ys1 }, \pi_{ys2 }$
    \> $=$ \> $1$ \\
\\
$c_{gts}, c_{ys1}, c_{ys2}$           
    \> $=$ \> $0$ \\
\end{tabbing}
It is interesting to note that two nodes having equal $\pi_i$ values does not imply that the two nodes are fused together.
Conversely, however, different $\pi_i$ values do imply that two nodes are not fused together.

The objective function for this solution is
$25 \cdot x_{sum1, gts} + 1 \cdot x_{sum1,sum2} + 25 \cdot x_{sum1, ys2} + 25 \cdot x_{gts, ys1} + 1 \cdot x_{sum2, ys1} + 25 \cdot x_{ys1, ys2} = 102$.


\subsection{QuickHull}
The core of the QuickHull algorithm is very similar to @hull@, below.
Given a line and an array of points, the points are filtered to those above the line,
and the farthest point above the line is also found.

\begin{code}
hull :: (Point,Point) -> Array Point -> Array Point
hull line@(l,r) pts
 = let pts' = filter (above   line) pts
       ma   = fold   (maxFrom line) pts'
       hl   = hull   (l, ma)        pts'
       hr   = hull   (ma, r)        pts'
   in  hl  ++ hr
\end{code}

Stream fusion is unable to fuse the @pts'@ and @ma@ together, as @pts'@ is used multiple times and cannot be inlined into @ma@.
Similarly, Megiddo~\cite{megiddo1998optimal} is unable to fuse them together, as their iteration sizes are different.
Our formulation is able to fuse these together.

If the @fold@ is changed to operate over @pts@ instead of @pts'@, Megiddo's formulation \emph{is} able to fuse the two.
Interestingly, a programmer unaware of fusion would expect the original version to be faster, because @pts'@ is smaller than @pts@.

\begin{code}
 = let pts' = filter (above   line) pts
       ma   = fold   (maxFrom line) pts
\end{code}



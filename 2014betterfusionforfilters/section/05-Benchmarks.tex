%!TEX root = ../Main.tex
\section{Benchmarks}
\label{s:Benchmarks}

\begin{figure*}
$$\begin{array}{c}

\begin{tabular}{lrrrrrrrr}
                &   \multicolumn{2}{c}{Unfused}         & \multicolumn{2}{c}{Stream}
                & \multicolumn{2}{c}{Megiddo} &\multicolumn{2}{c}{\textbf{Ours}} \\
                & Time & Loops   & Time & Loops      & Time & Loops & Time & Loops   \\
\hline
Normalize2      & 1.88s & 5      & 1.64s & 4          & 1.82s & 3  & \textbf{1.59s} & \textbf{2}\\
Closest pair    & 3.83s & 6      & 3.33s & 5          & 2.92s & 3  & \textbf{2.92s} & \textbf{3}\\
QuadTree        & 5.22s & 8      & 5.22s & 8          & 4.72s & 2  & \textbf{4.72s} & \textbf{2}\\
\end{tabular}

\end{array}$$
\caption{Benchmark results}
\label{f:BenchResults}
\end{figure*}

We have run three benchmarks to constrast our clustering algorithm, Megiddo~\cite{megiddo1998optimal}'s clustering, the clustering produced by stream fusion~\cite{coutts2007streamfusion}, and no fusion at all.
The three benchmarks are the @normalize2@ example, finding the closest pair of points, and quadtree.
The benchmark programs are all hand-written, hand-fused C code based on the clustering.
Each program was run with the same input five times, and the minimum runtime was used.
Runtimes and the number of loops for each clustering are shown in Figure~\ref{f:BenchResults}.
In all cases, our clustering performs better than or as good as Megiddo's, and better than stream fusion and unfused.
Interestingly, stream fusion's clustering for @normalize2@ performs better than Megiddo's, despite having more loops, as stream fusion is able to remove the intermediate array.

Benchmark programs are available at \url{https://github.com/amosr/papers/tree/master/2014betterfusionforfilters/benches}.



\subsection{Normalize2}
To demonstrate the ILP formulation, the clustering of @normalize2@ is derived as follows.
\begin{code}
 normalize2 :: Array Int -> Array Int
 normalize2 xs
  = let sum1 = fold   (+)  0   xs
        gts  = filter (>   0)  xs
        sum2 = fold   (+)  0   gts
        ys1  = map    (/ sum1) xs
        ys2  = map    (/ sum2) xs
    in (ys1, ys2)
\end{code}

To make the program shorter and easier to work with, we use the optimised version.
First, we must calculate $split$ -- that is, those nodes which have no fusion-preventing path between them.
Any elements in the following sets have no fusion-preventing paths.
\[ \{ \{sum1, gts, sum2\}
 , \{sum1, ys2\}
 , \{gts, sum2, ys1\}
 , \{ys1, ys2\} \} \]

Note that, in the objective function, the weights for $x_{sum1, sum2}$ and $x_{sum2, ys1}$ are both only 1, because they do not share any input arrays.

\begin{tabbing}
MMMMM   \= MMMMMMM \= M \= MMMMMMM \= M \= MMMMMMM \= \kill
Minimise   \> $25 \cdot x_{sum1, gts} + 1 \cdot x_{sum1,sum2} + 25 \cdot x_{sum1, ys2} +$ \\
           \> $25 \cdot x_{gts, sum2} + 25 \cdot x_{gts, ys1} + 1 \cdot x_{sum2, ys1} +$ \\
           \> $ 25 \cdot x_{ys1, ys2} + 5 \cdot c_{gts} + 5 \cdot c_{ys1} + 5 \cdot c_{ys2} $\\
Subject to \\
    \> $-5 \cdot x_{sum1, gts}$  \> $\le$ \> $\pi_{gts} - \pi_{sum1}$  \> $\le$ \> $5 \cdot x_{sum1, gts}$  \\
    \> $-5 \cdot x_{sum1, sum2}$ \> $\le$ \> $\pi_{sum2} - \pi_{sum1}$ \> $\le$ \> $5 \cdot x_{sum1, sum2}$ \\
    \> $-5 \cdot x_{sum1, ys2 }$ \> $\le$ \> $\pi_{ys2 } - \pi_{sum1}$ \> $\le$ \> $5 \cdot x_{sum1, ys2 }$ \\
    \> $-5 \cdot x_{gts,  ys1 }$ \> $\le$ \> $\pi_{ys1 } - \pi_{gts }$ \> $\le$ \> $5 \cdot x_{gts, ys1  }$ \\
    \> $-5 \cdot x_{sum2, ys1 }$ \> $\le$ \> $\pi_{ys1 } - \pi_{sum2}$ \> $\le$ \> $5 \cdot x_{sum2, ys1 }$ \\
    \> $-5 \cdot x_{ys1, ys2  }$ \> $\le$ \> $\pi_{ys2 } - \pi_{ys1 }$ \> $\le$ \> $5 \cdot x_{ys1, ys2  }$ \\
\\
    \> $   x_{gts, sum2 }$ \> $\le$ \> $\pi_{sum2} - \pi_{gts }$ \> $\le$ \> $5 \cdot x_{gts, sum2 }$ \\
\\
    \>                     \>       \> $\pi_{sum1} < \pi_{ys1}$ \\
    \>                     \>       \> $\pi_{sum2} < \pi_{ys2}$ \\
\\
    \> $ x_{gts,sum2} $    \> $\le$ \> $c_{gts}$ \\
\\
    \> $x_{sum1,sum2}$     \> $\le$ \> $x_{sum1, sum2}$ \\
    \> $x_{sum1, gts}$     \> $\le$ \> $x_{sum1, sum2}$ \\
    \> $x_{sum1, gts}$     \> $\le$ \> $x_{sum1, sum2}$
\end{tabbing}

One minimal solution to this is:
\begin{tabbing}
MMMMMMMMMMMMMMMMMMMMMMMMMM \= M \= \kill
$x_{sum1, gts}, x_{sum1, sum2}, x_{gts, sum2}, x_{ys1,  ys2}$
    \> $=$ \> $0$ \\
$x_{sum1, ys2}, x_{gts, ys1 }, x_{sum2, ys1}$
    \> $=$ \> $1$ \\
\\
$\pi_{sum1}, \pi_{gts }, \pi_{sum2}$
    \> $=$ \> $0$ \\
$\pi_{ys1 }, \pi_{ys2 }$
    \> $=$ \> $1$ \\
\\
$c_{gts}, c_{ys1}, c_{ys2}$           
    \> $=$ \> $0$
\end{tabbing}
This minimal solution is not unique, however in this case the only other minimal solutions use different $\pi$ values, and denote the same clustering.

Looking at just the non-zero variables in the objective function, the value is
$25 \cdot x_{sum1,ys2} + 25 \cdot x_{gts,ys1} + 1 \cdot x_{sum2, ys1} = 51$.
It is worth noting that, for example, the objective could be reduced by fusing $x_{sum1,ys2}$ together.
However, this conflicts with other constraints. Since $x_{sum1, sum2} = 0$, the constraint requires that $\pi_{sum1} = \pi_{sum2}$, and another constraint requires $\pi_{sum2} < \pi_{ys2}$.
These constraints may not all hold, so a clustering that fused sum1 and ys2 together would not allow sum1 and sum2 to be fused together.

We can also calculate the objective function for the clustering used by stream fusion, to contrast and show that the constraints are valid.
To do this, the values of $x_{ij}$ variables are:
\begin{tabbing}
MMMMMMMMMMMMMMMMMMMMMMMMMM \= M \= \kill
$x_{gts, sum2}$
    \> $=$ \> $0$ \\
$x_{sum1, gts}, x_{sum1, sum2}, x_{ys1,  ys2}, x_{sum1, ys2}, x_{gts, ys1 }, x_{sum2, ys1}$
    \> $=$ \> $1$
\end{tabbing}
If we add these extra equality constraints to the integer linear program and solve it, one possible solution is:
\begin{tabbing}
MMMMMMMMMMMMMMMMMMMMMMMMMM \= M \= \kill
$\pi_{sum1}, \pi_{gts }, \pi_{sum2}$
    \> $=$ \> $0$ \\
$\pi_{ys1 }, \pi_{ys2 }$
    \> $=$ \> $1$ \\
\\
$c_{gts}, c_{ys1}, c_{ys2}$           
    \> $=$ \> $0$
\end{tabbing}
It is interesting to note that two nodes having equal $\pi_i$ values does not imply that the two nodes are fused together.
Conversely, however, different $\pi_i$ values do imply that two nodes are not fused together.

The objective function for this solution is
$25 \cdot x_{sum1, gts} + 1 \cdot x_{sum1,sum2} + 25 \cdot x_{sum1, ys2} + 25 \cdot x_{gts, ys1} + 1 \cdot x_{sum2, ys1} + 25 \cdot x_{ys1, ys2} = 102$.

\subsection{QuickHull}
The core of the QuickHull algorithm is very similar to @hull@, below.
Given a line and an array of points, the points are filtered to those above the line,
and the farthest point above the line is also found.

\begin{code}
hull :: (Point,Point) -> Array Point -> Array Point
hull line@(l,r) pts
 = let pts' = filter (above   line) pts
       ma   = fold   (maxFrom line) pts'
       hl   = hull   (l, ma)        pts'
       hr   = hull   (ma, r)        pts'
   in  hl  ++ hr
\end{code}

Stream fusion is unable to fuse the @pts'@ and @ma@ together, as @pts'@ is used multiple times and cannot be inlined into @ma@.
Similarly, Megiddo~\cite{megiddo1998optimal} is unable to fuse them together, as their iteration sizes are different.
Our formulation is able to fuse these together.

If the @fold@ is changed to operate over @pts@ instead of @pts'@, Megiddo's formulation \emph{is} able to fuse the two.
However, a programmer unaware of fusion would expect the original version to be faster, because @pts'@ is smaller than @pts@.


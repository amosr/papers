%!TEX root = ../Main.tex
%\eject

\begin{figure*}[ht!]
\begin{center}
\includegraphics[scale=0.5]{figures/ex1-compare.pdf}
\end{center}

\caption{Clusterings for normalize2 example: with stream fusion; our system; best imperative system}
\label{f:normalize2-cluterings}
\end{figure*}


\section{Combinator normal form}
\TODO{Mention that in the data flow graph we draw materialized vectors with a box around them.}
\TODO{Say a program in this form is just a textual representation of its data-flow graph. This is similar to Loop Communication Graphs (LCG) from \cite{sarkar1991optimization}, except that we avoid needing ``array access vectors'' that track which direction an array is accessed in. All our operators access elements from front to back, and we don't consider reversals. },  
We can accept functions written in \emph{combinator normal form}, which is a specialised form of first-order array programs detailed in Figure~\ref{f:CombinatorNormalForm}.
This form is a list of combinator bindings, where variables are split into scalar and array variables.
The main restriction is that worker functions may only reference scalar variables, nor may they include any array combinators.

We support the following combinators: $@map@_n$, @filter@, @fold@, @gather@ and @cross@.
Most of these are standard combinators except for @gather@ and @cross@, however $@map@_n$ differs slightly from usual @map@ in that it takes $n$ arrays of the same length, and applies the worker function to all elements of the same index.
The @gather@ combinator is equivalent to @gather xs ys = map (index xs) ys@.
However, as we support no @index@ operation, and worker functions may not refer to arrays, @gather@ is implemented as a primitive.
The @cross@ combinator takes two arrays, and returns the cartesian product of the two.

Since it is unlikely that an entire function will be comprised of these few combinators, we support one additional binding type: @external@.
This signifies that the referenced variables are used by a computation that is not a primitive combinator, and must be materialised fully in memory at this stage.
The @external@ also lists the variables produced by the external computation.
Without knowing the nature of the computation expressed by @external@, we must naturally take a conservative view, and allow no fusion to occur between at these points. They are, in effect, fusion barriers, forcing arrays and scalars to be fully computed before continuing.
This also allows us to support combinators other than those here, but as they must be treated conservatively will likely be less optimal than if they were implemented as primitives.

It is important to note that because of the purity of Haskell, we are free to take certain liberties when fusing the program.
None of the worker functions, nor any @external@ computations may produce visible side-effects; the only observable effect must be to produce their output.
This means that any reordering of the program is allowed, as long as mentioned variables are bound beforehand.
\input{figures/Program.tex}



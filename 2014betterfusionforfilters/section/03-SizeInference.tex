%!TEX root = ../Main.tex
\section{Size inference}

Knowing the relative sizes of loops is important for fusion.
While it \emph{is} technically possible to fuse loops of different sizes, it requires extra complexity to find the maximum of the loop sizes, and additional branches are required to only execute the smaller loop fewer times. For simplicity, we do away with this added complexity and only support fusion of equal sized loops. \emph{Size inference} is performed on the combinators to infer as much information as possible about the sizes of the resulting loops.

It is important to emphasise that we are only interested in relative sizes of arrays; which arrays are equal, and which may be smaller.
The $@map@_n$ combinators require all input arrays to be the same size, and their output is the same.
Since @fold@s do not produce arrays, they have no constraints.
@gather@ takes two arrays; the data and the indices. Its output size is the size of the indices.
The size of a @filter@'s output is most interesting; the exact size is not known until after it has been executed, only that it is less than or equal to the input size.
Similarly, the size of @external@ outputs is not known at all, and thus cannot be constrained.

Size inference has been explored before in the context of fusion by Chatterjee~\cite{chatterjee1991size}, but the only constraints they support are equality.
Their formulation has no filtering operations, and all array operations in their case generate the same size as at least one of the operation's inputs.
A more in-depth analysis has also been explored by Jay~\cite{jay1996shape} in the form of shape inference, which is built from primitives such as @cons@ and @nil@.
Since we have fewer primitives and simpler goals, our size inference does not need to be as complicated as Jay's shape inference.


Our formulation of size inference is very similar to type inference, a la \CITE.
First, constraints are generated for the bindings, such as equality among two rates, the conjunction of two constraints, and existentials.
If these constraints can be solved, the equality constraints are used to group the rates into equivalence classes.
Otherwise if the constraints are unable to be solved, the program cannot be assured to require no runtime size checks and will not be fused by our system.
After the constraints are generated and solved, each combinator is given an iteration size.
Two loops with the same iteration size can be fused together.

\newcommand{\constr}[1]{\llbracket #1 \rrbracket}
\newcommand{\hole}[0]{[]}
\newcommand{\fillhole}[2]{#1\left[#2\right]}

\subsection{Constraint generation}
Rates may either be some rate variable, $k_n$ where $n$ is the name of an array, or they may be a cross product of two rates.

\begin{tabbing}
MMMMM       \= MM \= MMMMMMMMMMM \= \kill
$rate$      \> @::=@ \> $k_n$               \> (rate variable)\\
            \> $~|$  \> $rate \times rate$  \> (cross product) \\
%            \> $~|$  \> $Filtered_n$        \> (output of @filter@s) \\
%            \> $~|$  \> $External_n$        \> (output of @external@s) \\
\end{tabbing}

The most important constraint is equality on two rates.
Context holes are used to simplify later definitions, and the notation $\fillhole{c}{d}$ is used to denote replacing all holes in $c$ with $d$.
Constraints may be joined together with $c \wedge d$, which requires both $c$ and $d$ to be satisfiable.
Forall quantifiers may be given an upper bound, and mean the constraint must be satisfiable for every rate.
Existential quantifiers simply state that there must exist a rate that satisfies the constraint.


\begin{tabbing}
MMMMM       \= MM \= MMMMMMMMMMM \= \kill
$C$          \> @::=@ \> $true$                                 \> (trivially true) \\
             \> $~|$  \> $\hole$                                \> (constraint hole) \\
             \> $~|$  \> $rate = rate$                          \> (equality constraint) \\
             \> $~|$  \> $C \wedge C$                           \> (conjunction) \\
             \> $~|$  \> $\forall k_n.\ C$                      \> (forall quantification) \\
             \> $~|$  \> $\exists k_n.\ C$                      \> (existential quantification)\\
%             \> $~|$  \> $\exists k_n \le rate.\ C$             \> (exists with upper bound)    \\
\end{tabbing}


Constraints are generated for a list of bindings.
As folds produce no constraints, they simply return a hole to be filled later.
Maps require their inputs and output to all have the same rate, so if there exists some rate that is equal to all its inputs, then that is the rate of the output.
As the output rate of a filter is unknown and cannot be constrained except for the upper bound, it is a forall: for all possible rates, the subconstraint must be satisfiable.
Similarly, external must work for any possible output, so the subconstraint must be satisfiable for all rates.

The final clauses show how the constraint holes are filled by constraints of subsequent bindings.
If there no bindings, the constraint is trivially true.

$$\begin{array}{lcrcl}
&&\constr{\_} & :: & binds \rightarrow C \\
\\
% MMMMMMMMMMMMMMMMMM \= MM \= \kill
% $\constr{\lambda scalars~arrays \to @let @binds@ in @x}$ \> $=$ \> $\forall_{a \in arrays} k_a. \constr{binds}$ \\

\constr{o &=& @fold @f@ @n}       &  = &  \hole \\
\constr{o &=& @map@_n~f~ns}       &  = &  \exists k_o.\ \bigwedge_{n \in ns}\{k_o = k_n\} \wedge \hole \\
\constr{o &=& @filter@~f~n}       &  = &  \forall k_o.\ \hole \\
\constr{o &=& @gather@~i~d}       &  = &  \exists k_o.\ k_o = k_i \wedge \hole \\
\constr{o &=& @cross@~a~b}        &  = &  \exists k_o.\ k_o = k_a \times k_b \wedge \hole \\
\constr{outs &=& @external@~ins}  &  = &  \forall_{o \in outs} k_o.\ \hole \\
\\
&&\constr{b;~bs}  &  = &  \fillhole{\constr{b}}{\constr{bs}}       \\
&&\constr{nil}    &  = &  true                          \\
\end{array}$$

\subsubsection{Examples}

As an example of constraint generation, here is the @normalize2@ program from earlier.
\begin{tabbing}
@MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM@  \= \kill
@normalize2 us@                     \> $\exists k_{us}.$      \\
@ = let sum1 = fold   (+) 0 us@     \>                      \\
@       gts  = filter (>0)  us@     \> $\forall k_{gts}.$ \\
@       sum2 = fold   (+) 0 gts@    \> \\
@       nor1 = map  (/sum1) us@     \> $\exists k_{nor1}.\ k_{nor1} = k_{us} \wedge$ \\
@       nor2 = map  (/sum2) us@     \> $\exists k_{nor2}.\ k_{nor2} = k_{us} \wedge$ \\
@   in (nor1, nor2)@                \> $true$ \\
\end{tabbing}
This constraint is satisfiable, with the equivalence classes being:
\newcommand{\eqclasses}[1]{
    \begin{tabbing}
        MM \= M \= \kill
        #1
    \end{tabbing}}
\newcommand{\eqclass}[2]{$#1$ \> $\in$ \> $\{#2\}$ \\}
\eqclasses{
    \eqclass{k_{us}}{k_{us}, k_{nor1}, k_{nor2}}
    \eqclass{k_{gts}}{k_{gts}}
}

The next example involves two filters using the same predicate.
Despite using the same predicate and input data, we produce different output rates for each filter.
\begin{tabbing}
@MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM@  \= \kill
@diff xs@                           \> $\exists k_{xs}.$ \\
@ = let ys1 = filter p xs@          \> $\forall k_{ys1}.$       \\
@       ys2 = filter p xs@          \> $\forall k_{ys2}.$       \\
@   in (ys1, ys2)@                  \> $true$                   \\
\end{tabbing}

This constraint is satisfiable, with the equivalence classes being:
\eqclasses{
    \eqclass{k_{xs}}    {k_{xs}}
    \eqclass{k_{ys1}}   {k_{ys1}}
    \eqclass{k_{ys2}}   {k_{ys2}}
}

This example is disallowed, as it would require a runtime check on the size of the @flt@ array.
\begin{tabbing}
@MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM@  \= \kill
@bad1 vs@                           \> $\exists k_{vs}.$ \\
@ = let flt   = filter p vs@        \> $\forall k_{flt}.$ \\
@       wrong = map2   f flt vs@    \> $\exists k_{wrong}.\ k_{wrong} = k_{flt}$ \\
                                    \> $\wedge k_{wrong} = k_{vs} \wedge$ \\
@   in  wrong@                      \> $true$
\end{tabbing}
This constraint is unsatisfiable, as by transitivity it can be simplified to $\exists k_{vs}.\ \forall k_{flt}.\ k_{vs} = k_{flt}$.
Obviously, there exists no sole size such that all sizes are equal to it.
As a result, no equivalence classes are generated for this example, and no fusion is performed.


Similarly, this example:
\begin{tabbing}
@MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM@  \= \kill
@bad2 vs@                           \> $\exists k_{vs}.$ \\
@ = let flt  = filter p  vs@        \> $\forall k_{flt}.$ \\
@       flt2 = filter p' vs@        \> $\forall k_{flt2}.$ \\
@       mix  = map2   f  flt flt2@  \> $\exists k_{mix}.\ k_{mix} = k_{flt}$ \\
                                    \> $\wedge k_{mix} = k_{flt2} \wedge$ \\
@   in  mix@                        \> $true$                               \\
\end{tabbing}
Again, transitivity here requires that $Filtered_{flt} = Filtered_{flt2}$, but since these are both concrete constructors, we cannot have such a constraint.
Basically, we are constraining two different filtered outputs to be the same size.
Operationally, implementing this would require to buffer both @flt@ and @flt2@, before checking the two lengths.



\subsection{Iteration size}
After the constraints are solved, each combinator is assigned a $rate$ as an iteration size -- the size of the loop required to generate the output.
It is important to note that for filters, the iteration size is different to the output size.
The iteration sizes, $tau_n$, are used to check whether two loops may be fused.
Any two iteration sizes in the same equivalence class are the same size, and so are fusible.
External computations are treated separately, as they cannot be fused with any other nodes.

\begin{tabbing}
MMMMM       \= MM \= MMMMMMMMMMM \= \kill
$\tau$       \> @::=@ \> $rate$                                  \> (loop size of some rate) \\
             \> $~|$  \> @external@                              \> (external and unfusible) \\
\end{tabbing}

Once the constraints are solved, known to be satisfiable, and sorted into equivalence classes, each combinator is assigned a rate.
Note that for a filter, the size of the output array $k_o$ is some existential that is less than or equal to $k_n$, but the actual loop size of the \emph{combinator} is equal to $k_n$.
This is because, in order to produce the filtered output, all elements of the input $n$ must be considered.


\begin{tabbing}
MM \= MM \= MMMMMMMMM \= MMMM \= MM \= \kill
$\tau$  \>$::$\> $binds \rightarrow name \rightarrow \tau$ \\
\\
$\tau_{bs,o}$    
            \> $|$ \> $o = @fold@~f~n$      \> $\in bs$ \> $=$ \> $k_n$ \\
            \> $|$ \> $o = @map@_n~f~ns$    \> $\in bs$ \> $=$ \> $k_o$ \\
            \> $|$ \> $o = @filter@~f~n$    \> $\in bs$ \> $=$ \> $k_n$ \\
            \> $|$ \> $o = @gather@~i~d$    \> $\in bs$ \> $=$ \> $k_i$ \\
            \> $|$ \> $o = @cross@~a~b$     \> $\in bs$ \> $=$ \> $k_a \times k_b$ \\
            \> $|$ \> $o = @external@~ins$  \> $\in bs$ \> $=$ \> $@external@$ \\
\end{tabbing}

Solving the generated equality constraints allows each rate to be grouped into equivalence classes.
All combinators whose constraints are in the same equivalence class have the same iteration size, and may be fused together.
These constraints are also used to rule out any programs that require runtime checks on array lengths during the program.

\subsection{Runtime checks on array lengths}
The $@map@_n$ combinator requires all its input arrays to be the same size.
We do not, however, want to perform runtime checks on the size of arrays before every combinator.
We have decided to only fuse programs that can be statically determined to require only array length checks at the start of execution. 

\TODO{We assign different rates to both @ys1@ and @ys2@ in this example.}
\begin{code}
 diff xs = let ys1 = filter p xs
               ys2 = filter p xs
           in  (ys1, ys2)
\end{code}


% \ben{This point is only relavant in the context of our specific implementation, which is no the focus of this paper. }
% Any other programs are simply left alone by our fusion system, potentially falling back to stream fusion.


We use the constraints to rule out any programs that require runtime checks on array lengths during the program. Firstly, filter and external constraints are only allowed to be mentioned after their binding site, as it is only at that stage that the lengths are actually known.

\ben{Refactor presentation to use the actual $\exists k. $ quantifier, as in ``The essence of ML type inference'', from ATAPL}

Secondly, it is not possible to constrain one constructor to equal another: $Filtered_n = External_n$ is invalid. Finally, any initial equality constraints, such as two input arrays being the same length, or one input array being the length of the cross product of two others, are dealt with by inserting runtime checks only at the start of the function.


The constraints $Filtered_n$, $External_n$ are treated as \emph{existential} constructors, bound at $n$. This means that such constraints are not able to be referred to before their bindings.
Intuitively, we know that the output of a @filter@ or an @external@ has \emph{some} length, but we don't know what its value is until after they have executed. Thus, constraining the input of something to be some exact length, before we know what the length is, is impossible.

Similarly, these constructors cannot be constrained to equal any other constructor. 
For example, $Filtered_n = External_n$ is invalid, as is $a \times b = Filtered_n$.
This corresponds to each equivalence class having \emph{at most} one distinct constructor associated with it. Any other elements of the equivalence class must be either the same constructor, or simply rate variables.

\subsection{Generators}

\begin{tabbing}
MMM       \= MM \= MMMMMM \= MM \= MMM \= MM \= \kill
$gen$   \> @::@  \> $\{constraint\}$  \> $\to$ \> $array$ \> $\to$ \> $\{array\}$ \\
MMMMMMM                 \= M  \= MMMMMMMM \= MM \= \kill
$gen(constrs, a)$ \> $|$ \> $a \le_c b \in constrs$ \> $=$ \> $\{b\}$                        \\
$gen(constrs, a)$ \> $|$ \> $a =_c b \in constrs$   \> $=$ \> $\bigcup gen(constrs, b)$                        \\
$gen(constrs, a)$ \> $|$ \> $otherwise$             \> $=$ \> $\emptyset$                        \\
\end{tabbing}

%\begin{lemma}
\textbf{Lemma: unique generation of filters}
For some bindings $bs$ and associated constraints $cs$, then
\[
valid(cs) \implies \forall x. (\exists y \in bs. gen(cs, x) = \{y\}) \vee gen(cs, x) = \emptyset
\]
%\end{lemma}


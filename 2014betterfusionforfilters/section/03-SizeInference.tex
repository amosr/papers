\section{Size inference}
Knowing the relative sizes of loops is important for fusion.
While it \emph{is} technically possible to fuse loops of different sizes, it requires extra complexity to find the maximum of the loop sizes, and additional branches are required to only execute the smaller loop fewer times.
For simplicity, we do away with this added complexity and only support fusion of equal sized loops.
\emph{Size inference} is performed on the combinators to infer as much information as possible about the sizes of the resulting loops.

It is important to emphasise that we are only interested in relative sizes of arrays; which arrays are equal, and which may be smaller.
The $@map@_n$ combinators require all input arrays to be the same size, and their output is the same.
Since @fold@s do not produce arrays, they have no constraints.
@gather@ takes two arrays; the data and the indices. Its output size is the size of the indices.
The size of a @filter@'s output is most interesting; the exact size is not known until after it has been executed, only that it is less than or equal to the input size.

Talk about the relation to Chatterjee\cite{chatterjee1991size}.

\begin{tabbing}
MMMMM       \= MM \= MMMM \= MM \= \kill
$constraint$\> @::=@ \> $array$  \> $=_c$ \> $array$ \\
            \> $~|$  \> $array$  \> $\le_c$ \> $array$ \\
\\
$constrs$  \> @::@  \> $bind$  \> $\to$ \> $\{constraint\}$ \\
MMMMMMMMMMMM                 \= MM  \= \kill
$constrs(o = @fold@~f~n)  $ \> $=$ \> $\{\}$     \\
$constrs(o = @map@_n~f~ns)$ \> $=$ \> $\{o =_c n~|~n \in ns\}$     \\
$constrs(o = @filter@~f~b)$ \> $=$ \> $\{o \le_c b\}$              \\
$constrs(o = @gather@~i~d)$ \> $=$ \> $\{o =_c i\}$ \\
\end{tabbing}

Then, for some program $\lambda\ldots~@let@~binds~@in@~\ldots$, find the union of all constraints:
$\bigcup_{b \in binds} constrs(b)$.
Since equality is transitive, the transitive closure of the constraints is useful.
For example, if $a =_c b$ and $b =_c c$, then $a =_c c$. 
After finding the transitive closure the constraints are partitioned into equivalence sets.
All combinators whose constraints are in the same equivalence set may be fused together.

\subsection{Disallowed filters}

Filtered constraints of the form $a \le_c b$ are special.
The actual size of the filtered output is unknown, and so cannot be constrained.
For example, consider the constraints generated by this program:
\begin{code}
test vs    =
 let flt   = filter p vs
     wrong = map2   f flt vs
 in  wrong
\end{code}
With the resulting constraints being $\{flt \le_c vs, wrong =_c flt, wrong =_c vs\}$.
By transitivity, we find that $flt \le_c flt$ - the size of the filtered output is upper-bounded by the size of the filtered output! 
Why is this bad?
Actually implementing this would require to buffer the entire contents of @flt@, so for simplicity we disallow it. Talk more about this.   

Similarly, this example:
\begin{code}
test vs    =
 let flt   = filter p  vs
     flt2  = filter p' vs
     wrong = map2   f  flt flt2
 in  wrong
\end{code}
Generates the constraints $\{flt \le_c vs, flt2 \le_c vs, flt =_c flt2\}$.
Here we are constraining two different filtered outputs to be the same size.
We disallow this.

Not all constraints on filtered data are disallowed, of course;
\begin{code}
test vs    =
 let flt   = filter p  vs
     xs    = map    f  flt
     ys    = map    g  flt
     sm    = map2   f  xs ys
 in  sm
\end{code}
This generates the constraints $\{flt \le_c vs, xs =_c flt, ys =_c flt, sm =_c xs, sm =_c ys\}$,
but this is perfectly valid, since the constraints are all actually based on @flt@.

\begin{tabbing}
MMM       \= MM \= MMMMMM \= MM \= \kill
$valid$   \> @::@  \> $\{constraint\}$  \> $\to$ \> $\mathbb{B}$ \\
MMMMMMMMMMMM                 \= MM  \= \kill
$valid(\{             \})$   \> $=$ \> $\top$  \\
$valid(\{a =_c b, rest\})$   \> $=$ \> $valid(subst~a:=b~in~rest)$  \\
$valid(\{a \le_c a, rest\})$ \> $=$ \> $\bot$                        \\
$valid(\{a \le_c b, rest\})$ \> $=$ \> $a \le_c \_ \not\in closure(rest) \wedge valid(rest)$                        \\
\\
$closure(\{\}, out)$                \> $=$ \> $out$ \\
$closure(\{a =_c b, rest\}, out)$   \> $=$ \> $closure(subst~a:=b~in~rest, subst~a:=b~in~out)$  \\
$closure(\{a \le_c b, rest\}, out)$ \> $=$ \> $closure(rest, \{a \le_c b\} \cup out)$ \\
\end{tabbing}



\subsection{Generators}

\begin{tabbing}
MMM       \= MM \= MMMMMM \= MM \= MMM \= MM \= \kill
$gen$   \> @::@  \> $\{constraint\}$  \> $\to$ \> $array$ \> $\to$ \> $\{array\}$ \\
MMMMMMM                 \= M  \= MMMMMMMM \= MM \= \kill
$gen(constrs, a)$ \> $|$ \> $a \le_c b \in constrs$ \> $=$ \> $\{b\}$                        \\
$gen(constrs, a)$ \> $|$ \> $a =_c b \in constrs$   \> $=$ \> $\bigcup gen(constrs, b)$                        \\
$gen(constrs, a)$ \> $|$ \> $otherwise$             \> $=$ \> $\emptyset$                        \\
\end{tabbing}

%\begin{lemma}
\textbf{Lemma: unique generation of filters}
For some bindings $bs$ and associated constraints $cs$, then
\[
valid(cs) \implies \forall x. (\exists y \in bs. gen(cs, x) = \{y\}) \vee gen(cs, x) = \emptyset
\]
%\end{lemma}



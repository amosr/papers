%!TEX root = ../Main.tex
\section{Size inference}
Knowing the relative sizes of loops is important for fusion.
While it \emph{is} technically possible to fuse loops of different sizes, it requires extra complexity to find the maximum of the loop sizes, and additional branches are required to only execute the smaller loop fewer times. For simplicity, we do away with this added complexity and only support fusion of equal sized loops. \emph{Size inference} is performed on the combinators to infer as much information as possible about the sizes of the resulting loops.

It is important to emphasise that we are only interested in relative sizes of arrays; which arrays are equal, and which may be smaller.
The $@map@_n$ combinators require all input arrays to be the same size, and their output is the same.
Since @fold@s do not produce arrays, they have no constraints.
@gather@ takes two arrays; the data and the indices. Its output size is the size of the indices.
The size of a @filter@'s output is most interesting; the exact size is not known until after it has been executed, only that it is less than or equal to the input size.
Similarly, the size of @external@ outputs is not known at all, and thus cannot be constrained.

Size inference has been explored before in the context of fusion by Chatterjee~\cite{chatterjee1991size}, but the only constraints they support are equality.
Their formulation has no filtering operations, and all array operations in their case generate the same size as at least one of the operation's inputs.
A more in-depth analysis has also been explored by Jay~\cite{jay1996shape} in the form of shape inference, which is built from primitives such as @cons@ and @nil@.
Since we have fewer primitives and simpler goals, our size inference does not need to be as complicated as Jay's shape inference.

Our formulation of size inference is very similar to type inference of HM(X)~\cite{odersky1999type}.
First, constraints are generated for the bindings, such as equality among two sizes, the conjunction of two constraints, and existentials.
If these constraints can be solved, the equality constraints are used to group the sizes into equivalence classes.
Otherwise if the constraints are unable to be solved, the program cannot be assured to require no runtime size checks and will not be fused by our system.
After the constraints are generated and solved, each combinator is given an iteration size.
Two loops with the same iteration size can be fused together.

\newcommand{\constr}[1]{\llbracket #1 \rrbracket}
\newcommand{\hole}[0]{[]}
\newcommand{\fillhole}[2]{#1\left[#2\right]}


% -----------------------------------------------------------------------------
\subsection{Constraint generation}
Sizes may either be some variable, $k_n$ where $n$ is the name of an array, or they may be a cross product of two sizes.
\begin{tabbing}
MMMMM   \= MM \= MMMMMMMMM \= \kill
$size$  \> @::=@ \> $k_n$               \> (size variable) \\
        \> $~|$  \> $size \times size$  \> (cross product)
\end{tabbing}

The most important constraint is equality on two sizes.
Context holes are used to simplify later definitions, and the notation $\fillhole{c}{d}$ is used to denote replacing all holes in $c$ with $d$.
Constraints may be joined together with $c \wedge d$, which requires both $c$ and $d$ to be satisfiable.
Forall quantifiers may be given an upper bound, and mean the constraint must be satisfiable for every size.
Existential quantifiers simply state that there must exist a size that satisfies the constraint.
\begin{tabbing}
MMMMM   \= MM \= MMMMMMMMM \= \kill
$C$     \> @::=@ \> $true$              \> (trivially true)             \\
%       \> $~|$  \> $\hole$             \> (constraint hole)            \\
        \> $~|$  \> $size = size$       \> (equality constraint)        \\
        \> $~|$  \> $C \wedge C$        \> (conjunction)                \\
        \> $~|$  \> $\forall k_n.\ C$   \> (forall quantification)      \\
        \> $~|$  \> $\exists k_n.\ C$   \> (existential quantification)
\end{tabbing}

Constraints are generated for a list of bindings.
As folds produce no constraints, they simply return a hole to be filled later.
Maps require their inputs and output to all have the same size, so if there exists some size that is equal to all its inputs, then that is the size of the output.
As the output size of a filter is unknown and cannot be constrained except for the upper bound, it is a forall: for all possible sizes, the subconstraint must be satisfiable.
Similarly, external must work for any possible output, so the subconstraint must be satisfiable for all sizes.

The final clauses show how the constraint holes are filled by constraints of subsequent bindings. If there no bindings, the constraint is trivially true.

$$\begin{array}{lcrcl}
&&\constr{\_} & :: & \textrm{function} \rightarrow C
\\[1ex]

\multicolumn{3}{l}{
    \constr{
       f~ \{ x_i \}~ \{ u_j \}^{\; j \gets 1..m}~ 
         =  \textrm{let}~ bs~ \textrm{in}~ exp
    }
}
        & = & \{ \exists u_j^k. \}^{j \gets 1..m}
           ~\constr{bs}

\\[2ex]

&&\constr{\_} & :: & \overline{bind} \rightarrow C 
\\[1ex]

&&\constr{~ \cdot ~}    
        & = &   true                          
\\[0.5ex]

\constr{u_o &=& @fold@~ f~ u_1;~ bs}
        & = &   \constr{bs}
\\[0.5ex]

\constr{u_o &=& @map@_n~ f~ \{u_i\}^{\;i \gets 1..n};~ bs }       
        & = &   \exists u_o^k.\ \bigwedge_{i \gets 1..n}\{u_o^k = u_i^k\} 
                \wedge \constr{bs}
\\[0.5ex]

\constr{u_o &=& @filter@~ f~ u_1;~ bs}
        & = &   \forall u_o^k.\ \constr{bs}
\\[0.5ex]

\constr{u_o &=& @gather@~ u_{ix}~ u_{data};~ bs}
        & = &   \exists u_o^k.\ u_o^k = u_{ix}^k
                ~\wedge~ \constr{bs}
\\[0.5ex]

\constr{u_o &=& @cross@~ u_a~ u_b;~ bs}
        & = &   \exists u_o^k.\ u_o^k = u_a^k \times u_b^k 
                ~\wedge~ \constr{bs}
\\[0.5ex]

\multicolumn{5}{l}{
\constr{x,~ \{u_i\}^{i \gets 1..n} = @external@~ \{v_j\}^{j \gets 1..m};~ bs}
          =     \{ \forall u_i^k. \}^{\; i \gets 1..n}
                ~\constr{bs}
}
\\[0.5ex]
\end{array}$$


% -----------------------------------------------------------------------------
\subsubsection{Examples}
As an example of constraint generation, here is the @normalize2@ program from earlier.
\begin{tabbing}
@MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM@  \= \kill
@normalize2 us@                     \> $\exists k_{us}.$      \\
@ = let sum1 = fold   (+) 0 us@     \>                      \\
@       gts  = filter (>0)  us@     \> $\forall k_{gts}.$ \\
@       sum2 = fold   (+) 0 gts@    \> \\
@       nor1 = map  (/sum1) us@     \> $\exists k_{nor1}.\ k_{nor1} = k_{us} \wedge$ \\
@       nor2 = map  (/sum2) us@     \> $\exists k_{nor2}.\ k_{nor2} = k_{us} \wedge$ \\
@   in (nor1, nor2)@                \> $true$ \\
\end{tabbing}
This constraint is satisfiable, with the equivalence classes being:
\newcommand{\eqclasses}[1]{
    \begin{tabbing}
        MM \= M \= \kill
        #1
    \end{tabbing}}
\newcommand{\eqclass}[2]{$#1$ \> $\in$ \> $\{#2\}$ \\}
\eqclasses{
    \eqclass{k_{us}}{k_{us}, k_{nor1}, k_{nor2}}
    \eqclass{k_{gts}}{k_{gts}}
}

The next example involves two filters using the same predicate.
Despite using the same predicate and input data, we produce different output sizes for each filter.
\begin{tabbing}
@MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM@  \= \kill
@diff xs@                           \> $\exists k_{xs}.$ \\
@ = let ys1 = filter p xs@          \> $\forall k_{ys1}.$       \\
@       ys2 = filter p xs@          \> $\forall k_{ys2}.$       \\
@   in (ys1, ys2)@                  \> $true$                   \\
\end{tabbing}

This constraint is satisfiable, with the equivalence classes being:
\eqclasses{
    \eqclass{k_{xs}}    {k_{xs}}
    \eqclass{k_{ys1}}   {k_{ys1}}
    \eqclass{k_{ys2}}   {k_{ys2}}
}

This example is disallowed, as it would require a runtime check on the size of the @flt@ array.
\begin{tabbing}
@MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM@  \= \kill
@bad1 vs@                           \> $\exists k_{vs}.$ \\
@ = let flt   = filter p vs@        \> $\forall k_{flt}.$ \\
@       wrong = map2   f flt vs@    \> $\exists k_{wrong}.\ k_{wrong} = k_{flt}$ \\
                                    \> $\wedge k_{wrong} = k_{vs} \wedge$ \\
@   in  wrong@                      \> $true$
\end{tabbing}
This constraint is unsatisfiable, as by transitivity it can be simplified to $\exists k_{vs}.\ \forall k_{flt}.\ k_{vs} = k_{flt}$.
Obviously, there exists no sole size such that all sizes are equal to it.
As a result, no equivalence classes are generated for this example, and no fusion is performed.


Similarly, this example is not allowed, as it would require a runtime check to determine that the output of two filters @flt@ and @flt2@ are the same size.
\begin{tabbing}
@MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM@  \= \kill
@bad2 vs@                           \> $\exists k_{vs}.$ \\
@ = let flt  = filter p  vs@        \> $\forall k_{flt}.$ \\
@       flt2 = filter p' vs@        \> $\forall k_{flt2}.$ \\
@       mix  = map2   f  flt flt2@  \> $\exists k_{mix}.\ k_{mix} = k_{flt}$ \\
                                    \> $\wedge k_{mix} = k_{flt2} \wedge$ \\
@   in  mix@                        \> $true$                               \\
\end{tabbing}
Again, by transitivity of equality this constraint can be simplified to $\forall k_{flt}.\ \forall k_{flt2}.\ k_{flt} = k_{flt2}$.
It is easy to see that this constraint is unsatisfiable.

\subsection{Constraint validity}
Checking whether a constraint is valid can be done using Herbrand unification, similar to HM(X)~\cite{odersky1999type}.
The difference, however, is that our constraints include both universal and existential quantifiers, whereas HM(X) only includes existential quantifiers.
Herbrand unification is still applicable on constraints with both quantifiers~\cite{buss1995herbrand}.
This is achieved by performing \emph{Herbrandization}, the dual of Skolemization, to remove the universal quantifiers and replace them with Herbrand functions.
After the universal quantifiers have been removed, the constraint can easily be put into prenex form, and validated using the same unification method as HM(X).

For example, a simple, but invalid constraint such as:
\[ \exists x.\ \forall y.\ x = y \]
will have its universal quantifier removed, and all references to $y$ changed to $f_y(x)$, with $x$ as an argument to $f$ as $x$ is in scope of the quantifier.
The result being:
\[ \exists x.\ x = f_y(x) \]
This resulting constraint, while satisfiable for certain values of $f_y$, is not satisfiable for all values of $f_y$, and so is not valid.

After the constraint has been validated, equivalence classes are easily constructed.
The transitive closure of the equality constraints, ignoring quantifiers, is generated.
As there are no disjunction, negation or implication all equality constraints will be applicable, regardless of the quantifiers used.


\subsection{Iteration size}
After the constraints are validated and equivalence classes generated, each combinator is assigned a $size$ as an iteration size -- the number of iterations in the loop required to generate the output.
It is important to note that for filters, the iteration size is not the output size, but is instead the size of the input.
The output size of a filter is, however, a \emph{subsize} of the input's size, as not only is it known to be less than or equal to its input in size, it is also generated depending on the input.
The iteration sizes, $\tau_n$, are used to check whether two loops may be fused.
Any two iteration sizes in the same equivalence class are the same size, and so are fusible.
The difference from previous work is that loops of different iteration sizes \emph{can} be fused, if one is a subsize of the other, and the subsize's \emph{generator} is fused together it as well.
Basically, operations on filtered data can be fused with operations on the original data, if it is fused with the filter as well.
External computations are treated separately, as they cannot be fused with any other nodes.

\begin{tabbing}
MMMMM       \= MM \= MMMMMMMMMMM \= \kill
$\tau$       \> @::=@ \> $size$                                  \> (known size) \\
             \> $~|$  \> @external@                              \> (external and unfusible) \\
\end{tabbing}

Once the constraints are solved, known to be satisfiable, and sorted into equivalence classes, each combinator is assigned a size.
Note that for a filter, the size of the output array $k_o$ is some existential that is less than or equal to $k_n$, but the actual loop size of the \emph{combinator} is equal to $k_n$.
This is because, in order to produce the filtered output, all elements of the input $n$ must be considered.


\begin{tabbing}
MM \= MM \= MMMMMMMMM \= MMMM \= MM \= \kill
$\tau$  \>$::$\> $binds \rightarrow name \rightarrow \tau$ \\
\\
$\tau_{bs,o}$    
            \> $|$ \> $o = @fold@~f~n$      \> $\in bs$ \> $=$ \> $k_n$ \\
            \> $|$ \> $o = @map@_n~f~ns$    \> $\in bs$ \> $=$ \> $k_o$ \\
            \> $|$ \> $o = @filter@~f~n$    \> $\in bs$ \> $=$ \> $k_n$ \\
            \> $|$ \> $o = @gather@~i~d$    \> $\in bs$ \> $=$ \> $k_i$ \\
            \> $|$ \> $o = @cross@~a~b$     \> $\in bs$ \> $=$ \> $k_a \times k_b$ \\
            \> $|$ \> $o = @external@~ins$  \> $\in bs$ \> $=$ \> $@external@$ \\
\end{tabbing}

After the generated equality constraints are solved, and sizes are grouped into equivalence classes, the combinators with iteration sizes in the same equivalence class can be fused together.

\subsection{Subsizes and generators}
Unlike previous work, we do allow combinators with different iteration sizes to be fused together.
For example, an operation on filtered data may be fused with the filter operation that generates the data, even though the iteration sizes are different.



\begin{tabbing}
MMM       \= MM \= MMMMMM \= MM \= MMM \= MM \= \kill
$gen$   \> @::@  \> $\{constraint\}$  \> $\to$ \> $array$ \> $\to$ \> $\{array\}$ \\
MMMMMMM                 \= M  \= MMMMMMMM \= MM \= \kill
$gen(constrs, a)$ \> $|$ \> $a \le_c b \in constrs$ \> $=$ \> $\{b\}$                        \\
$gen(constrs, a)$ \> $|$ \> $a =_c b \in constrs$   \> $=$ \> $\bigcup gen(constrs, b)$                        \\
$gen(constrs, a)$ \> $|$ \> $otherwise$             \> $=$ \> $\emptyset$                        \\
\end{tabbing}

%\begin{lemma}
\textbf{Lemma: unique generation of filters}
For some bindings $bs$ and associated constraints $cs$, then
\[
valid(cs) \implies \forall x. (\exists y \in bs. gen(cs, x) = \{y\}) \vee gen(cs, x) = \emptyset
\]
%\end{lemma}


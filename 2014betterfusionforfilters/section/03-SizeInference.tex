%!TEX root = ../Main.tex
\section{Size inference}





Knowing the relative sizes of loops is important for fusion.
While it \emph{is} technically possible to fuse loops of different sizes, it requires extra complexity to find the maximum of the loop sizes, and additional branches are required to only execute the smaller loop fewer times.
For simplicity, we do away with this added complexity and only support fusion of equal sized loops.
\emph{Size inference} is performed on the combinators to infer as much information as possible about the sizes of the resulting loops.

After size inference, the goal is to have a function that only requires runtime size checks at the start of the function. This outlaws certain filter constraints.

It is important to emphasise that we are only interested in relative sizes of arrays; which arrays are equal, and which may be smaller.
The $@map@_n$ combinators require all input arrays to be the same size, and their output is the same.
Since @fold@s do not produce arrays, they have no constraints.
@gather@ takes two arrays; the data and the indices. Its output size is the size of the indices.
The size of a @filter@'s output is most interesting; the exact size is not known until after it has been executed, only that it is less than or equal to the input size.
Similarly, the size of @external@ outputs is not known at all, and thus cannot be constrained.

Talk about the relation to Chatterjee\cite{chatterjee1991size}.

\begin{tabbing}
MMMMM       \= MM \= MMMMMM \= \kill
$rate$      \> @::=@ \> $Filtered_n$        \> (output of @filter@s) \\
            \> $~|$  \> $External_n$        \> (output of @external@s) \\
            \> $~|$  \> $rate \times rate$  \> (cross product) \\
            \> $~|$  \> $k_n$               \> (rate variable)\\
\end{tabbing}

Finding the relative sizes of arrays is very similar to type inference.
A rate can be either some rate variable, a cross product of two rates, or an unknown, but fixed, filtered or external output.
For each binding, a set of equality constraints are created.

\begin{tabbing}
MMMMM       \= MM \= MMMM \= MM \= \kill
$constrs$  \> @::@  \> $bind$  \> $\to$ \> $\{var = rate\}$ \\
MMMMMMMMMMMMMM               \= MM  \= \kill
$constrs(o = @fold@~f~n)  $ \> $=$ \> $\{\}$     \\
$constrs(o = @map@_n~f~ns)$ \> $=$ \> $\{o = n~|~n \in ns\}$     \\
$constrs(o = @filter@~f~b)$ \> $=$ \> $\{o = Filtered_b\}$              \\
$constrs(o = @gather@~i~d)$ \> $=$ \> $\{o = i\}$ \\
$constrs(o = @cross@~a~b) $ \> $=$ \> $\{o = a \times b\}$ \\
$constrs(outs = @external@~ins) $ \> $=$ \> $\{o = External_o~|~o \in outs\}$ \\
\end{tabbing}

Then, for some program $\lambda\ldots~@let@~binds~@in@~\ldots$, find the union of all constraints:
$\bigcup_{b \in binds} constrs(b)$.
The generated equalities are grouped into equivalence classes.

All combinators whose constraints are in the same equivalence class have the same iteration size, and may be fused together.
These constraints are also used to rule out any programs that require runtime checks on array lengths during the program.
In other words, only programs that can be statically determined to require only array length checks at the start of execution.

\TODO{Well\ldots} note that $Filtered_n$, $External_n$ are \emph{existential} constructors, bound at $n$.
This basically translates into them not being able to be referred to \emph{before} their bindings.
Also note that there can be at most one distinct constructor per equivalence class.
Go through the examples below.


\begin{code}
 normalize2 :: Array Int -> Array Int
 normalize2 us                   {us   = k_us}
  = let sum1 = fold   (+) 0 us   
        gts  = filter (>0)  us   {gts  = Filtered_us}
        sum2 = fold   (+) 0 gts   
        nor1 = map  (/sum1) us   {nor1 = k_us}
        nor2 = map  (/sum2) us   {nor2 = k_us}
    in (nor1, nor2)
\end{code}

\begin{code}
 { us   : us = nor1 = nor2
 , gts  : Filtered_us }
\end{code}

\subsection{Disallowed filters}

Filtered constraints of the form $a \le_c b$ are special.
The actual size of the filtered output is unknown, and so cannot be constrained.
For example, consider the constraints generated by this program:
\begin{code}
test vs    =
 let flt   = filter p vs
     wrong = map2   f flt vs
 in  wrong
\end{code}
With the resulting constraints being $\{flt \le_c vs, wrong =_c flt, wrong =_c vs\}$.
By transitivity, we find that $flt \le_c flt$ - the size of the filtered output is upper-bounded by the size of the filtered output! 
Why is this bad?
Actually implementing this would require to buffer the entire contents of @flt@, so for simplicity we disallow it. Talk more about this.   

Similarly, this example:
\begin{code}
test vs    =
 let flt   = filter p  vs
     flt2  = filter p' vs
     wrong = map2   f  flt flt2
 in  wrong
\end{code}
Generates the constraints $\{flt \le_c vs, flt2 \le_c vs, flt =_c flt2\}$.
Here we are constraining two different filtered outputs to be the same size.
We disallow this.

Not all constraints on filtered data are disallowed, of course;
\begin{code}
test vs    =
 let flt   = filter p  vs
     xs    = map    f  flt
     ys    = map    g  flt
     sm    = map2   f  xs ys
 in  sm
\end{code}
This generates the constraints $\{flt \le_c vs, xs =_c flt, ys =_c flt, sm =_c xs, sm =_c ys\}$,
but this is perfectly valid, since the constraints are all actually based on @flt@.



\subsection{Generators}

\begin{tabbing}
MMM       \= MM \= MMMMMM \= MM \= MMM \= MM \= \kill
$gen$   \> @::@  \> $\{constraint\}$  \> $\to$ \> $array$ \> $\to$ \> $\{array\}$ \\
MMMMMMM                 \= M  \= MMMMMMMM \= MM \= \kill
$gen(constrs, a)$ \> $|$ \> $a \le_c b \in constrs$ \> $=$ \> $\{b\}$                        \\
$gen(constrs, a)$ \> $|$ \> $a =_c b \in constrs$   \> $=$ \> $\bigcup gen(constrs, b)$                        \\
$gen(constrs, a)$ \> $|$ \> $otherwise$             \> $=$ \> $\emptyset$                        \\
\end{tabbing}

%\begin{lemma}
\textbf{Lemma: unique generation of filters}
For some bindings $bs$ and associated constraints $cs$, then
\[
valid(cs) \implies \forall x. (\exists y \in bs. gen(cs, x) = \{y\}) \vee gen(cs, x) = \emptyset
\]
%\end{lemma}


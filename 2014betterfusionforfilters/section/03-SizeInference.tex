%!TEX root = ../Main.tex
\section{Size inference}

Knowing the relative sizes of loops is important for fusion.
While it \emph{is} technically possible to fuse loops of different sizes, it requires extra complexity to find the maximum of the loop sizes, and additional branches are required to only execute the smaller loop fewer times. For simplicity, we do away with this added complexity and only support fusion of equal sized loops. \emph{Size inference} is performed on the combinators to infer as much information as possible about the sizes of the resulting loops.

It is important to emphasise that we are only interested in relative sizes of arrays; which arrays are equal, and which may be smaller.
The $@map@_n$ combinators require all input arrays to be the same size, and their output is the same.
Since @fold@s do not produce arrays, they have no constraints.
@gather@ takes two arrays; the data and the indices. Its output size is the size of the indices.
The size of a @filter@'s output is most interesting; the exact size is not known until after it has been executed, only that it is less than or equal to the input size.
Similarly, the size of @external@ outputs is not known at all, and thus cannot be constrained.

Size inference has been explored before in the context of fusion by Chatterjee~\cite{chatterjee1991size}, but the only constraints they support are equality.
Their formulation has no filtering operations, and all array operations in their case generate the same size as at least one of the operation's inputs.
A more in-depth analysis has also been explored by Jay~\cite{jay1996shape} in the form of shape inference, which is built from primitives such as @cons@ and @nil@.
Since we have fewer primitives and simpler goals, our size inference does not need to be as complicated as Jay's shape inference.


\newcommand{\constr}[1]{\llbracket #1 \rrbracket}
\newcommand{\hole}[0]{[]}
\newcommand{\fillhole}[2]{#1\Left[#2\right]}

\begin{tabbing}
MMMMM       \= MM \= MMMMMMMMMMM \= \kill
$rate$      \> @::=@ \> $k_n$               \> (rate variable)\\
            \> $~|$  \> $rate \times rate$  \> (cross product) \\
%            \> $~|$  \> $Filtered_n$        \> (output of @filter@s) \\
%            \> $~|$  \> $External_n$        \> (output of @external@s) \\
\\
$C$          \> @::=@ \> $true$                                 \> (trivially true) \\
             \> $~|$  \> $\hole$                                \> (constraint hole) \\
             \> $~|$  \> $rate = rate$                          \> (equality constraint) \\
             \> $~|$  \> $C \wedge C$                           \> (conjunction) \\
             \> $~|$  \> $\forall k_n.\ C$                      \> (forall quantification) \\
             \> $~|$  \> $\exists k_n.\ C$                      \> (exists with no bounds)\\
             \> $~|$  \> $\exists k_n \le rate.\ C$             \> (exists with upper bound)    \\
\\
$\tau$       \> @::=@ \> $rate$                                  \> (loop size of some rate) \\
             \> $~|$  \> @external@                              \> (external and unfusible) \\
\end{tabbing}

Finding the relative sizes of arrays is very similar to type inference.
A rate can be either some rate variable, a cross product of two rates, or an unknown, but fixed, filtered or external output.
For each binding, a set of equality constraints are created.

$$\begin{array}{lcrcl}
&&\constr{\_} & :: & binds \rightarrow C \\
\\
% MMMMMMMMMMMMMMMMMM \= MM \= \kill
% $\constr{\lambda scalars~arrays \to @let @binds@ in @x}$ \> $=$ \> $\forall_{a \in arrays} k_a. \constr{binds}$ \\

\constr{o &=& @fold @f@ @n}       &  = &  \hole \\
\constr{o &=& @map@_n~f~ns}       &  = &  \forall k_o.\ \bigwedge_{n \in ns}\{k_o = k_n\} \wedge \hole \\
\constr{o &=& @filter@~f~n}       &  = &  \exists k_o \le k_n.\ \hole \\
\constr{o &=& @gather@~i~d}       &  = &  \forall k_o.\ k_o = k_i \wedge \hole \\
\constr{o &=& @cross@~a~b}        &  = &  \forall k_o.\ k_o = k_a \times k_b \wedge \hole \\
\constr{outs &=& @external@~ins}  &  = &  \exists_{o \in outs} k_o.\ \hole \\
\\
&&\constr{b;~bs}  &  = &  \fillhole{\constr{b}}{\constr{bs}}       \\
&&\constr{nil}    &  = &  true                          \\
\end{array}$$


\begin{tabbing}
MM \= MM \= MMMMMMMMM \= MMMM \= MM \= \kill
$\tau$  \>$::$\> $binds \rightarrow name \rightarrow \tau$ \\
\\
$\tau_{bs,o}$    
            \> $|$ \> $o = @fold@~f~n$      \> $\in bs$ \> $=$ \> $k_n$ \\
            \> $|$ \> $o = @map@_n~f~ns$    \> $\in bs$ \> $=$ \> $k_o$ \\
            \> $|$ \> $o = @filter@~f~n$    \> $\in bs$ \> $=$ \> $k_n$ \\
            \> $|$ \> $o = @gather@~i~d$    \> $\in bs$ \> $=$ \> $k_i$ \\
            \> $|$ \> $o = @cross@~a~b$     \> $\in bs$ \> $=$ \> $k_a \times k_b$ \\
            \> $|$ \> $o = @external@~ins$  \> $\in bs$ \> $=$ \> $@external@$ \\
\end{tabbing}

Note that for a filter, the size of the output array $k_o$ is some existential that is less than or equal to $k_n$, but the actual loop size of the \emph{combinator} is equal to $k_n$.
This is because, in order to produce the filtered output, all elements of the input $n$ must be considered.

Solving the generated equality constraints allows each rate to be grouped into equivalence classes.
All combinators whose constraints are in the same equivalence class have the same iteration size, and may be fused together.
These constraints are also used to rule out any programs that require runtime checks on array lengths during the program.


\begin{code}
 normalize2 :: Array Int -> Array Int
 normalize2 us                   {us   = k_us}
  = let sum1 = fold   (+) 0 us   
        gts  = filter (>0)  us   {gts  = Filtered_gts}
        sum2 = fold   (+) 0 gts   
        nor1 = map  (/sum1) us   {nor1 = k_us}
        nor2 = map  (/sum2) us   {nor2 = k_us}
    in (nor1, nor2)
\end{code}

\subsection{Runtime checks on array lengths}
The $@map@_n$ combinator requires all its input arrays to be the same size.
We do not, however, want to perform runtime checks on the size of arrays before every combinator.
We have decided to only fuse programs that can be statically determined to require only array length checks at the start of execution. 

\TODO{We assign different rates to both @ys1@ and @ys2@ in this example.}
\begin{code}
 diff xs = let ys1 = filter p xs
               ys2 = filter p xs
           in  (ys1, ys2)
\end{code}


% \ben{This point is only relavant in the context of our specific implementation, which is no the focus of this paper. }
% Any other programs are simply left alone by our fusion system, potentially falling back to stream fusion.


We use the constraints to rule out any programs that require runtime checks on array lengths during the program. Firstly, filter and external constraints are only allowed to be mentioned after their binding site, as it is only at that stage that the lengths are actually known.

\ben{Refactor presentation to use the actual $\exists k. $ quantifier, as in ``The essence of ML type inference'', from ATAPL}

Secondly, it is not possible to constrain one constructor to equal another: $Filtered_n = External_n$ is invalid. Finally, any initial equality constraints, such as two input arrays being the same length, or one input array being the length of the cross product of two others, are dealt with by inserting runtime checks only at the start of the function.


The constraints $Filtered_n$, $External_n$ are treated as \emph{existential} constructors, bound at $n$. This means that such constraints are not able to be referred to before their bindings.
Intuitively, we know that the output of a @filter@ or an @external@ has \emph{some} length, but we don't know what its value is until after they have executed. Thus, constraining the input of something to be some exact length, before we know what the length is, is impossible.

Similarly, these constructors cannot be constrained to equal any other constructor. 
For example, $Filtered_n = External_n$ is invalid, as is $a \times b = Filtered_n$.
This corresponds to each equivalence class having \emph{at most} one distinct constructor associated with it. Any other elements of the equivalence class must be either the same constructor, or simply rate variables.

\subsubsection{Examples}
Following are a few examples of disallowed programs.
Consider the constraints generated by this program:
\begin{code}
test vs    =
 let flt   = filter p vs        { flt   = Filtered_flt }
     wrong = map2   f flt vs    { wrong = flt = vs     }
 in  wrong
\end{code}
By transitivity, we find that $vs = Filtered_{flt}$, but $vs$ is bound before @flt@.
Operationally, actually implementing this would require to buffer the entire contents of @flt@, then check the length of @flt@ against the length of @vs@.


Similarly, this example:
\begin{code}
test vs    =
 let flt   = filter p  vs       { flt   = Filtered_flt  }
     flt2  = filter p' vs       { flt2  = Filtered_flt2 }
     wrong = map2   f  flt flt2 { wrong = flt = flt2    }
 in  wrong
\end{code}
Again, transitivity here requires that $Filtered_{flt} = Filtered_{flt2}$, but since these are both concrete constructors, we cannot have such a constraint.
Basically, we are constraining two different filtered outputs to be the same size.
Operationally, implementing this would require to buffer both @flt@ and @flt2@, before checking the two lengths.

\subsection{Generators}

\begin{tabbing}
MMM       \= MM \= MMMMMM \= MM \= MMM \= MM \= \kill
$gen$   \> @::@  \> $\{constraint\}$  \> $\to$ \> $array$ \> $\to$ \> $\{array\}$ \\
MMMMMMM                 \= M  \= MMMMMMMM \= MM \= \kill
$gen(constrs, a)$ \> $|$ \> $a \le_c b \in constrs$ \> $=$ \> $\{b\}$                        \\
$gen(constrs, a)$ \> $|$ \> $a =_c b \in constrs$   \> $=$ \> $\bigcup gen(constrs, b)$                        \\
$gen(constrs, a)$ \> $|$ \> $otherwise$             \> $=$ \> $\emptyset$                        \\
\end{tabbing}

%\begin{lemma}
\textbf{Lemma: unique generation of filters}
For some bindings $bs$ and associated constraints $cs$, then
\[
valid(cs) \implies \forall x. (\exists y \in bs. gen(cs, x) = \{y\}) \vee gen(cs, x) = \emptyset
\]
%\end{lemma}


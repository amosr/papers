%!TEX root = ../Main.tex
\section{Elimination}
\label{s:Elimination}

\subsection{Preliminary transforms}

A-normalisation is relatively easy, however any expressions in the initialiser of each fold can be lifted out as a separate fold with initialiser and an identity expression (that is, the name of the fold).
Any expressions to be lifted out from the update expression should be created as new @let@ bindings.
They cannot necessarily be created as @fold@ bindings because the expression will not work for the initial expression, if it refers to other lets or loop iterators.

Some simple forwarding can be applied, such as lets of variables, and folds where the initial and update expressions are the same.
Fold initials could be forwarded to other initials, but fold updates cannot always be forwarded to other updates, as the first evaluation of the other update will refer to the forwarder's initial.

So-called ``melting'' can be performed, splitting apart pairs into multiple bindings, arrays of pairs into pairs of arrays, and so on.
Key-value maps can be similarly split into a special map from key to index, and an array for the values.
Splitting these complex structures into their constituent parts exposes more opportunities for elimination removal.
The following program computes the mean of the loop elements. Here, the sum and count are both computed, and stored in a pair.

\begin{code}
loop item {
  stage {
    fold sumcount
     = (0, 0)
     then
       ( fst sumcount + item
       , snd sumcount + 1);

    fold mean
     = fst sumcount / snd sumcount
     then
       fst sumcount / snd sumcount;
  }
}
\end{code}

If another query were to compute the sum as well, it is not obvious looking at the two expressions that @sum@ and @fst sumcount@ are equivalent:
\begin{code}
loop item {
  stage {
    fold sum
     = 0
     then
       sum + item;
  }
}
\end{code}

Now, by splitting the @sumcount@ pair into two bindings named @sumcount1@ and @sumcount2@, it becomes easier to see that the definitions of @sum@ and @sumcount1@ are equivalent.
\begin{code}
loop item {
  stage {
    fold sumcount1
     = 0
     then
       sumcount1 + item;

    fold sumcount2
     = 0
     then
       sumcount2 + 1;

    fold mean
     = sumcount1 / sumcount2
     then
       sumcount1 / sumcount2;
  }
}
\end{code}



\subsection{Strongly connected components}
Up to now, the reason for the stages has only been briefly mentioned.
The idea is that each stage should contain a single set of mutually recursive folds.
Then, each set of mutually recursive folds becomes a single unit to be operated on for removing duplicates.

The type system enforces that mutually recursive folds must be in the same stage, but not that each stage can only contain one set of mutually recursive folds.
We find the strongly connected components of the program graph, so that each strongly connected component.
When treating the program as a graph, each binding is a node and references to a fold @f@ as either @f@ for the current value, or @new f@ for the new value, both count as edges to @f@.

As a contrived example, we have bindings @sum@ and @count@ on their own, and another pair of bindings @a@ and @b@ which depend on each other, as well as on @sum@ and @count@.
\begin{code}
loop item {
  stage {
    fold count = 0 then count + 1;

    fold sum   = 0 then sum   + item;

    fold a     = 1 then count + b;
    fold b     = 0 then sum + new a;
  }
}
\end{code}

The graph looks something like this.
\begin{code}
  count     sum
    |        |
    V        V
    a <----> b
\end{code}

The strongly connected components are found, and ripped out into separate stages.
The bindings of each stage are sorted topologically, but this time only @new@ references count as edges in the graph.
This is because @new@ references require the new, updated value of the fold, but other references use the value that is already available at the start of the iteration.
Hence, only @new@ references impose an ordering constraint.
\begin{code}
loop item {
  stage {
    fold count = 0 then count + 1;
  }
  stage {
    fold sum   = 0 then sum   + item;
  }
  stage {
    fold a     = 1 then count + b;
    fold b     = 0 then sum + new a;
  }
}
\end{code}

\subsection{Stage layers}
Once we have a list or set of stages, we can perform a topological ordering over the stages themselves.
In this case, a whole stage becomes a node in the graph, and edges are any references between stages.

The topological ordering is used for denoting execution order between the stages, but also tells us which stages need to be checked against each other, to remove duplicates.
Each stage could be checked against all other stages, but this would be wasteful.

We can look at the topological ordering of stages as layers of the same depth.
In the @count/sum/ab@ example, @count@ and @sum@ are together on the top layer, while @ab@ is on the second layer.

Each stage need only be compared with those on the same layer, and those on the layer directly above.
In fact, of those on the layer above, it only needs to be compared with those it refers to.
\TODO{Justify this further.}
Because the stages have already been split apart, we also need only check against those with equal or greater number of bindings.

\subsection{Duplicate removal}
Because the stages have already been split apart, we can only replace a stage 


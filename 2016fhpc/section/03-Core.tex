%!TEX root = ../Main.tex
\section{Intermediate language}
\label{s:IcicleCore}

\begin{figure}

\begin{tabbing}
MMM \= MM \= MMMM \= MM \= MMMMMM \= \kill
$\mi{PlanX}$
\GrammarDef
  $x~|~V~|~\mi{PlanP}~\ov{\mi{PlanX}}~|~\lam{x}\mi{PlanX}$
\\
$\mi{PlanP}$
\GrammarDef
  $\mi{Prim}~|~@mapUpdate@~|~@mapEmpty@~|~@mapMap@~|~@mapZip@$
\\
\\
$\mi{Plan}$
\GrammarDef
  $@plan@~x$ \> $\{~\ov{x~:~T;}~\}$
\\
  \> \> $@before@$ \> $\{~\ov{x~:~T~=~\mi{PlanX};}~\}$ \\
  \> \> $@folds@$  \> $\{~\ov{x~:~T~=~\mi{PlanX}~@then@~\mi{PlanX};}~\}$ \\
  \> \> $@after@$  \> $\{~\ov{x~:~T~=~\mi{PlanX};}~\}$ \\
  \> \> $@return@$ \> $\{~\ov{x~:~T~=~x;}~\}$ \\
\end{tabbing}



\caption{Query Plan Grammar}
\label{fig:core:grammar}
\end{figure}

The intermediate language can be thought of as similar to a query plan in other databases.
Queries in the source language are converted to query plans, and then query plans on the same table are fused together.
Common subexpression elimination, partial evaluation and other optimisations are performed at the query plan level.

The grammar for the intermediate language is given in figure~\ref{fig:core:grammar}.
Expressions can be variables, values, applications of primitives or anonymous functions.
Function definitions and uses are not allowed in expressions here, as their definitions are inlined before converting to query plans.
Anonymous functions are only allowed as arguments to primitives: they cannot be applied or stored in variables.
The $\mi{Plan}$ itself is split into stages of computation, which correspond to the modal stages in the Source query.
The first stage, @before@, is used for pure computations which do not depend on any stream values at all.
The next stage, @folds@, defines the @Element@ computations and how they are converted into @Aggregate@ computations.
Next are @after@ which correspond to @Aggregate@ computations, occurring after the entire stream has been seen.
Finally, the @return@ specifies the output values of the query; a single query will have only one output value, but the result of fusion can have many outputs.

Before we can convert our example query to a query plan, we must look at the definitions of the functions @count@, @sum@, @mean@ and @last@.
Here, we have definitions of @count@ and @sum@.
Count is defined by starting from zero, and incrementing by one for each element.
Sum starts at zero and increments its argument.

\begin{code}
    function count
     = fold c = 0 then c + 1;

    function sum (e : Element Real)
     = fold s = 0 then s + e;
\end{code}

Mean can then defined as sum divided by the count.
\begin{code}
    function mean (e : Element Real)
     = sum e / count;
\end{code}

Here, we have the function definition for @last k@, which is defined as a fold with an initial value to describe a missing date @NO_DATE@\footnote{In our production compiler, @last@ returns a @Maybe@.}, and the update value is the current @k@.
The current fold value is bound to @l@ but is not used.

\begin{code}
    function last (d : Element Date)
     = fold l = NO_DATE then d;
\end{code}

% \begin{code}
%   query avg = let k    = last key in
%               let avgs = group key of mean value
%               in  lookup k avgs
% \end{code}

We now inline these function definitions before converting to a query plan, renaming as necessary.
This is guaranteed to terminate because no recursion is allowed in function definitions.
\begin{code}
  query avg
   =    let lst = (fold l = NO_DATE then key)
     in let map = group key of
                  ( (fold s = 0 then s + value)
                  / (fold c = 0 then c + 1) )
     in let ret = lookup lst map
     in     ret
\end{code}

We can now convert to the query plan.
The binding @lst@ becomes a single fold, initialised to @NO_DATE@ and updated with @key@.
\begin{code}
  plan kvs { key : Date; value : Real;      }
  folds    { fL  : Date = NO_DATE then key  }
  after    { lst : Date = fL                }
\end{code}

For the @map@ binding, each fold inside the group becomes its own map which is initialised to empty: fold @s@ becomes @gS@, and @c@ becomes @gC@.
At each iteration the fold update is applied to the value in the map, or the fold's initial value if the key is not yet present.
After all iterations are finished, the two maps are joined together and the pairs are divided.
\begin{code}
  folds  { gS  : Map Date Real = mapEmpty
           then mapUpdate gS key 0 (\s. s + value)

         ; gC  : Map Date Real = mapEmpty
           then mapUpdate gC key 0 (\c. c + 1) }

  after  { map : Map Date Real
            = mapMap (\s c. s / c) (mapZip gS gC) }
\end{code}

It would be possible to convert this as a map of pairs of the sum and count.
Keeping this as two separate maps rather than a map of pairs exposes more opportunities for common subexpression elimination when fusion occurs.
For example, another query @group key of count@ can reuse the already constructed @gC@ map.

Finally, the @ret@ binding contains no folds and is an @Aggregate@ type, so is converted to an @after@.
The return associates the query's name with its final value.
\begin{code}
  after  { ret : Real = lookup lst map }
  return { avg : Real = ret }
\end{code}


If we wish to fuse query plans on the same table together, it is as simple as giving the @before@, @folds@ and @after@ bindings unique names and appending each part of the plan together.
The names of the returns and the column names stay the same.
It is the single-pass restriction that makes fusion so simple, as it implies there are no fusion-preventing dependencies between any two query plans: if there were, the source query would have required multiple passes.

Efficient imperative loops can be generated from these query plans in a similar way to previous work on flow fusion~\cite{lippmeier2013data}.


%!TEX root = ../Main.tex
\section{Related}
\label{s:Related}

The Icicle approach to bounded buffering is simpler but less expressive than both existing synchronous data flow languages such as Lucy~\cite{mandel2010lucy}, as well as our prior work on flow fusion~\cite{lippmeier2013data}. These systems perform a clock, or \emph{rate} analysis of the streams being processed. Stream combinators with multiple inputs, such as @zip@, are assigned types that require their stream arguments to have the same rate --- meaning that elements always arrive in lockstep and the combinators themselves do not need to perform their own buffering.

\TODO{fill}
Advances in dataflow programming languages~\cite{johnston2004advances}.
Survey of stream processing~\cite{stephens1997survey}.
How to architect a query compiler~\cite{shaikhha2016architect}.
StreamIt~\cite{thies2002streamit}.

Kahn process networks are a flexible alternative to MapReduce~\cite{vrba2009kahn}.
Scheduling dynamic dataflow~\cite{buck1993scheduling}.
Co-iterative characterization~\cite{caspi1998co}.

Compare to short-cut fusion~\cite{coutts2007stream}.

Continuous queries are a similar domain, where a single query keeps running and producing results, as data is received.
In \cite{munagala2007optimization} there are multiple queries based off the same incoming stream.
Each queries is filtered by a conjunction of predicates, where each single predicate may be used by multiple queries.
If these predicates are expensive to compute, it is certainly not ideal to compute these for each query.

Multi-query data analysis\cite{andrade2003efficient} describes a similar problem, where they have multiple queries over the same data that run periodically.
By grouping the multiple queries together, more optimisations can be performed than when treating the queries separately.
However, this is only for a small set of built-in aggregates, and does not deal with mutually recursive definitions.



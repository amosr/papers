%!TEX root = ../Main.tex
\section{Introduction}
\label{s:Introduction}

At Ambiata, we peform feature generation for machine learning applications by executing many thousands of simple queries over terabytes worth of compressed data.\footnote{In 2016 this was a lot of data.}
For such applications we must automatically fuse these separate queries and be sure that the result can be executed in a single pass over the input.
We also ingest tens of gigabytes of new data per day, and must incrementally update existing features without recomputing them all from scratch.
Our feature generation process is executed in parallel on hundreds of nodes on a cloud based system, and if we performed neither fusion or incremental update then the cost of the computation would begin to exceed the salaries of the developers.

For example queries, suppose we have a table, @stocks@, containing daily open and close prices for a set of companies. We want to compute the number of days where the open price exceeded the close price, and vice versa. We also want the mean of the open price for days in which the open price exceeded the close price. In Icicle we write the three queries as follows:

\begin{code}
table stocks { open : Int, close : Int }
query 
  more  = filter open > close of count;
  less  = filter open < close of count;
  mean  = filter open > close of sum open / count;
\end{code}
In the above code, @open > close@ and @close < open@ are the filter predicates, and @count@ counts the number of times the body of each filter construct was entered.
% We describe this construct more fully in \REF

A joint query like this can be converted to a back-end language such as SQL, but doing so by hand is tedious and error prone. As the three queries use different filter predicates we cannot use a single @SELECT@ statement and a @WHERE@ expression to implement the filter. We instead need to lift each predicate to an expression-level conditional:
\begin{code}
  SELECT COUNT(IF(open > close, 1, 0))
       , COUNT(IF(open < close, 1, 0))
       , SUM  (IF(open > close, open, 0))
       / COUNT(IF(open > close, 1, 0))
  FROM stocks;
\end{code}
As we see, the result of query fusion also tends to have many common sub expressions, and we wish to guarantee that the duplicates in the fused result are eliminated.

Joint queries such as the stocks example can be evaluated in a streaming, incremental fashion, which allows the result to be updated as we receive new data. As a counter example, suppose we have a table with two fields @key@ and @value@, and we wish to find the mean of values whose key matches the last one in the table. We might try something like:
\begin{code}
  table kvs { key : Date; value : Real }
  query avg = let k = last key
              in  filter (key == k) of mean value;
\end{code}
Unfortunately, although the \emph{result} we desire is computable, the \emph{algorithm} implied by the above query cannot be evaluated in an inceremental fashion. While streaming through the table we always have access to the last key in the stream, but to select rows that match this key would require that we stream through the table again from the start. We need a better solution. With this in mind, the contributions of this paper are:
\begin{itemize}
\item
We present a domain specific language that guarantees any set of queries on a shared input table can be fused, and allows the query results to be updated as new data is received\sref{s:IcicleSource};

\item
We present a fold-based intermediate language, which allows the query fusion transformation to be a simple matter of appending two intermediate programs\sref{s:IcicleCore};

\item
We present production benchmarks of Icicle compiled code which outperforms an existing R feature generation system by several orders of magnitude, and are on par with standard Unix utilities that conceptually perform less work\sref{s:Benchmarks}.
\end{itemize}

% on our smaller single-disk datasets
% BEN: for streaming applications the absolute size of the input size doesn't affect the performance, so we don't need to apologise.

This work is related to stream processing languages such as Lucy~\cite{mandel2010lucy} and Streamit~\cite{thies2002streamit}, but without the need for clock or deadlock analyses.
It is also related to continuous queries~\cite{arasu2003cql} where queries produce results as rows are inserted or deleted, except we can compute arbitrary folds and do not support deletion.

Our implementation is available at \url{https://github.com/ambiata/icicle}.

